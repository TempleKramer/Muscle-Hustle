{"ast":null,"code":"import{__assign}from\"tslib\";import{equal}from\"@wry/equality\";import{DeepMerger}from\"../utilities/index.js\";import{reobserveCacheFirst}from\"./ObservableQuery.js\";import{isNonEmptyArray,graphQLResultHasError,canUseWeakMap}from\"../utilities/index.js\";import{NetworkStatus,isNetworkRequestInFlight}from\"./networkStatus.js\";;var destructiveMethodCounts=new(canUseWeakMap?WeakMap:Map)();function wrapDestructiveCacheMethod(cache,methodName){var original=cache[methodName];if(typeof original===\"function\"){cache[methodName]=function(){destructiveMethodCounts.set(cache,(destructiveMethodCounts.get(cache)+1)%1e15);return original.apply(this,arguments);};}}function cancelNotifyTimeout(info){if(info[\"notifyTimeout\"]){clearTimeout(info[\"notifyTimeout\"]);info[\"notifyTimeout\"]=void 0;}}var QueryInfo=function(){function QueryInfo(queryManager,queryId){if(queryId===void 0){queryId=queryManager.generateQueryId();}this.queryId=queryId;this.listeners=new Set();this.document=null;this.lastRequestId=1;this.subscriptions=new Set();this.stopped=false;this.dirty=false;this.observableQuery=null;var cache=this.cache=queryManager.cache;if(!destructiveMethodCounts.has(cache)){destructiveMethodCounts.set(cache,0);wrapDestructiveCacheMethod(cache,\"evict\");wrapDestructiveCacheMethod(cache,\"modify\");wrapDestructiveCacheMethod(cache,\"reset\");}}QueryInfo.prototype.init=function(query){var networkStatus=query.networkStatus||NetworkStatus.loading;if(this.variables&&this.networkStatus!==NetworkStatus.loading&&!equal(this.variables,query.variables)){networkStatus=NetworkStatus.setVariables;}if(!equal(query.variables,this.variables)){this.lastDiff=void 0;}Object.assign(this,{document:query.document,variables:query.variables,networkError:null,graphQLErrors:this.graphQLErrors||[],networkStatus:networkStatus});if(query.observableQuery){this.setObservableQuery(query.observableQuery);}if(query.lastRequestId){this.lastRequestId=query.lastRequestId;}return this;};QueryInfo.prototype.reset=function(){cancelNotifyTimeout(this);this.dirty=false;};QueryInfo.prototype.getDiff=function(variables){if(variables===void 0){variables=this.variables;}var options=this.getDiffOptions(variables);if(this.lastDiff&&equal(options,this.lastDiff.options)){return this.lastDiff.diff;}this.updateWatch(this.variables=variables);var oq=this.observableQuery;if(oq&&oq.options.fetchPolicy===\"no-cache\"){return{complete:false};}var diff=this.cache.diff(options);this.updateLastDiff(diff,options);return diff;};QueryInfo.prototype.updateLastDiff=function(diff,options){this.lastDiff=diff?{diff:diff,options:options||this.getDiffOptions()}:void 0;};QueryInfo.prototype.getDiffOptions=function(variables){var _a;if(variables===void 0){variables=this.variables;}return{query:this.document,variables:variables,returnPartialData:true,optimistic:true,canonizeResults:(_a=this.observableQuery)===null||_a===void 0?void 0:_a.options.canonizeResults};};QueryInfo.prototype.setDiff=function(diff){var _this=this;var oldDiff=this.lastDiff&&this.lastDiff.diff;this.updateLastDiff(diff);if(!this.dirty&&!equal(oldDiff&&oldDiff.result,diff&&diff.result)){this.dirty=true;if(!this.notifyTimeout){this.notifyTimeout=setTimeout(function(){return _this.notify();},0);}}};QueryInfo.prototype.setObservableQuery=function(oq){var _this=this;if(oq===this.observableQuery)return;if(this.oqListener){this.listeners.delete(this.oqListener);}this.observableQuery=oq;if(oq){oq[\"queryInfo\"]=this;this.listeners.add(this.oqListener=function(){var diff=_this.getDiff();if(diff.fromOptimisticTransaction){oq[\"observe\"]();}else{reobserveCacheFirst(oq);}});}else{delete this.oqListener;}};QueryInfo.prototype.notify=function(){var _this=this;cancelNotifyTimeout(this);if(this.shouldNotify()){this.listeners.forEach(function(listener){return listener(_this);});}this.dirty=false;};QueryInfo.prototype.shouldNotify=function(){if(!this.dirty||!this.listeners.size){return false;}if(isNetworkRequestInFlight(this.networkStatus)&&this.observableQuery){var fetchPolicy=this.observableQuery.options.fetchPolicy;if(fetchPolicy!==\"cache-only\"&&fetchPolicy!==\"cache-and-network\"){return false;}}return true;};QueryInfo.prototype.stop=function(){if(!this.stopped){this.stopped=true;this.reset();this.cancel();this.cancel=QueryInfo.prototype.cancel;this.subscriptions.forEach(function(sub){return sub.unsubscribe();});var oq=this.observableQuery;if(oq)oq.stopPolling();}};QueryInfo.prototype.cancel=function(){};QueryInfo.prototype.updateWatch=function(variables){var _this=this;if(variables===void 0){variables=this.variables;}var oq=this.observableQuery;if(oq&&oq.options.fetchPolicy===\"no-cache\"){return;}var watchOptions=__assign(__assign({},this.getDiffOptions(variables)),{watcher:this,callback:function callback(diff){return _this.setDiff(diff);}});if(!this.lastWatch||!equal(watchOptions,this.lastWatch)){this.cancel();this.cancel=this.cache.watch(this.lastWatch=watchOptions);}};QueryInfo.prototype.resetLastWrite=function(){this.lastWrite=void 0;};QueryInfo.prototype.shouldWrite=function(result,variables){var lastWrite=this.lastWrite;return!(lastWrite&&lastWrite.dmCount===destructiveMethodCounts.get(this.cache)&&equal(variables,lastWrite.variables)&&equal(result.data,lastWrite.result.data));};QueryInfo.prototype.markResult=function(result,document,options,cacheWriteBehavior){var _this=this;var graphQLErrors=isNonEmptyArray(result.errors)?result.errors.slice(0):[];this.reset();if('incremental'in result&&isNonEmptyArray(result.incremental)){var mergedData_1=this.getDiff().result;var merger_1=new DeepMerger();result.incremental.forEach(function(_a){var data=_a.data,path=_a.path,errors=_a.errors;for(var i=path.length-1;i>=0;--i){var key=path[i];var isNumericKey=!isNaN(+key);var parent_1=isNumericKey?[]:{};parent_1[key]=data;data=parent_1;}if(errors){graphQLErrors.push.apply(graphQLErrors,errors);}mergedData_1=merger_1.merge(mergedData_1,data);});result.data=mergedData_1;}this.graphQLErrors=graphQLErrors;if(options.fetchPolicy==='no-cache'){this.updateLastDiff({result:result.data,complete:true},this.getDiffOptions(options.variables));}else if(cacheWriteBehavior!==0){if(shouldWriteResult(result,options.errorPolicy)){this.cache.performTransaction(function(cache){if(_this.shouldWrite(result,options.variables)){cache.writeQuery({query:document,data:result.data,variables:options.variables,overwrite:cacheWriteBehavior===1});_this.lastWrite={result:result,variables:options.variables,dmCount:destructiveMethodCounts.get(_this.cache)};}else{if(_this.lastDiff&&_this.lastDiff.diff.complete){result.data=_this.lastDiff.diff.result;return;}}var diffOptions=_this.getDiffOptions(options.variables);var diff=cache.diff(diffOptions);if(!_this.stopped){_this.updateWatch(options.variables);}_this.updateLastDiff(diff,diffOptions);if(diff.complete){result.data=diff.result;}});}else{this.lastWrite=void 0;}}};QueryInfo.prototype.markReady=function(){this.networkError=null;return this.networkStatus=NetworkStatus.ready;};QueryInfo.prototype.markError=function(error){this.networkStatus=NetworkStatus.error;this.lastWrite=void 0;this.reset();if(error.graphQLErrors){this.graphQLErrors=error.graphQLErrors;}if(error.networkError){this.networkError=error.networkError;}return error;};return QueryInfo;}();export{QueryInfo};export function shouldWriteResult(result,errorPolicy){if(errorPolicy===void 0){errorPolicy=\"none\";}var ignoreErrors=errorPolicy===\"ignore\"||errorPolicy===\"all\";var writeWithErrors=!graphQLResultHasError(result);if(!writeWithErrors&&ignoreErrors&&result.data){writeWithErrors=true;}return writeWithErrors;}","map":{"version":3,"mappings":"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","names":["equal","DeepMerger","reobserveCacheFirst","isNonEmptyArray","graphQLResultHasError","canUseWeakMap","NetworkStatus","isNetworkRequestInFlight","destructiveMethodCounts","WeakMap","Map","wrapDestructiveCacheMethod","cache","methodName","original","set","get","apply","arguments","cancelNotifyTimeout","info","clearTimeout","queryManager","queryId","generateQueryId","Set","has","QueryInfo","query","networkStatus","loading","variables","setVariables","lastDiff","Object","assign","document","networkError","graphQLErrors","observableQuery","setObservableQuery","lastRequestId","dirty","options","getDiffOptions","diff","updateWatch","oq","fetchPolicy","complete","updateLastDiff","returnPartialData","optimistic","canonizeResults","_a","oldDiff","result","notifyTimeout","setTimeout","notify","oqListener","listeners","delete","add","_this","getDiff","fromOptimisticTransaction","shouldNotify","forEach","size","stopped","reset","cancel","prototype","subscriptions","unsubscribe","stopPolling","watchOptions","watcher","callback","setDiff","lastWatch","watch","lastWrite","dmCount","data","cacheWriteBehavior","errors","slice","incremental","mergedData_1","merger_1","path","i","length","key","isNumericKey","isNaN","parent_1","push","merge","shouldWriteResult","errorPolicy","performTransaction","shouldWrite","writeQuery","overwrite","diffOptions","ready","error","ignoreErrors","writeWithErrors"],"sourceRoot":"","sources":["../../src/core/QueryInfo.ts"],"sourcesContent":["import { DocumentNode, GraphQLError } from 'graphql';\nimport { equal } from \"@wry/equality\";\n\nimport { Cache, ApolloCache } from '../cache';\nimport { DeepMerger } from \"../utilities\"\nimport { WatchQueryOptions, ErrorPolicy } from './watchQueryOptions';\nimport { ObservableQuery, reobserveCacheFirst } from './ObservableQuery';\nimport { QueryListener } from './types';\nimport { FetchResult } from '../link/core';\nimport {\n  ObservableSubscription,\n  isNonEmptyArray,\n  graphQLResultHasError,\n  canUseWeakMap,\n} from '../utilities';\nimport {\n  NetworkStatus,\n  isNetworkRequestInFlight,\n} from './networkStatus';\nimport { ApolloError } from '../errors';\nimport { QueryManager } from './QueryManager';\n\nexport type QueryStoreValue = Pick<QueryInfo,\n  | \"variables\"\n  | \"networkStatus\"\n  | \"networkError\"\n  | \"graphQLErrors\"\n  >;\n\nexport const enum CacheWriteBehavior {\n  FORBID,\n  OVERWRITE,\n  MERGE,\n};\n\nconst destructiveMethodCounts = new (\n  canUseWeakMap ? WeakMap : Map\n)<ApolloCache<any>, number>();\n\nfunction wrapDestructiveCacheMethod(\n  cache: ApolloCache<any>,\n  methodName: keyof ApolloCache<any>,\n) {\n  const original = cache[methodName];\n  if (typeof original === \"function\") {\n    cache[methodName] = function () {\n      destructiveMethodCounts.set(\n        cache,\n        // The %1e15 allows the count to wrap around to 0 safely every\n        // quadrillion evictions, so there's no risk of overflow. To be\n        // clear, this is more of a pedantic principle than something\n        // that matters in any conceivable practical scenario.\n        (destructiveMethodCounts.get(cache)! + 1) % 1e15,\n      );\n      return original.apply(this, arguments);\n    };\n  }\n}\n\nfunction cancelNotifyTimeout(info: QueryInfo) {\n  if (info[\"notifyTimeout\"]) {\n    clearTimeout(info[\"notifyTimeout\"]);\n    info[\"notifyTimeout\"] = void 0;\n  }\n}\n\n// A QueryInfo object represents a single query managed by the\n// QueryManager, which tracks all QueryInfo objects by queryId in its\n// this.queries Map. QueryInfo objects store the latest results and errors\n// for the given query, and are responsible for reporting those results to\n// the corresponding ObservableQuery, via the QueryInfo.notify method.\n// Results are reported asynchronously whenever setDiff marks the\n// QueryInfo object as dirty, though a call to the QueryManager's\n// broadcastQueries method may trigger the notification before it happens\n// automatically. This class used to be a simple interface type without\n// any field privacy or meaningful methods, which is why it still has so\n// many public fields. The effort to lock down and simplify the QueryInfo\n// interface is ongoing, and further improvements are welcome.\nexport class QueryInfo {\n  listeners = new Set<QueryListener>();\n  document: DocumentNode | null = null;\n  lastRequestId = 1;\n  subscriptions = new Set<ObservableSubscription>();\n  variables?: Record<string, any>;\n  networkStatus?: NetworkStatus;\n  networkError?: Error | null;\n  graphQLErrors?: ReadonlyArray<GraphQLError>;\n  stopped = false;\n\n  private cache: ApolloCache<any>;\n\n  constructor(\n    queryManager: QueryManager<any>,\n    public readonly queryId = queryManager.generateQueryId(),\n  ) {\n    const cache = this.cache = queryManager.cache;\n\n    // Track how often cache.evict is called, since we want eviction to\n    // override the feud-stopping logic in the markResult method, by\n    // causing shouldWrite to return true. Wrapping the cache.evict method\n    // is a bit of a hack, but it saves us from having to make eviction\n    // counting an official part of the ApolloCache API.\n    if (!destructiveMethodCounts.has(cache)) {\n      destructiveMethodCounts.set(cache, 0);\n      wrapDestructiveCacheMethod(cache, \"evict\");\n      wrapDestructiveCacheMethod(cache, \"modify\");\n      wrapDestructiveCacheMethod(cache, \"reset\");\n    }\n  }\n\n  public init(query: {\n    document: DocumentNode;\n    variables: Record<string, any> | undefined,\n    // The initial networkStatus for this fetch, most often\n    // NetworkStatus.loading, but also possibly fetchMore, poll, refetch,\n    // or setVariables.\n    networkStatus?: NetworkStatus,\n    observableQuery?: ObservableQuery<any>;\n    lastRequestId?: number;\n  }): this {\n    let networkStatus = query.networkStatus || NetworkStatus.loading;\n    if (this.variables &&\n        this.networkStatus !== NetworkStatus.loading &&\n        !equal(this.variables, query.variables)) {\n      networkStatus = NetworkStatus.setVariables;\n    }\n\n    if (!equal(query.variables, this.variables)) {\n      this.lastDiff = void 0;\n    }\n\n    Object.assign(this, {\n      document: query.document,\n      variables: query.variables,\n      networkError: null,\n      graphQLErrors: this.graphQLErrors || [],\n      networkStatus,\n    });\n\n    if (query.observableQuery) {\n      this.setObservableQuery(query.observableQuery);\n    }\n\n    if (query.lastRequestId) {\n      this.lastRequestId = query.lastRequestId;\n    }\n\n    return this;\n  }\n\n  private dirty: boolean = false;\n\n  private notifyTimeout?: ReturnType<typeof setTimeout>;\n\n  reset() {\n    cancelNotifyTimeout(this);\n    this.dirty = false;\n  }\n\n  getDiff(variables = this.variables): Cache.DiffResult<any> {\n    const options = this.getDiffOptions(variables);\n\n    if (this.lastDiff && equal(options, this.lastDiff.options)) {\n      return this.lastDiff.diff;\n    }\n\n    this.updateWatch(this.variables = variables);\n\n    const oq = this.observableQuery;\n    if (oq && oq.options.fetchPolicy === \"no-cache\") {\n      return { complete: false };\n    }\n\n    const diff = this.cache.diff(options);\n    this.updateLastDiff(diff, options);\n    return diff;\n  }\n\n  private lastDiff?: {\n    diff: Cache.DiffResult<any>,\n    options: Cache.DiffOptions,\n  };\n\n  private updateLastDiff(\n    diff: Cache.DiffResult<any> | null,\n    options?: Cache.DiffOptions,\n  ) {\n    this.lastDiff = diff ? {\n      diff,\n      options: options || this.getDiffOptions(),\n    } : void 0;\n  }\n\n  private getDiffOptions(variables = this.variables): Cache.DiffOptions {\n    return {\n      query: this.document!,\n      variables,\n      returnPartialData: true,\n      optimistic: true,\n      canonizeResults: this.observableQuery?.options.canonizeResults,\n    };\n  }\n\n  setDiff(diff: Cache.DiffResult<any> | null) {\n    const oldDiff = this.lastDiff && this.lastDiff.diff;\n    this.updateLastDiff(diff);\n    if (!this.dirty &&\n        !equal(oldDiff && oldDiff.result,\n               diff && diff.result)) {\n      this.dirty = true;\n      if (!this.notifyTimeout) {\n        this.notifyTimeout = setTimeout(() => this.notify(), 0);\n      }\n    }\n  }\n\n  public readonly observableQuery: ObservableQuery<any> | null = null;\n  private oqListener?: QueryListener;\n\n  setObservableQuery(oq: ObservableQuery<any> | null) {\n    if (oq === this.observableQuery) return;\n\n    if (this.oqListener) {\n      this.listeners.delete(this.oqListener);\n    }\n\n    (this as any).observableQuery = oq;\n\n    if (oq) {\n      oq[\"queryInfo\"] = this;\n      this.listeners.add(this.oqListener = () => {\n        const diff = this.getDiff();\n        if (diff.fromOptimisticTransaction) {\n          // If this diff came from an optimistic transaction, deliver the\n          // current cache data to the ObservableQuery, but don't perform a\n          // reobservation, since oq.reobserveCacheFirst might make a network\n          // request, and we never want to trigger network requests in the\n          // middle of optimistic updates.\n          oq[\"observe\"]();\n        } else {\n          // Otherwise, make the ObservableQuery \"reobserve\" the latest data\n          // using a temporary fetch policy of \"cache-first\", so complete cache\n          // results have a chance to be delivered without triggering additional\n          // network requests, even when options.fetchPolicy is \"network-only\"\n          // or \"cache-and-network\". All other fetch policies are preserved by\n          // this method, and are handled by calling oq.reobserve(). If this\n          // reobservation is spurious, isDifferentFromLastResult still has a\n          // chance to catch it before delivery to ObservableQuery subscribers.\n          reobserveCacheFirst(oq);\n        }\n      });\n    } else {\n      delete this.oqListener;\n    }\n  }\n\n  notify() {\n    cancelNotifyTimeout(this);\n\n    if (this.shouldNotify()) {\n      this.listeners.forEach(listener => listener(this));\n    }\n\n    this.dirty = false;\n  }\n\n  private shouldNotify() {\n    if (!this.dirty || !this.listeners.size) {\n      return false;\n    }\n\n    if (isNetworkRequestInFlight(this.networkStatus) &&\n        this.observableQuery) {\n      const { fetchPolicy } = this.observableQuery.options;\n      if (fetchPolicy !== \"cache-only\" &&\n          fetchPolicy !== \"cache-and-network\") {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  public stop() {\n    if (!this.stopped) {\n      this.stopped = true;\n\n      // Cancel the pending notify timeout\n      this.reset();\n\n      this.cancel();\n      // Revert back to the no-op version of cancel inherited from\n      // QueryInfo.prototype.\n      this.cancel = QueryInfo.prototype.cancel;\n\n      this.subscriptions.forEach(sub => sub.unsubscribe());\n\n      const oq = this.observableQuery;\n      if (oq) oq.stopPolling();\n    }\n  }\n\n  // This method is a no-op by default, until/unless overridden by the\n  // updateWatch method.\n  private cancel() {}\n\n  private lastWatch?: Cache.WatchOptions;\n\n  private updateWatch(variables = this.variables) {\n    const oq = this.observableQuery;\n    if (oq && oq.options.fetchPolicy === \"no-cache\") {\n      return;\n    }\n\n    const watchOptions: Cache.WatchOptions = {\n      // Although this.getDiffOptions returns Cache.DiffOptions instead of\n      // Cache.WatchOptions, all the overlapping options should be the same, so\n      // we can reuse getDiffOptions here, for consistency.\n      ...this.getDiffOptions(variables),\n      watcher: this,\n      callback: diff => this.setDiff(diff),\n    };\n\n    if (!this.lastWatch ||\n        !equal(watchOptions, this.lastWatch)) {\n      this.cancel();\n      this.cancel = this.cache.watch(this.lastWatch = watchOptions);\n    }\n  }\n\n  private lastWrite?: {\n    result: FetchResult<any>;\n    variables: WatchQueryOptions[\"variables\"];\n    dmCount: number | undefined;\n  };\n\n  public resetLastWrite() {\n    this.lastWrite = void 0;\n  }\n\n  private shouldWrite(\n    result: FetchResult<any>,\n    variables: WatchQueryOptions[\"variables\"],\n  ) {\n    const { lastWrite } = this;\n    return !(\n      lastWrite &&\n      // If cache.evict has been called since the last time we wrote this\n      // data into the cache, there's a chance writing this result into\n      // the cache will repair what was evicted.\n      lastWrite.dmCount === destructiveMethodCounts.get(this.cache) &&\n      equal(variables, lastWrite.variables) &&\n      equal(result.data, lastWrite.result.data)\n    );\n  }\n\n  public markResult<T>(\n    result: FetchResult<T>,\n    document: DocumentNode,\n    options: Pick<WatchQueryOptions,\n      | \"variables\"\n      | \"fetchPolicy\"\n      | \"errorPolicy\">,\n    cacheWriteBehavior: CacheWriteBehavior,\n  ) {\n    const graphQLErrors = isNonEmptyArray(result.errors)\n      ? result.errors.slice(0)\n      : [];\n\n    // Cancel the pending notify timeout (if it exists) to prevent extraneous network\n    // requests. To allow future notify timeouts, diff and dirty are reset as well.\n    this.reset();\n\n    if ('incremental' in result && isNonEmptyArray(result.incremental)) {\n      let mergedData = this.getDiff().result;\n      const merger = new DeepMerger();\n      result.incremental.forEach(({ data, path, errors }) => {\n        for (let i = path.length - 1; i >= 0; --i) {\n          const key = path[i];\n          const isNumericKey = !isNaN(+key);\n          const parent: Record<string | number, any> = isNumericKey ? [] : {};\n          parent[key] = data;\n          data = parent as typeof data;\n        }\n        if (errors) {\n          graphQLErrors.push(...errors);\n        }\n        mergedData = merger.merge(mergedData, data);\n      });\n      result.data = mergedData;\n    }\n\n    this.graphQLErrors = graphQLErrors;\n\n    if (options.fetchPolicy === 'no-cache') {\n      this.updateLastDiff(\n        { result: result.data, complete: true },\n        this.getDiffOptions(options.variables),\n      );\n\n    } else if (cacheWriteBehavior !== CacheWriteBehavior.FORBID) {\n      if (shouldWriteResult(result, options.errorPolicy)) {\n        // Using a transaction here so we have a chance to read the result\n        // back from the cache before the watch callback fires as a result\n        // of writeQuery, so we can store the new diff quietly and ignore\n        // it when we receive it redundantly from the watch callback.\n        this.cache.performTransaction(cache => {\n          if (this.shouldWrite(result, options.variables)) {\n            cache.writeQuery({\n              query: document,\n              data: result.data as T,\n              variables: options.variables,\n              overwrite: cacheWriteBehavior === CacheWriteBehavior.OVERWRITE,\n            });\n\n            this.lastWrite = {\n              result,\n              variables: options.variables,\n              dmCount: destructiveMethodCounts.get(this.cache),\n            };\n          } else {\n            // If result is the same as the last result we received from\n            // the network (and the variables match too), avoid writing\n            // result into the cache again. The wisdom of skipping this\n            // cache write is far from obvious, since any cache write\n            // could be the one that puts the cache back into a desired\n            // state, fixing corruption or missing data. However, if we\n            // always write every network result into the cache, we enable\n            // feuds between queries competing to update the same data in\n            // incompatible ways, which can lead to an endless cycle of\n            // cache broadcasts and useless network requests. As with any\n            // feud, eventually one side must step back from the brink,\n            // letting the other side(s) have the last word(s). There may\n            // be other points where we could break this cycle, such as\n            // silencing the broadcast for cache.writeQuery (not a good\n            // idea, since it just delays the feud a bit) or somehow\n            // avoiding the network request that just happened (also bad,\n            // because the server could return useful new data). All\n            // options considered, skipping this cache write seems to be\n            // the least damaging place to break the cycle, because it\n            // reflects the intuition that we recently wrote this exact\n            // result into the cache, so the cache *should* already/still\n            // contain this data. If some other query has clobbered that\n            // data in the meantime, that's too bad, but there will be no\n            // winners if every query blindly reverts to its own version\n            // of the data. This approach also gives the network a chance\n            // to return new data, which will be written into the cache as\n            // usual, notifying only those queries that are directly\n            // affected by the cache updates, as usual. In the future, an\n            // even more sophisticated cache could perhaps prevent or\n            // mitigate the clobbering somehow, but that would make this\n            // particular cache write even less important, and thus\n            // skipping it would be even safer than it is today.\n            if (this.lastDiff &&\n                this.lastDiff.diff.complete) {\n              // Reuse data from the last good (complete) diff that we\n              // received, when possible.\n              result.data = this.lastDiff.diff.result;\n              return;\n            }\n            // If the previous this.diff was incomplete, fall through to\n            // re-reading the latest data with cache.diff, below.\n          }\n\n          const diffOptions = this.getDiffOptions(options.variables);\n          const diff = cache.diff<T>(diffOptions);\n\n          // In case the QueryManager stops this QueryInfo before its\n          // results are delivered, it's important to avoid restarting the\n          // cache watch when markResult is called.\n          if (!this.stopped) {\n            // Any time we're about to update this.diff, we need to make\n            // sure we've started watching the cache.\n            this.updateWatch(options.variables);\n          }\n\n          // If we're allowed to write to the cache, and we can read a\n          // complete result from the cache, update result.data to be the\n          // result from the cache, rather than the raw network result.\n          // Set without setDiff to avoid triggering a notify call, since\n          // we have other ways of notifying for this result.\n          this.updateLastDiff(diff, diffOptions);\n          if (diff.complete) {\n            result.data = diff.result;\n          }\n        });\n      } else {\n        this.lastWrite = void 0;\n      }\n    }\n  }\n\n  public markReady() {\n    this.networkError = null;\n    return this.networkStatus = NetworkStatus.ready;\n  }\n\n  public markError(error: ApolloError) {\n    this.networkStatus = NetworkStatus.error;\n    this.lastWrite = void 0;\n\n    this.reset();\n\n    if (error.graphQLErrors) {\n      this.graphQLErrors = error.graphQLErrors;\n    }\n\n    if (error.networkError) {\n      this.networkError = error.networkError;\n    }\n\n    return error;\n  }\n}\n\nexport function shouldWriteResult<T>(\n  result: FetchResult<T>,\n  errorPolicy: ErrorPolicy = \"none\",\n) {\n  const ignoreErrors =\n    errorPolicy === \"ignore\" ||\n    errorPolicy === \"all\";\n  let writeWithErrors = !graphQLResultHasError(result);\n  if (!writeWithErrors && ignoreErrors && result.data) {\n    writeWithErrors = true;\n  }\n  return writeWithErrors;\n}\n"]},"metadata":{},"sourceType":"module"}