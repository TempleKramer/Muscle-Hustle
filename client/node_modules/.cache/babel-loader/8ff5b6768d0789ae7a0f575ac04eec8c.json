{"ast":null,"code":"import{__assign,__awaiter,__generator}from\"tslib\";import{invariant,InvariantError}from\"../utilities/globals/index.js\";import{equal}from'@wry/equality';import{execute}from\"../link/core/index.js\";import{isExecutionPatchIncrementalResult}from\"../utilities/common/incrementalResult.js\";import{canonicalStringify}from\"../cache/index.js\";import{getDefaultValues,getOperationDefinition,getOperationName,hasClientExports,graphQLResultHasError,removeConnectionDirectiveFromDocument,canUseWeakMap,Observable,asyncMap,isNonEmptyArray,Concast,makeUniqueId,isDocumentNode,isNonNullObject,cloneDeep}from\"../utilities/index.js\";import{ApolloError,isApolloError}from\"../errors/index.js\";import{ObservableQuery,logMissingFieldErrors}from\"./ObservableQuery.js\";import{NetworkStatus,isNetworkRequestInFlight}from\"./networkStatus.js\";import{LocalState}from\"./LocalState.js\";import{QueryInfo,shouldWriteResult}from\"./QueryInfo.js\";var hasOwnProperty=Object.prototype.hasOwnProperty;var QueryManager=function(){function QueryManager(_a){var cache=_a.cache,link=_a.link,defaultOptions=_a.defaultOptions,_b=_a.queryDeduplication,queryDeduplication=_b===void 0?false:_b,onBroadcast=_a.onBroadcast,_c=_a.ssrMode,ssrMode=_c===void 0?false:_c,_d=_a.clientAwareness,clientAwareness=_d===void 0?{}:_d,localState=_a.localState,assumeImmutableResults=_a.assumeImmutableResults;this.clientAwareness={};this.queries=new Map();this.fetchCancelFns=new Map();this.transformCache=new(canUseWeakMap?WeakMap:Map)();this.queryIdCounter=1;this.requestIdCounter=1;this.mutationIdCounter=1;this.inFlightLinkObservables=new Map();this.cache=cache;this.link=link;this.defaultOptions=defaultOptions||Object.create(null);this.queryDeduplication=queryDeduplication;this.clientAwareness=clientAwareness;this.localState=localState||new LocalState({cache:cache});this.ssrMode=ssrMode;this.assumeImmutableResults=!!assumeImmutableResults;if(this.onBroadcast=onBroadcast){this.mutationStore=Object.create(null);}}QueryManager.prototype.stop=function(){var _this=this;this.queries.forEach(function(_info,queryId){_this.stopQueryNoBroadcast(queryId);});this.cancelPendingFetches(__DEV__?new InvariantError('QueryManager stopped while query was in flight'):new InvariantError(13));};QueryManager.prototype.cancelPendingFetches=function(error){this.fetchCancelFns.forEach(function(cancel){return cancel(error);});this.fetchCancelFns.clear();};QueryManager.prototype.mutate=function(_a){var _b,_c;var mutation=_a.mutation,variables=_a.variables,optimisticResponse=_a.optimisticResponse,updateQueries=_a.updateQueries,_d=_a.refetchQueries,refetchQueries=_d===void 0?[]:_d,_e=_a.awaitRefetchQueries,awaitRefetchQueries=_e===void 0?false:_e,updateWithProxyFn=_a.update,onQueryUpdated=_a.onQueryUpdated,_f=_a.fetchPolicy,fetchPolicy=_f===void 0?((_b=this.defaultOptions.mutate)===null||_b===void 0?void 0:_b.fetchPolicy)||\"network-only\":_f,_g=_a.errorPolicy,errorPolicy=_g===void 0?((_c=this.defaultOptions.mutate)===null||_c===void 0?void 0:_c.errorPolicy)||\"none\":_g,keepRootFields=_a.keepRootFields,context=_a.context;return __awaiter(this,void 0,void 0,function(){var mutationId,_h,document,hasClientExports,mutationStoreValue,self;return __generator(this,function(_j){switch(_j.label){case 0:__DEV__?invariant(mutation,'mutation option is required. You must specify your GraphQL document in the mutation option.'):invariant(mutation,14);__DEV__?invariant(fetchPolicy==='network-only'||fetchPolicy==='no-cache',\"Mutations support only 'network-only' or 'no-cache' fetchPolicy strings. The default `network-only` behavior automatically writes mutation results to the cache. Passing `no-cache` skips the cache write.\"):invariant(fetchPolicy==='network-only'||fetchPolicy==='no-cache',15);mutationId=this.generateMutationId();_h=this.transform(mutation),document=_h.document,hasClientExports=_h.hasClientExports;mutation=this.cache.transformForLink(document);variables=this.getVariables(mutation,variables);if(!hasClientExports)return[3,2];return[4,this.localState.addExportedVariables(mutation,variables,context)];case 1:variables=_j.sent();_j.label=2;case 2:mutationStoreValue=this.mutationStore&&(this.mutationStore[mutationId]={mutation:mutation,variables:variables,loading:true,error:null});if(optimisticResponse){this.markMutationOptimistic(optimisticResponse,{mutationId:mutationId,document:mutation,variables:variables,fetchPolicy:fetchPolicy,errorPolicy:errorPolicy,context:context,updateQueries:updateQueries,update:updateWithProxyFn,keepRootFields:keepRootFields});}this.broadcastQueries();self=this;return[2,new Promise(function(resolve,reject){return asyncMap(self.getObservableFromLink(mutation,__assign(__assign({},context),{optimisticResponse:optimisticResponse}),variables,false),function(result){if(graphQLResultHasError(result)&&errorPolicy==='none'){throw new ApolloError({graphQLErrors:result.errors});}if(mutationStoreValue){mutationStoreValue.loading=false;mutationStoreValue.error=null;}var storeResult=__assign({},result);if(typeof refetchQueries===\"function\"){refetchQueries=refetchQueries(storeResult);}if(errorPolicy==='ignore'&&graphQLResultHasError(storeResult)){delete storeResult.errors;}return self.markMutationResult({mutationId:mutationId,result:storeResult,document:mutation,variables:variables,fetchPolicy:fetchPolicy,errorPolicy:errorPolicy,context:context,update:updateWithProxyFn,updateQueries:updateQueries,awaitRefetchQueries:awaitRefetchQueries,refetchQueries:refetchQueries,removeOptimistic:optimisticResponse?mutationId:void 0,onQueryUpdated:onQueryUpdated,keepRootFields:keepRootFields});}).subscribe({next:function next(storeResult){self.broadcastQueries();resolve(storeResult);},error:function error(err){if(mutationStoreValue){mutationStoreValue.loading=false;mutationStoreValue.error=err;}if(optimisticResponse){self.cache.removeOptimistic(mutationId);}self.broadcastQueries();reject(err instanceof ApolloError?err:new ApolloError({networkError:err}));}});})];}});});};QueryManager.prototype.markMutationResult=function(mutation,cache){var _this=this;if(cache===void 0){cache=this.cache;}var result=mutation.result;var cacheWrites=[];var skipCache=mutation.fetchPolicy===\"no-cache\";if(!skipCache&&shouldWriteResult(result,mutation.errorPolicy)){cacheWrites.push({result:result.data,dataId:'ROOT_MUTATION',query:mutation.document,variables:mutation.variables});var updateQueries_1=mutation.updateQueries;if(updateQueries_1){this.queries.forEach(function(_a,queryId){var observableQuery=_a.observableQuery;var queryName=observableQuery&&observableQuery.queryName;if(!queryName||!hasOwnProperty.call(updateQueries_1,queryName)){return;}var updater=updateQueries_1[queryName];var _b=_this.queries.get(queryId),document=_b.document,variables=_b.variables;var _c=cache.diff({query:document,variables:variables,returnPartialData:true,optimistic:false}),currentQueryResult=_c.result,complete=_c.complete;if(complete&&currentQueryResult){var nextQueryResult=updater(currentQueryResult,{mutationResult:result,queryName:document&&getOperationName(document)||void 0,queryVariables:variables});if(nextQueryResult){cacheWrites.push({result:nextQueryResult,dataId:'ROOT_QUERY',query:document,variables:variables});}}});}}if(cacheWrites.length>0||mutation.refetchQueries||mutation.update||mutation.onQueryUpdated||mutation.removeOptimistic){var results_1=[];this.refetchQueries({updateCache:function updateCache(cache){if(!skipCache){cacheWrites.forEach(function(write){return cache.write(write);});}var update=mutation.update;if(update){if(!skipCache){var diff=cache.diff({id:\"ROOT_MUTATION\",query:_this.transform(mutation.document).asQuery,variables:mutation.variables,optimistic:false,returnPartialData:true});if(diff.complete&&!isExecutionPatchIncrementalResult(result)){result=__assign(__assign({},result),{data:diff.result});}}update(cache,result,{context:mutation.context,variables:mutation.variables});}if(!skipCache&&!mutation.keepRootFields){cache.modify({id:'ROOT_MUTATION',fields:function fields(value,_a){var fieldName=_a.fieldName,DELETE=_a.DELETE;return fieldName===\"__typename\"?value:DELETE;}});}},include:mutation.refetchQueries,optimistic:false,removeOptimistic:mutation.removeOptimistic,onQueryUpdated:mutation.onQueryUpdated||null}).forEach(function(result){return results_1.push(result);});if(mutation.awaitRefetchQueries||mutation.onQueryUpdated){return Promise.all(results_1).then(function(){return result;});}}return Promise.resolve(result);};QueryManager.prototype.markMutationOptimistic=function(optimisticResponse,mutation){var _this=this;var data=typeof optimisticResponse===\"function\"?optimisticResponse(mutation.variables):optimisticResponse;return this.cache.recordOptimisticTransaction(function(cache){try{_this.markMutationResult(__assign(__assign({},mutation),{result:{data:data}}),cache);}catch(error){__DEV__&&invariant.error(error);}},mutation.mutationId);};QueryManager.prototype.fetchQuery=function(queryId,options,networkStatus){return this.fetchQueryObservable(queryId,options,networkStatus).promise;};QueryManager.prototype.getQueryStore=function(){var store=Object.create(null);this.queries.forEach(function(info,queryId){store[queryId]={variables:info.variables,networkStatus:info.networkStatus,networkError:info.networkError,graphQLErrors:info.graphQLErrors};});return store;};QueryManager.prototype.resetErrors=function(queryId){var queryInfo=this.queries.get(queryId);if(queryInfo){queryInfo.networkError=undefined;queryInfo.graphQLErrors=[];}};QueryManager.prototype.transform=function(document){var transformCache=this.transformCache;if(!transformCache.has(document)){var transformed=this.cache.transformDocument(document);var noConnection=removeConnectionDirectiveFromDocument(transformed);var clientQuery=this.localState.clientQuery(transformed);var serverQuery=noConnection&&this.localState.serverQuery(noConnection);var cacheEntry_1={document:transformed,hasClientExports:hasClientExports(transformed),hasForcedResolvers:this.localState.shouldForceResolvers(transformed),clientQuery:clientQuery,serverQuery:serverQuery,defaultVars:getDefaultValues(getOperationDefinition(transformed)),asQuery:__assign(__assign({},transformed),{definitions:transformed.definitions.map(function(def){if(def.kind===\"OperationDefinition\"&&def.operation!==\"query\"){return __assign(__assign({},def),{operation:\"query\"});}return def;})})};var add=function add(doc){if(doc&&!transformCache.has(doc)){transformCache.set(doc,cacheEntry_1);}};add(document);add(transformed);add(clientQuery);add(serverQuery);}return transformCache.get(document);};QueryManager.prototype.getVariables=function(document,variables){return __assign(__assign({},this.transform(document).defaultVars),variables);};QueryManager.prototype.watchQuery=function(options){options=__assign(__assign({},options),{variables:this.getVariables(options.query,options.variables)});if(typeof options.notifyOnNetworkStatusChange==='undefined'){options.notifyOnNetworkStatusChange=false;}var queryInfo=new QueryInfo(this);var observable=new ObservableQuery({queryManager:this,queryInfo:queryInfo,options:options});this.queries.set(observable.queryId,queryInfo);queryInfo.init({document:observable.query,observableQuery:observable,variables:observable.variables});return observable;};QueryManager.prototype.query=function(options,queryId){var _this=this;if(queryId===void 0){queryId=this.generateQueryId();}__DEV__?invariant(options.query,'query option is required. You must specify your GraphQL document '+'in the query option.'):invariant(options.query,16);__DEV__?invariant(options.query.kind==='Document','You must wrap the query string in a \"gql\" tag.'):invariant(options.query.kind==='Document',17);__DEV__?invariant(!options.returnPartialData,'returnPartialData option only supported on watchQuery.'):invariant(!options.returnPartialData,18);__DEV__?invariant(!options.pollInterval,'pollInterval option only supported on watchQuery.'):invariant(!options.pollInterval,19);return this.fetchQuery(queryId,options).finally(function(){return _this.stopQuery(queryId);});};QueryManager.prototype.generateQueryId=function(){return String(this.queryIdCounter++);};QueryManager.prototype.generateRequestId=function(){return this.requestIdCounter++;};QueryManager.prototype.generateMutationId=function(){return String(this.mutationIdCounter++);};QueryManager.prototype.stopQueryInStore=function(queryId){this.stopQueryInStoreNoBroadcast(queryId);this.broadcastQueries();};QueryManager.prototype.stopQueryInStoreNoBroadcast=function(queryId){var queryInfo=this.queries.get(queryId);if(queryInfo)queryInfo.stop();};QueryManager.prototype.clearStore=function(options){if(options===void 0){options={discardWatches:true};}this.cancelPendingFetches(__DEV__?new InvariantError('Store reset while query was in flight (not completed in link chain)'):new InvariantError(20));this.queries.forEach(function(queryInfo){if(queryInfo.observableQuery){queryInfo.networkStatus=NetworkStatus.loading;}else{queryInfo.stop();}});if(this.mutationStore){this.mutationStore=Object.create(null);}return this.cache.reset(options);};QueryManager.prototype.getObservableQueries=function(include){var _this=this;if(include===void 0){include=\"active\";}var queries=new Map();var queryNamesAndDocs=new Map();var legacyQueryOptions=new Set();if(Array.isArray(include)){include.forEach(function(desc){if(typeof desc===\"string\"){queryNamesAndDocs.set(desc,false);}else if(isDocumentNode(desc)){queryNamesAndDocs.set(_this.transform(desc).document,false);}else if(isNonNullObject(desc)&&desc.query){legacyQueryOptions.add(desc);}});}this.queries.forEach(function(_a,queryId){var oq=_a.observableQuery,document=_a.document;if(oq){if(include===\"all\"){queries.set(queryId,oq);return;}var queryName=oq.queryName,fetchPolicy=oq.options.fetchPolicy;if(fetchPolicy===\"standby\"||include===\"active\"&&!oq.hasObservers()){return;}if(include===\"active\"||queryName&&queryNamesAndDocs.has(queryName)||document&&queryNamesAndDocs.has(document)){queries.set(queryId,oq);if(queryName)queryNamesAndDocs.set(queryName,true);if(document)queryNamesAndDocs.set(document,true);}}});if(legacyQueryOptions.size){legacyQueryOptions.forEach(function(options){var queryId=makeUniqueId(\"legacyOneTimeQuery\");var queryInfo=_this.getQuery(queryId).init({document:options.query,variables:options.variables});var oq=new ObservableQuery({queryManager:_this,queryInfo:queryInfo,options:__assign(__assign({},options),{fetchPolicy:\"network-only\"})});invariant(oq.queryId===queryId);queryInfo.setObservableQuery(oq);queries.set(queryId,oq);});}if(__DEV__&&queryNamesAndDocs.size){queryNamesAndDocs.forEach(function(included,nameOrDoc){if(!included){__DEV__&&invariant.warn(\"Unknown query \".concat(typeof nameOrDoc===\"string\"?\"named \":\"\").concat(JSON.stringify(nameOrDoc,null,2),\" requested in refetchQueries options.include array\"));}});}return queries;};QueryManager.prototype.reFetchObservableQueries=function(includeStandby){var _this=this;if(includeStandby===void 0){includeStandby=false;}var observableQueryPromises=[];this.getObservableQueries(includeStandby?\"all\":\"active\").forEach(function(observableQuery,queryId){var fetchPolicy=observableQuery.options.fetchPolicy;observableQuery.resetLastResults();if(includeStandby||fetchPolicy!==\"standby\"&&fetchPolicy!==\"cache-only\"){observableQueryPromises.push(observableQuery.refetch());}_this.getQuery(queryId).setDiff(null);});this.broadcastQueries();return Promise.all(observableQueryPromises);};QueryManager.prototype.setObservableQuery=function(observableQuery){this.getQuery(observableQuery.queryId).setObservableQuery(observableQuery);};QueryManager.prototype.startGraphQLSubscription=function(_a){var _this=this;var query=_a.query,fetchPolicy=_a.fetchPolicy,errorPolicy=_a.errorPolicy,variables=_a.variables,_b=_a.context,context=_b===void 0?{}:_b;query=this.transform(query).document;variables=this.getVariables(query,variables);var makeObservable=function makeObservable(variables){return _this.getObservableFromLink(query,context,variables).map(function(result){if(fetchPolicy!=='no-cache'){if(shouldWriteResult(result,errorPolicy)){_this.cache.write({query:query,result:result.data,dataId:'ROOT_SUBSCRIPTION',variables:variables});}_this.broadcastQueries();}if(graphQLResultHasError(result)){throw new ApolloError({graphQLErrors:result.errors});}return result;});};if(this.transform(query).hasClientExports){var observablePromise_1=this.localState.addExportedVariables(query,variables,context).then(makeObservable);return new Observable(function(observer){var sub=null;observablePromise_1.then(function(observable){return sub=observable.subscribe(observer);},observer.error);return function(){return sub&&sub.unsubscribe();};});}return makeObservable(variables);};QueryManager.prototype.stopQuery=function(queryId){this.stopQueryNoBroadcast(queryId);this.broadcastQueries();};QueryManager.prototype.stopQueryNoBroadcast=function(queryId){this.stopQueryInStoreNoBroadcast(queryId);this.removeQuery(queryId);};QueryManager.prototype.removeQuery=function(queryId){this.fetchCancelFns.delete(queryId);if(this.queries.has(queryId)){this.getQuery(queryId).stop();this.queries.delete(queryId);}};QueryManager.prototype.broadcastQueries=function(){if(this.onBroadcast)this.onBroadcast();this.queries.forEach(function(info){return info.notify();});};QueryManager.prototype.getLocalState=function(){return this.localState;};QueryManager.prototype.getObservableFromLink=function(query,context,variables,deduplication){var _this=this;var _a;if(deduplication===void 0){deduplication=(_a=context===null||context===void 0?void 0:context.queryDeduplication)!==null&&_a!==void 0?_a:this.queryDeduplication;}var observable;var serverQuery=this.transform(query).serverQuery;if(serverQuery){var _b=this,inFlightLinkObservables_1=_b.inFlightLinkObservables,link=_b.link;var operation={query:serverQuery,variables:variables,operationName:getOperationName(serverQuery)||void 0,context:this.prepareContext(__assign(__assign({},context),{forceFetch:!deduplication}))};context=operation.context;if(deduplication){var byVariables_1=inFlightLinkObservables_1.get(serverQuery)||new Map();inFlightLinkObservables_1.set(serverQuery,byVariables_1);var varJson_1=canonicalStringify(variables);observable=byVariables_1.get(varJson_1);if(!observable){var concast=new Concast([execute(link,operation)]);byVariables_1.set(varJson_1,observable=concast);concast.beforeNext(function(){if(byVariables_1.delete(varJson_1)&&byVariables_1.size<1){inFlightLinkObservables_1.delete(serverQuery);}});}}else{observable=new Concast([execute(link,operation)]);}}else{observable=new Concast([Observable.of({data:{}})]);context=this.prepareContext(context);}var clientQuery=this.transform(query).clientQuery;if(clientQuery){observable=asyncMap(observable,function(result){return _this.localState.runResolvers({document:clientQuery,remoteResult:result,context:context,variables:variables});});}return observable;};QueryManager.prototype.getResultsFromLink=function(queryInfo,cacheWriteBehavior,options){var requestId=queryInfo.lastRequestId=this.generateRequestId();options=cloneDeep(options);var linkDocument=this.cache.transformForLink(this.transform(queryInfo.document).document);return asyncMap(this.getObservableFromLink(linkDocument,options.context,options.variables),function(result){var graphQLErrors=isNonEmptyArray(result.errors)?result.errors.slice(0):[];if('incremental'in result&&isNonEmptyArray(result.incremental)){result.incremental.forEach(function(incrementalResult){if(incrementalResult.errors){graphQLErrors.push.apply(graphQLErrors,incrementalResult.errors);}});}var hasErrors=isNonEmptyArray(graphQLErrors);if(requestId>=queryInfo.lastRequestId){if(hasErrors&&options.errorPolicy===\"none\"){throw queryInfo.markError(new ApolloError({graphQLErrors:graphQLErrors}));}queryInfo.markResult(result,linkDocument,options,cacheWriteBehavior);queryInfo.markReady();}var aqr={data:result.data,loading:false,networkStatus:NetworkStatus.ready};if(hasErrors&&options.errorPolicy!==\"ignore\"){aqr.errors=graphQLErrors;aqr.networkStatus=NetworkStatus.error;}return aqr;},function(networkError){var error=isApolloError(networkError)?networkError:new ApolloError({networkError:networkError});if(requestId>=queryInfo.lastRequestId){queryInfo.markError(error);}throw error;});};QueryManager.prototype.fetchQueryObservable=function(queryId,options,networkStatus){var _this=this;if(networkStatus===void 0){networkStatus=NetworkStatus.loading;}var query=this.transform(options.query).document;var variables=this.getVariables(query,options.variables);var queryInfo=this.getQuery(queryId);var defaults=this.defaultOptions.watchQuery;var _a=options.fetchPolicy,fetchPolicy=_a===void 0?defaults&&defaults.fetchPolicy||\"cache-first\":_a,_b=options.errorPolicy,errorPolicy=_b===void 0?defaults&&defaults.errorPolicy||\"none\":_b,_c=options.returnPartialData,returnPartialData=_c===void 0?false:_c,_d=options.notifyOnNetworkStatusChange,notifyOnNetworkStatusChange=_d===void 0?false:_d,_e=options.context,context=_e===void 0?{}:_e;var normalized=Object.assign({},options,{query:query,variables:variables,fetchPolicy:fetchPolicy,errorPolicy:errorPolicy,returnPartialData:returnPartialData,notifyOnNetworkStatusChange:notifyOnNetworkStatusChange,context:context});var fromVariables=function fromVariables(variables){normalized.variables=variables;var concastSources=_this.fetchQueryByPolicy(queryInfo,normalized,networkStatus);if(normalized.fetchPolicy!==\"standby\"&&concastSources.length>0&&queryInfo.observableQuery){queryInfo.observableQuery[\"applyNextFetchPolicy\"](\"after-fetch\",options);}return concastSources;};var cleanupCancelFn=function cleanupCancelFn(){return _this.fetchCancelFns.delete(queryId);};this.fetchCancelFns.set(queryId,function(reason){cleanupCancelFn();setTimeout(function(){return concast.cancel(reason);});});var concast=new Concast(this.transform(normalized.query).hasClientExports?this.localState.addExportedVariables(normalized.query,normalized.variables,normalized.context).then(fromVariables):fromVariables(normalized.variables));concast.promise.then(cleanupCancelFn,cleanupCancelFn);return concast;};QueryManager.prototype.refetchQueries=function(_a){var _this=this;var updateCache=_a.updateCache,include=_a.include,_b=_a.optimistic,optimistic=_b===void 0?false:_b,_c=_a.removeOptimistic,removeOptimistic=_c===void 0?optimistic?makeUniqueId(\"refetchQueries\"):void 0:_c,onQueryUpdated=_a.onQueryUpdated;var includedQueriesById=new Map();if(include){this.getObservableQueries(include).forEach(function(oq,queryId){includedQueriesById.set(queryId,{oq:oq,lastDiff:_this.getQuery(queryId).getDiff()});});}var results=new Map();if(updateCache){this.cache.batch({update:updateCache,optimistic:optimistic&&removeOptimistic||false,removeOptimistic:removeOptimistic,onWatchUpdated:function onWatchUpdated(watch,diff,lastDiff){var oq=watch.watcher instanceof QueryInfo&&watch.watcher.observableQuery;if(oq){if(onQueryUpdated){includedQueriesById.delete(oq.queryId);var result=onQueryUpdated(oq,diff,lastDiff);if(result===true){result=oq.refetch();}if(result!==false){results.set(oq,result);}return result;}if(onQueryUpdated!==null){includedQueriesById.set(oq.queryId,{oq:oq,lastDiff:lastDiff,diff:diff});}}}});}if(includedQueriesById.size){includedQueriesById.forEach(function(_a,queryId){var oq=_a.oq,lastDiff=_a.lastDiff,diff=_a.diff;var result;if(onQueryUpdated){if(!diff){var info=oq[\"queryInfo\"];info.reset();diff=info.getDiff();}result=onQueryUpdated(oq,diff,lastDiff);}if(!onQueryUpdated||result===true){result=oq.refetch();}if(result!==false){results.set(oq,result);}if(queryId.indexOf(\"legacyOneTimeQuery\")>=0){_this.stopQueryNoBroadcast(queryId);}});}if(removeOptimistic){this.cache.removeOptimistic(removeOptimistic);}return results;};QueryManager.prototype.fetchQueryByPolicy=function(queryInfo,_a,networkStatus){var _this=this;var query=_a.query,variables=_a.variables,fetchPolicy=_a.fetchPolicy,refetchWritePolicy=_a.refetchWritePolicy,errorPolicy=_a.errorPolicy,returnPartialData=_a.returnPartialData,context=_a.context,notifyOnNetworkStatusChange=_a.notifyOnNetworkStatusChange;var oldNetworkStatus=queryInfo.networkStatus;queryInfo.init({document:this.transform(query).document,variables:variables,networkStatus:networkStatus});var readCache=function readCache(){return queryInfo.getDiff(variables);};var resultsFromCache=function resultsFromCache(diff,networkStatus){if(networkStatus===void 0){networkStatus=queryInfo.networkStatus||NetworkStatus.loading;}var data=diff.result;if(__DEV__&&!returnPartialData&&!equal(data,{})){logMissingFieldErrors(diff.missing);}var fromData=function fromData(data){return Observable.of(__assign({data:data,loading:isNetworkRequestInFlight(networkStatus),networkStatus:networkStatus},diff.complete?null:{partial:true}));};if(data&&_this.transform(query).hasForcedResolvers){return _this.localState.runResolvers({document:query,remoteResult:{data:data},context:context,variables:variables,onlyRunForcedResolvers:true}).then(function(resolved){return fromData(resolved.data||void 0);});}return fromData(data);};var cacheWriteBehavior=fetchPolicy===\"no-cache\"?0:networkStatus===NetworkStatus.refetch&&refetchWritePolicy!==\"merge\"?1:2;var resultsFromLink=function resultsFromLink(){return _this.getResultsFromLink(queryInfo,cacheWriteBehavior,{variables:variables,context:context,fetchPolicy:fetchPolicy,errorPolicy:errorPolicy});};var shouldNotify=notifyOnNetworkStatusChange&&typeof oldNetworkStatus===\"number\"&&oldNetworkStatus!==networkStatus&&isNetworkRequestInFlight(networkStatus);switch(fetchPolicy){default:case\"cache-first\":{var diff=readCache();if(diff.complete){return[resultsFromCache(diff,queryInfo.markReady())];}if(returnPartialData||shouldNotify){return[resultsFromCache(diff),resultsFromLink()];}return[resultsFromLink()];}case\"cache-and-network\":{var diff=readCache();if(diff.complete||returnPartialData||shouldNotify){return[resultsFromCache(diff),resultsFromLink()];}return[resultsFromLink()];}case\"cache-only\":return[resultsFromCache(readCache(),queryInfo.markReady())];case\"network-only\":if(shouldNotify){return[resultsFromCache(readCache()),resultsFromLink()];}return[resultsFromLink()];case\"no-cache\":if(shouldNotify){return[resultsFromCache(queryInfo.getDiff()),resultsFromLink()];}return[resultsFromLink()];case\"standby\":return[];}};QueryManager.prototype.getQuery=function(queryId){if(queryId&&!this.queries.has(queryId)){this.queries.set(queryId,new QueryInfo(this,queryId));}return this.queries.get(queryId);};QueryManager.prototype.prepareContext=function(context){if(context===void 0){context={};}var newContext=this.localState.prepareContext(context);return __assign(__assign({},newContext),{clientAwareness:this.clientAwareness});};return QueryManager;}();export{QueryManager};","map":{"version":3,"mappings":"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","names":["invariant","InvariantError","equal","execute","isExecutionPatchIncrementalResult","canonicalStringify","getDefaultValues","getOperationDefinition","getOperationName","hasClientExports","graphQLResultHasError","removeConnectionDirectiveFromDocument","canUseWeakMap","Observable","asyncMap","isNonEmptyArray","Concast","makeUniqueId","isDocumentNode","isNonNullObject","cloneDeep","ApolloError","isApolloError","ObservableQuery","logMissingFieldErrors","NetworkStatus","isNetworkRequestInFlight","LocalState","QueryInfo","shouldWriteResult","Object","prototype","hasOwnProperty","_a","cache","link","defaultOptions","_b","onBroadcast","_c","_d","localState","assumeImmutableResults","Map","WeakMap","create","queryDeduplication","clientAwareness","ssrMode","mutationStore","QueryManager","queries","forEach","_info","queryId","_this","stopQueryNoBroadcast","cancelPendingFetches","__DEV__","error","fetchCancelFns","clear","mutation","variables","optimisticResponse","updateQueries","_e","updateWithProxyFn","onQueryUpdated","_f","mutate","fetchPolicy","_g","errorPolicy","keepRootFields","context","mutationId","_h","transform","document","transformForLink","loading","markMutationOptimistic","update","broadcastQueries","self","Promise","resolve","reject","__assign","result","graphQLErrors","mutationStoreValue","storeResult","refetchQueries","awaitRefetchQueries","removeOptimistic","err","networkError","markMutationResult","cacheWrites","skipCache","push","dataId","query","updateQueries_1","observableQuery","queryName","get","returnPartialData","optimistic","currentQueryResult","complete","nextQueryResult","updater","mutationResult","queryVariables","results_1","diff","id","asQuery","modify","value","DELETE","include","data","recordOptimisticTransaction","fetchQuery","options","networkStatus","getQueryStore","store","info","resetErrors","queryInfo","undefined","transformCache","transformed","transformDocument","noConnection","clientQuery","serverQuery","cacheEntry_1","hasForcedResolvers","defaultVars","definitions","def","kind","add","doc","observable","queryManager","set","generateQueryId","generateRequestId","generateMutationId","stopQueryInStoreNoBroadcast","discardWatches","getObservableQueries","queryNamesAndDocs","legacyQueryOptions","Set","Array","desc","oq","size","getQuery","init","reFetchObservableQueries","includeStandby","observableQueryPromises","setObservableQuery","startGraphQLSubscription","makeObservable","map","write","addExportedVariables","then","observablePromise_1","sub","observer","removeQuery","delete","has","stop","getLocalState","getObservableFromLink","deduplication","inFlightLinkObservables_1","operation","operationName","byVariables_1","varJson_1","concast","beforeNext","runResolvers","remoteResult","getResultsFromLink","cacheWriteBehavior","linkDocument","slice","incrementalResult","errors","hasErrors","requestId","markResult","aqr","fetchQueryObservable","getVariables","watchQuery","notifyOnNetworkStatusChange","normalized","fromVariables","concastSources","cleanupCancelFn","setTimeout","updateCache","includedQueriesById","lastDiff","results","batch","watch","fetchQueryByPolicy","refetchWritePolicy","readCache","resultsFromCache","fromData","onlyRunForcedResolvers","resultsFromLink","shouldNotify","oldNetworkStatus","prepareContext"],"sourceRoot":"","sources":["../../src/core/QueryManager.ts"],"sourcesContent":["import { invariant, InvariantError } from '../utilities/globals';\n\nimport { DocumentNode } from 'graphql';\n// TODO(brian): A hack until this issue is resolved (https://github.com/graphql/graphql-js/issues/3356)\ntype OperationTypeNode = any;\nimport { equal } from '@wry/equality';\n\nimport { ApolloLink, execute, FetchResult } from '../link/core';\nimport { isExecutionPatchIncrementalResult } from '../utilities/common/incrementalResult';\nimport { Cache, ApolloCache, canonicalStringify } from '../cache';\n\nimport {\n  getDefaultValues,\n  getOperationDefinition,\n  getOperationName,\n  hasClientExports,\n  graphQLResultHasError,\n  removeConnectionDirectiveFromDocument,\n  canUseWeakMap,\n  ObservableSubscription,\n  Observable,\n  asyncMap,\n  isNonEmptyArray,\n  Concast,\n  ConcastSourcesArray,\n  makeUniqueId,\n  isDocumentNode,\n  isNonNullObject,\n  cloneDeep,\n} from '../utilities';\nimport { ApolloError, isApolloError } from '../errors';\nimport {\n  QueryOptions,\n  WatchQueryOptions,\n  SubscriptionOptions,\n  MutationOptions,\n  ErrorPolicy,\n  MutationFetchPolicy,\n} from './watchQueryOptions';\nimport { ObservableQuery, logMissingFieldErrors } from './ObservableQuery';\nimport { NetworkStatus, isNetworkRequestInFlight } from './networkStatus';\nimport {\n  ApolloQueryResult,\n  OperationVariables,\n  MutationUpdaterFunction,\n  OnQueryUpdated,\n  InternalRefetchQueriesInclude,\n  InternalRefetchQueriesOptions,\n  InternalRefetchQueriesResult,\n  InternalRefetchQueriesMap,\n} from './types';\nimport { LocalState } from './LocalState';\n\nimport {\n  QueryInfo,\n  QueryStoreValue,\n  shouldWriteResult,\n  CacheWriteBehavior,\n} from './QueryInfo';\n\nconst { hasOwnProperty } = Object.prototype;\n\ninterface MutationStoreValue {\n  mutation: DocumentNode;\n  variables: Record<string, any>;\n  loading: boolean;\n  error: Error | null;\n}\n\ntype UpdateQueries<TData> = MutationOptions<TData, any, any>[\"updateQueries\"];\n\ninterface TransformCacheEntry {\n  document: DocumentNode;\n  hasClientExports: boolean;\n  hasForcedResolvers: boolean;\n  clientQuery: DocumentNode | null;\n  serverQuery: DocumentNode | null;\n  defaultVars: OperationVariables;\n  asQuery: DocumentNode;\n}\n\ntype DefaultOptions = import(\"./ApolloClient\").DefaultOptions;\n\nexport class QueryManager<TStore> {\n  public cache: ApolloCache<TStore>;\n  public link: ApolloLink;\n  public defaultOptions: DefaultOptions;\n\n  public readonly assumeImmutableResults: boolean;\n  public readonly ssrMode: boolean;\n\n  private queryDeduplication: boolean;\n  private clientAwareness: Record<string, string> = {};\n  private localState: LocalState<TStore>;\n\n  private onBroadcast?: () => void;\n  public mutationStore?: {\n    [mutationId: string]: MutationStoreValue;\n  };\n\n  // All the queries that the QueryManager is currently managing (not\n  // including mutations and subscriptions).\n  private queries = new Map<string, QueryInfo>();\n\n  // Maps from queryId strings to Promise rejection functions for\n  // currently active queries and fetches.\n  private fetchCancelFns = new Map<string, (error: any) => any>();\n\n  constructor({\n    cache,\n    link,\n    defaultOptions,\n    queryDeduplication = false,\n    onBroadcast,\n    ssrMode = false,\n    clientAwareness = {},\n    localState,\n    assumeImmutableResults,\n  }: {\n    cache: ApolloCache<TStore>;\n    link: ApolloLink;\n    defaultOptions?: DefaultOptions;\n    queryDeduplication?: boolean;\n    onBroadcast?: () => void;\n    ssrMode?: boolean;\n    clientAwareness?: Record<string, string>;\n    localState?: LocalState<TStore>;\n    assumeImmutableResults?: boolean;\n  }) {\n    this.cache = cache;\n    this.link = link;\n    this.defaultOptions = defaultOptions || Object.create(null);\n    this.queryDeduplication = queryDeduplication;\n    this.clientAwareness = clientAwareness;\n    this.localState = localState || new LocalState({ cache });\n    this.ssrMode = ssrMode;\n    this.assumeImmutableResults = !!assumeImmutableResults;\n    if ((this.onBroadcast = onBroadcast)) {\n      this.mutationStore = Object.create(null);\n    }\n  }\n\n  /**\n   * Call this method to terminate any active query processes, making it safe\n   * to dispose of this QueryManager instance.\n   */\n  public stop() {\n    this.queries.forEach((_info, queryId) => {\n      this.stopQueryNoBroadcast(queryId);\n    });\n\n    this.cancelPendingFetches(\n      new InvariantError('QueryManager stopped while query was in flight'),\n    );\n  }\n\n  private cancelPendingFetches(error: Error) {\n    this.fetchCancelFns.forEach(cancel => cancel(error));\n    this.fetchCancelFns.clear();\n  }\n\n  public async mutate<\n    TData,\n    TVariables,\n    TContext,\n    TCache extends ApolloCache<any>\n  >({\n    mutation,\n    variables,\n    optimisticResponse,\n    updateQueries,\n    refetchQueries = [],\n    awaitRefetchQueries = false,\n    update: updateWithProxyFn,\n    onQueryUpdated,\n    fetchPolicy = this.defaultOptions.mutate?.fetchPolicy || \"network-only\",\n    errorPolicy = this.defaultOptions.mutate?.errorPolicy || \"none\",\n    keepRootFields,\n    context,\n  }: MutationOptions<TData, TVariables, TContext>): Promise<FetchResult<TData>> {\n    invariant(\n      mutation,\n      'mutation option is required. You must specify your GraphQL document in the mutation option.',\n    );\n\n    invariant(\n      fetchPolicy === 'network-only' ||\n      fetchPolicy === 'no-cache',\n      \"Mutations support only 'network-only' or 'no-cache' fetchPolicy strings. The default `network-only` behavior automatically writes mutation results to the cache. Passing `no-cache` skips the cache write.\"\n    );\n\n    const mutationId = this.generateMutationId();\n\n    const {\n      document,\n      hasClientExports,\n    } = this.transform(mutation);\n    mutation = this.cache.transformForLink(document);\n\n    variables = this.getVariables(mutation, variables) as TVariables;\n    if (hasClientExports) {\n      variables = await this.localState.addExportedVariables(mutation, variables, context) as TVariables;\n    }\n\n    const mutationStoreValue =\n      this.mutationStore &&\n      (this.mutationStore[mutationId] = {\n        mutation,\n        variables,\n        loading: true,\n        error: null,\n      } as MutationStoreValue);\n\n    if (optimisticResponse) {\n      this.markMutationOptimistic<\n        TData,\n        TVariables,\n        TContext,\n        TCache\n      >(optimisticResponse, {\n        mutationId,\n        document: mutation,\n        variables,\n        fetchPolicy,\n        errorPolicy,\n        context,\n        updateQueries,\n        update: updateWithProxyFn,\n        keepRootFields,\n      });\n    }\n\n    this.broadcastQueries();\n\n    const self = this;\n\n    return new Promise((resolve, reject) => {\n      return asyncMap(\n        self.getObservableFromLink(\n          mutation,\n          {\n            ...context,\n            optimisticResponse,\n          },\n          variables,\n          false,\n        ),\n\n        (result: FetchResult<TData>) => {\n          if (graphQLResultHasError(result) && errorPolicy === 'none') {\n            throw new ApolloError({\n              graphQLErrors: result.errors,\n            });\n          }\n\n          if (mutationStoreValue) {\n            mutationStoreValue.loading = false;\n            mutationStoreValue.error = null;\n          }\n\n          const storeResult: typeof result = { ...result };\n\n          if (typeof refetchQueries === \"function\") {\n            refetchQueries = refetchQueries(storeResult);\n          }\n\n          if (errorPolicy === 'ignore' &&\n              graphQLResultHasError(storeResult)) {\n            delete storeResult.errors;\n          }\n\n          return self.markMutationResult<\n            TData,\n            TVariables,\n            TContext,\n            TCache\n          >({\n            mutationId,\n            result: storeResult,\n            document: mutation,\n            variables,\n            fetchPolicy,\n            errorPolicy,\n            context,\n            update: updateWithProxyFn,\n            updateQueries,\n            awaitRefetchQueries,\n            refetchQueries,\n            removeOptimistic: optimisticResponse ? mutationId : void 0,\n            onQueryUpdated,\n            keepRootFields,\n          });\n        },\n\n      ).subscribe({\n        next(storeResult) {\n          self.broadcastQueries();\n\n          // At the moment, a mutation can have only one result, so we can\n          // immediately resolve upon receiving the first result. In the future,\n          // mutations containing @defer or @stream directives might receive\n          // multiple FetchResult payloads from the ApolloLink chain, so we will\n          // probably need to collect those results in this next method and call\n          // resolve only later, in an observer.complete function.\n          resolve(storeResult);\n        },\n\n        error(err: Error) {\n          if (mutationStoreValue) {\n            mutationStoreValue.loading = false;\n            mutationStoreValue.error = err;\n          }\n\n          if (optimisticResponse) {\n            self.cache.removeOptimistic(mutationId);\n          }\n\n          self.broadcastQueries();\n\n          reject(\n            err instanceof ApolloError ? err : new ApolloError({\n              networkError: err,\n            }),\n          );\n        },\n      });\n    });\n  }\n\n  public markMutationResult<\n    TData,\n    TVariables,\n    TContext,\n    TCache extends ApolloCache<any>\n  >(\n    mutation: {\n      mutationId: string;\n      result: FetchResult<TData>;\n      document: DocumentNode;\n      variables?: TVariables;\n      fetchPolicy?: MutationFetchPolicy;\n      errorPolicy: ErrorPolicy;\n      context?: TContext;\n      updateQueries: UpdateQueries<TData>;\n      update?: MutationUpdaterFunction<TData, TVariables, TContext, TCache>;\n      awaitRefetchQueries?: boolean;\n      refetchQueries?: InternalRefetchQueriesInclude;\n      removeOptimistic?: string;\n      onQueryUpdated?: OnQueryUpdated<any>;\n      keepRootFields?: boolean;\n    },\n    cache = this.cache,\n  ): Promise<FetchResult<TData>> {\n    let { result } = mutation;\n    const cacheWrites: Cache.WriteOptions[] = [];\n    const skipCache = mutation.fetchPolicy === \"no-cache\";\n\n    if (!skipCache && shouldWriteResult(result, mutation.errorPolicy)) {\n      cacheWrites.push({\n        result: result.data,\n        dataId: 'ROOT_MUTATION',\n        query: mutation.document,\n        variables: mutation.variables,\n      });\n\n      const { updateQueries } = mutation;\n      if (updateQueries) {\n        this.queries.forEach(({ observableQuery }, queryId) => {\n          const queryName = observableQuery && observableQuery.queryName;\n          if (!queryName || !hasOwnProperty.call(updateQueries, queryName)) {\n            return;\n          }\n          const updater = updateQueries[queryName];\n          const { document, variables } = this.queries.get(queryId)!;\n\n          // Read the current query result from the store.\n          const { result: currentQueryResult, complete } = cache.diff<TData>({\n            query: document!,\n            variables,\n            returnPartialData: true,\n            optimistic: false,\n          });\n\n          if (complete && currentQueryResult) {\n            // Run our reducer using the current query result and the mutation result.\n            const nextQueryResult = updater(currentQueryResult, {\n              mutationResult: result,\n              queryName: document && getOperationName(document) || void 0,\n              queryVariables: variables!,\n            });\n\n            // Write the modified result back into the store if we got a new result.\n            if (nextQueryResult) {\n              cacheWrites.push({\n                result: nextQueryResult,\n                dataId: 'ROOT_QUERY',\n                query: document!,\n                variables,\n              });\n            }\n          }\n        });\n      }\n    }\n\n    if (\n      cacheWrites.length > 0 ||\n      mutation.refetchQueries ||\n      mutation.update ||\n      mutation.onQueryUpdated ||\n      mutation.removeOptimistic\n    ) {\n      const results: any[] = [];\n\n      this.refetchQueries({\n        updateCache: (cache: TCache) => {\n          if (!skipCache) {\n            cacheWrites.forEach(write => cache.write(write));\n          }\n\n          // If the mutation has some writes associated with it then we need to\n          // apply those writes to the store by running this reducer again with\n          // a write action.\n          const { update } = mutation;\n          if (update) {\n            if (!skipCache) {\n              // Re-read the ROOT_MUTATION data we just wrote into the cache\n              // (the first cache.write call in the cacheWrites.forEach loop\n              // above), so field read functions have a chance to run for\n              // fields within mutation result objects.\n              const diff = cache.diff<TData>({\n                id: \"ROOT_MUTATION\",\n                // The cache complains if passed a mutation where it expects a\n                // query, so we transform mutations and subscriptions to queries\n                // (only once, thanks to this.transformCache).\n                query: this.transform(mutation.document).asQuery,\n                variables: mutation.variables,\n                optimistic: false,\n                returnPartialData: true,\n              });\n\n              if (diff.complete && !(isExecutionPatchIncrementalResult(result))) {\n                result = { ...result, data: diff.result };\n              }\n            }\n\n            update(cache, result, {\n              context: mutation.context,\n              variables: mutation.variables,\n            });\n          }\n\n          // TODO Do this with cache.evict({ id: 'ROOT_MUTATION' }) but make it\n          // shallow to allow rolling back optimistic evictions.\n          if (!skipCache && !mutation.keepRootFields) {\n            cache.modify({\n              id: 'ROOT_MUTATION',\n              fields(value, { fieldName, DELETE }) {\n                return fieldName === \"__typename\" ? value : DELETE;\n              },\n            });\n          }\n        },\n\n        include: mutation.refetchQueries,\n\n        // Write the final mutation.result to the root layer of the cache.\n        optimistic: false,\n\n        // Remove the corresponding optimistic layer at the same time as we\n        // write the final non-optimistic result.\n        removeOptimistic: mutation.removeOptimistic,\n\n        // Let the caller of client.mutate optionally determine the refetching\n        // behavior for watched queries after the mutation.update function runs.\n        // If no onQueryUpdated function was provided for this mutation, pass\n        // null instead of undefined to disable the default refetching behavior.\n        onQueryUpdated: mutation.onQueryUpdated || null,\n\n      }).forEach(result => results.push(result));\n\n      if (mutation.awaitRefetchQueries || mutation.onQueryUpdated) {\n        // Returning a promise here makes the mutation await that promise, so we\n        // include results in that promise's work if awaitRefetchQueries or an\n        // onQueryUpdated function was specified.\n        return Promise.all(results).then(() => result);\n      }\n    }\n\n    return Promise.resolve(result);\n  }\n\n  public markMutationOptimistic<TData, TVariables, TContext, TCache extends ApolloCache<any>>(\n    optimisticResponse: any,\n    mutation: {\n      mutationId: string;\n      document: DocumentNode;\n      variables?: TVariables;\n      fetchPolicy?: MutationFetchPolicy;\n      errorPolicy: ErrorPolicy;\n      context?: TContext;\n      updateQueries: UpdateQueries<TData>,\n      update?: MutationUpdaterFunction<TData, TVariables, TContext, TCache>;\n      keepRootFields?: boolean,\n    },\n  ) {\n    const data = typeof optimisticResponse === \"function\"\n      ? optimisticResponse(mutation.variables)\n      : optimisticResponse;\n\n    return this.cache.recordOptimisticTransaction(cache => {\n      try {\n        this.markMutationResult<TData, TVariables, TContext, TCache>({\n          ...mutation,\n          result: { data },\n        }, cache);\n      } catch (error) {\n        invariant.error(error);\n      }\n    }, mutation.mutationId);\n  }\n\n  public fetchQuery<TData, TVars>(\n    queryId: string,\n    options: WatchQueryOptions<TVars, TData>,\n    networkStatus?: NetworkStatus,\n  ): Promise<ApolloQueryResult<TData>> {\n    return this.fetchQueryObservable<TData, TVars>(\n      queryId,\n      options,\n      networkStatus,\n    ).promise;\n  }\n\n  public getQueryStore() {\n    const store: Record<string, QueryStoreValue> = Object.create(null);\n    this.queries.forEach((info, queryId) => {\n      store[queryId] = {\n        variables: info.variables,\n        networkStatus: info.networkStatus,\n        networkError: info.networkError,\n        graphQLErrors: info.graphQLErrors,\n      };\n    });\n    return store;\n  }\n\n  public resetErrors(queryId: string) {\n    const queryInfo = this.queries.get(queryId);\n    if (queryInfo) {\n      queryInfo.networkError = undefined;\n      queryInfo.graphQLErrors = [];\n    }\n  }\n\n  private transformCache = new (\n    canUseWeakMap ? WeakMap : Map\n  )<DocumentNode, TransformCacheEntry>();\n\n  public transform(document: DocumentNode) {\n    const { transformCache } = this;\n\n    if (!transformCache.has(document)) {\n      const transformed = this.cache.transformDocument(document);\n      const noConnection = removeConnectionDirectiveFromDocument(transformed);\n      const clientQuery = this.localState.clientQuery(transformed);\n      const serverQuery = noConnection && this.localState.serverQuery(noConnection);\n\n      const cacheEntry: TransformCacheEntry = {\n        document: transformed,\n        // TODO These two calls (hasClientExports and shouldForceResolvers)\n        // could probably be merged into a single traversal.\n        hasClientExports: hasClientExports(transformed),\n        hasForcedResolvers: this.localState.shouldForceResolvers(transformed),\n        clientQuery,\n        serverQuery,\n        defaultVars: getDefaultValues(\n          getOperationDefinition(transformed)\n        ) as OperationVariables,\n        // Transform any mutation or subscription operations to query operations\n        // so we can read/write them from/to the cache.\n        asQuery: {\n          ...transformed,\n          definitions: transformed.definitions.map(def => {\n            if (def.kind === \"OperationDefinition\" &&\n                def.operation !== \"query\") {\n              return { ...def, operation: \"query\" as OperationTypeNode };\n            }\n            return def;\n          }),\n        }\n      };\n\n      const add = (doc: DocumentNode | null) => {\n        if (doc && !transformCache.has(doc)) {\n          transformCache.set(doc, cacheEntry);\n        }\n      }\n      // Add cacheEntry to the transformCache using several different keys,\n      // since any one of these documents could end up getting passed to the\n      // transform method again in the future.\n      add(document);\n      add(transformed);\n      add(clientQuery);\n      add(serverQuery);\n    }\n\n    return transformCache.get(document)!;\n  }\n\n  private getVariables<TVariables>(\n    document: DocumentNode,\n    variables?: TVariables,\n  ): OperationVariables {\n    return {\n      ...this.transform(document).defaultVars,\n      ...variables,\n    };\n  }\n\n  public watchQuery<T, TVariables = OperationVariables>(\n    options: WatchQueryOptions<TVariables, T>,\n  ): ObservableQuery<T, TVariables> {\n    // assign variable default values if supplied\n    options = {\n      ...options,\n      variables: this.getVariables(\n        options.query,\n        options.variables,\n      ) as TVariables,\n    };\n\n    if (typeof options.notifyOnNetworkStatusChange === 'undefined') {\n      options.notifyOnNetworkStatusChange = false;\n    }\n\n    const queryInfo = new QueryInfo(this);\n    const observable = new ObservableQuery<T, TVariables>({\n      queryManager: this,\n      queryInfo,\n      options,\n    });\n\n    this.queries.set(observable.queryId, queryInfo);\n\n    queryInfo.init({\n      document: observable.query,\n      observableQuery: observable,\n      variables: observable.variables,\n    });\n\n    return observable;\n  }\n\n  public query<TData, TVars = OperationVariables>(\n    options: QueryOptions<TVars, TData>,\n    queryId = this.generateQueryId(),\n  ): Promise<ApolloQueryResult<TData>> {\n    invariant(\n      options.query,\n      'query option is required. You must specify your GraphQL document ' +\n        'in the query option.',\n    );\n\n    invariant(\n      options.query.kind === 'Document',\n      'You must wrap the query string in a \"gql\" tag.',\n    );\n\n    invariant(\n      !(options as any).returnPartialData,\n      'returnPartialData option only supported on watchQuery.',\n    );\n\n    invariant(\n      !(options as any).pollInterval,\n      'pollInterval option only supported on watchQuery.',\n    );\n\n    return this.fetchQuery<TData, TVars>(\n      queryId,\n      options,\n    ).finally(() => this.stopQuery(queryId));\n  }\n\n  private queryIdCounter = 1;\n  public generateQueryId() {\n    return String(this.queryIdCounter++);\n  }\n\n  private requestIdCounter = 1;\n  public generateRequestId() {\n    return this.requestIdCounter++;\n  }\n\n  private mutationIdCounter = 1;\n  public generateMutationId() {\n    return String(this.mutationIdCounter++);\n  }\n\n  public stopQueryInStore(queryId: string) {\n    this.stopQueryInStoreNoBroadcast(queryId);\n    this.broadcastQueries();\n  }\n\n  private stopQueryInStoreNoBroadcast(queryId: string) {\n    const queryInfo = this.queries.get(queryId);\n    if (queryInfo) queryInfo.stop();\n  }\n\n  public clearStore(options: Cache.ResetOptions = {\n    discardWatches: true,\n  }): Promise<void> {\n    // Before we have sent the reset action to the store, we can no longer\n    // rely on the results returned by in-flight requests since these may\n    // depend on values that previously existed in the data portion of the\n    // store. So, we cancel the promises and observers that we have issued\n    // so far and not yet resolved (in the case of queries).\n    this.cancelPendingFetches(new InvariantError(\n      'Store reset while query was in flight (not completed in link chain)',\n    ));\n\n    this.queries.forEach(queryInfo => {\n      if (queryInfo.observableQuery) {\n        // Set loading to true so listeners don't trigger unless they want\n        // results with partial data.\n        queryInfo.networkStatus = NetworkStatus.loading;\n      } else {\n        queryInfo.stop();\n      }\n    });\n\n    if (this.mutationStore) {\n      this.mutationStore = Object.create(null);\n    }\n\n    // begin removing data from the store\n    return this.cache.reset(options);\n  }\n\n  public getObservableQueries(\n    include: InternalRefetchQueriesInclude = \"active\",\n  ) {\n    const queries = new Map<string, ObservableQuery<any>>();\n    const queryNamesAndDocs = new Map<string | DocumentNode, boolean>();\n    const legacyQueryOptions = new Set<QueryOptions>();\n\n    if (Array.isArray(include)) {\n      include.forEach(desc => {\n        if (typeof desc === \"string\") {\n          queryNamesAndDocs.set(desc, false);\n        } else if (isDocumentNode(desc)) {\n          queryNamesAndDocs.set(this.transform(desc).document, false);\n        } else if (isNonNullObject(desc) && desc.query) {\n          legacyQueryOptions.add(desc);\n        }\n      });\n    }\n\n    this.queries.forEach(({ observableQuery: oq, document }, queryId) => {\n      if (oq) {\n        if (include === \"all\") {\n          queries.set(queryId, oq);\n          return;\n        }\n\n        const {\n          queryName,\n          options: { fetchPolicy },\n        } = oq;\n\n        if (\n          fetchPolicy === \"standby\" ||\n          (include === \"active\" && !oq.hasObservers())\n        ) {\n          return;\n        }\n\n        if (\n          include === \"active\" ||\n          (queryName && queryNamesAndDocs.has(queryName)) ||\n          (document && queryNamesAndDocs.has(document))\n        ) {\n          queries.set(queryId, oq);\n          if (queryName) queryNamesAndDocs.set(queryName, true);\n          if (document) queryNamesAndDocs.set(document, true);\n        }\n      }\n    });\n\n    if (legacyQueryOptions.size) {\n      legacyQueryOptions.forEach((options: QueryOptions) => {\n        // We will be issuing a fresh network request for this query, so we\n        // pre-allocate a new query ID here, using a special prefix to enable\n        // cleaning up these temporary queries later, after fetching.\n        const queryId = makeUniqueId(\"legacyOneTimeQuery\");\n        const queryInfo = this.getQuery(queryId).init({\n          document: options.query,\n          variables: options.variables,\n        });\n        const oq = new ObservableQuery({\n          queryManager: this,\n          queryInfo,\n          options: {\n            ...options,\n            fetchPolicy: \"network-only\",\n          },\n        });\n        invariant(oq.queryId === queryId);\n        queryInfo.setObservableQuery(oq);\n        queries.set(queryId, oq);\n      });\n    }\n\n    if (__DEV__ && queryNamesAndDocs.size) {\n      queryNamesAndDocs.forEach((included, nameOrDoc) => {\n        if (!included) {\n          invariant.warn(`Unknown query ${\n            typeof nameOrDoc === \"string\" ? \"named \" : \"\"\n          }${\n            JSON.stringify(nameOrDoc, null, 2)\n          } requested in refetchQueries options.include array`);\n        }\n      });\n    }\n\n    return queries;\n  }\n\n  public reFetchObservableQueries(\n    includeStandby: boolean = false,\n  ): Promise<ApolloQueryResult<any>[]> {\n    const observableQueryPromises: Promise<ApolloQueryResult<any>>[] = [];\n\n    this.getObservableQueries(\n      includeStandby ? \"all\" : \"active\"\n    ).forEach((observableQuery, queryId) => {\n      const { fetchPolicy } = observableQuery.options;\n      observableQuery.resetLastResults();\n      if (includeStandby ||\n          (fetchPolicy !== \"standby\" &&\n           fetchPolicy !== \"cache-only\")) {\n        observableQueryPromises.push(observableQuery.refetch());\n      }\n      this.getQuery(queryId).setDiff(null);\n    });\n\n    this.broadcastQueries();\n\n    return Promise.all(observableQueryPromises);\n  }\n\n  public setObservableQuery(observableQuery: ObservableQuery<any, any>) {\n    this.getQuery(observableQuery.queryId).setObservableQuery(observableQuery);\n  }\n\n  public startGraphQLSubscription<T = any>({\n    query,\n    fetchPolicy,\n    errorPolicy,\n    variables,\n    context = {},\n  }: SubscriptionOptions): Observable<FetchResult<T>> {\n    query = this.transform(query).document;\n    variables = this.getVariables(query, variables);\n\n    const makeObservable = (variables: OperationVariables) =>\n      this.getObservableFromLink<T>(\n        query,\n        context,\n        variables,\n      ).map(result => {\n        if (fetchPolicy !== 'no-cache') {\n          // the subscription interface should handle not sending us results we no longer subscribe to.\n          // XXX I don't think we ever send in an object with errors, but we might in the future...\n          if (shouldWriteResult(result, errorPolicy)) {\n            this.cache.write({\n              query,\n              result: result.data,\n              dataId: 'ROOT_SUBSCRIPTION',\n              variables: variables,\n            });\n          }\n\n          this.broadcastQueries();\n        }\n\n        if (graphQLResultHasError(result)) {\n          throw new ApolloError({\n            graphQLErrors: result.errors,\n          });\n        }\n\n        return result;\n      });\n\n    if (this.transform(query).hasClientExports) {\n      const observablePromise = this.localState.addExportedVariables(\n        query,\n        variables,\n        context,\n      ).then(makeObservable);\n\n      return new Observable<FetchResult<T>>(observer => {\n        let sub: ObservableSubscription | null = null;\n        observablePromise.then(\n          observable => sub = observable.subscribe(observer),\n          observer.error,\n        );\n        return () => sub && sub.unsubscribe();\n      });\n    }\n\n    return makeObservable(variables);\n  }\n\n  public stopQuery(queryId: string) {\n    this.stopQueryNoBroadcast(queryId);\n    this.broadcastQueries();\n  }\n\n  private stopQueryNoBroadcast(queryId: string) {\n    this.stopQueryInStoreNoBroadcast(queryId);\n    this.removeQuery(queryId);\n  }\n\n  public removeQuery(queryId: string) {\n    // teardown all links\n    // Both `QueryManager.fetchRequest` and `QueryManager.query` create separate promises\n    // that each add their reject functions to fetchCancelFns.\n    // A query created with `QueryManager.query()` could trigger a `QueryManager.fetchRequest`.\n    // The same queryId could have two rejection fns for two promises\n    this.fetchCancelFns.delete(queryId);\n    if (this.queries.has(queryId)) {\n      this.getQuery(queryId).stop();\n      this.queries.delete(queryId);\n    }\n  }\n\n  public broadcastQueries() {\n    if (this.onBroadcast) this.onBroadcast();\n    this.queries.forEach(info => info.notify());\n  }\n\n  public getLocalState(): LocalState<TStore> {\n    return this.localState;\n  }\n\n  private inFlightLinkObservables = new Map<\n    DocumentNode,\n    Map<string, Observable<FetchResult>>\n  >();\n\n  private getObservableFromLink<T = any>(\n    query: DocumentNode,\n    context: any,\n    variables?: OperationVariables,\n    deduplication: boolean =\n      // Prefer context.queryDeduplication if specified.\n      context?.queryDeduplication ??\n      this.queryDeduplication,\n  ): Observable<FetchResult<T>> {\n    let observable: Observable<FetchResult<T>>;\n\n    const { serverQuery } = this.transform(query);\n    if (serverQuery) {\n      const { inFlightLinkObservables, link } = this;\n\n      const operation = {\n        query: serverQuery,\n        variables,\n        operationName: getOperationName(serverQuery) || void 0,\n        context: this.prepareContext({\n          ...context,\n          forceFetch: !deduplication\n        }),\n      };\n\n      context = operation.context;\n\n      if (deduplication) {\n        const byVariables = inFlightLinkObservables.get(serverQuery) || new Map();\n        inFlightLinkObservables.set(serverQuery, byVariables);\n\n        const varJson = canonicalStringify(variables);\n        observable = byVariables.get(varJson);\n\n        if (!observable) {\n          const concast = new Concast([\n            execute(link, operation) as Observable<FetchResult<T>>\n          ]);\n\n          byVariables.set(varJson, observable = concast);\n\n          concast.beforeNext(() => {\n            if (byVariables.delete(varJson) &&\n                byVariables.size < 1) {\n              inFlightLinkObservables.delete(serverQuery);\n            }\n          });\n        }\n\n      } else {\n        observable = new Concast([\n          execute(link, operation) as Observable<FetchResult<T>>\n        ]);\n      }\n    } else {\n      observable = new Concast([\n        Observable.of({ data: {} } as FetchResult<T>)\n      ]);\n      context = this.prepareContext(context);\n    }\n\n    const { clientQuery } = this.transform(query);\n    if (clientQuery) {\n      observable = asyncMap(observable, result => {\n        return this.localState.runResolvers({\n          document: clientQuery,\n          remoteResult: result,\n          context,\n          variables,\n        });\n      });\n    }\n\n    return observable;\n  }\n\n  private getResultsFromLink<TData, TVars>(\n    queryInfo: QueryInfo,\n    cacheWriteBehavior: CacheWriteBehavior,\n    options: Pick<WatchQueryOptions<TVars, TData>,\n      | \"variables\"\n      | \"context\"\n      | \"fetchPolicy\"\n      | \"errorPolicy\">,\n  ): Observable<ApolloQueryResult<TData>> {\n    const requestId = queryInfo.lastRequestId = this.generateRequestId();\n\n    // Make sure we write the result below using the same options we were given,\n    // even though the input object may have been modified in the meantime.\n    options = cloneDeep(options);\n\n    // Performing transformForLink here gives this.cache a chance to fill in\n    // missing fragment definitions (for example) before sending this document\n    // through the link chain.\n    const linkDocument = this.cache.transformForLink(\n      // Use same document originally produced by this.cache.transformDocument.\n      this.transform(queryInfo.document!).document\n    );\n\n    return asyncMap(\n      this.getObservableFromLink(\n        linkDocument,\n        options.context,\n        options.variables,\n      ),\n\n      result => {\n        const graphQLErrors = isNonEmptyArray(result.errors)\n          ? result.errors.slice(0)\n          : [];\n\n        if ('incremental' in result && isNonEmptyArray(result.incremental)) {\n          result.incremental.forEach(incrementalResult => {\n            if (incrementalResult.errors) {\n              graphQLErrors.push(...incrementalResult.errors);\n            }\n          });\n        }\n\n        const hasErrors = isNonEmptyArray(graphQLErrors);\n\n        // If we interrupted this request by calling getResultsFromLink again\n        // with the same QueryInfo object, we ignore the old results.\n        if (requestId >= queryInfo.lastRequestId) {\n          if (hasErrors && options.errorPolicy === \"none\") {\n            // Throwing here effectively calls observer.error.\n            throw queryInfo.markError(new ApolloError({\n              graphQLErrors,\n            }));\n          }\n          // Use linkDocument rather than queryInfo.document so the\n          // operation/fragments used to write the result are the same as the\n          // ones used to obtain it from the link.\n          queryInfo.markResult(result, linkDocument, options, cacheWriteBehavior);\n          queryInfo.markReady();\n        }\n\n        const aqr: ApolloQueryResult<TData> = {\n          data: result.data,\n          loading: false,\n          networkStatus: NetworkStatus.ready,\n        };\n\n        if (hasErrors && options.errorPolicy !== \"ignore\") {\n          aqr.errors = graphQLErrors;\n          aqr.networkStatus = NetworkStatus.error;\n        }\n\n        return aqr;\n      },\n\n      networkError => {\n        const error = isApolloError(networkError)\n          ? networkError\n          : new ApolloError({ networkError });\n\n        // Avoid storing errors from older interrupted queries.\n        if (requestId >= queryInfo.lastRequestId) {\n          queryInfo.markError(error);\n        }\n\n        throw error;\n      },\n    );\n  }\n\n  public fetchQueryObservable<TData, TVars>(\n    queryId: string,\n    options: WatchQueryOptions<TVars, TData>,\n    // The initial networkStatus for this fetch, most often\n    // NetworkStatus.loading, but also possibly fetchMore, poll, refetch,\n    // or setVariables.\n    networkStatus = NetworkStatus.loading,\n  ): Concast<ApolloQueryResult<TData>> {\n    const query = this.transform(options.query).document;\n    const variables = this.getVariables(query, options.variables) as TVars;\n    const queryInfo = this.getQuery(queryId);\n\n    const defaults = this.defaultOptions.watchQuery;\n    let {\n      fetchPolicy = defaults && defaults.fetchPolicy || \"cache-first\",\n      errorPolicy = defaults && defaults.errorPolicy || \"none\",\n      returnPartialData = false,\n      notifyOnNetworkStatusChange = false,\n      context = {},\n    } = options;\n\n    const normalized = Object.assign({}, options, {\n      query,\n      variables,\n      fetchPolicy,\n      errorPolicy,\n      returnPartialData,\n      notifyOnNetworkStatusChange,\n      context,\n    });\n\n    const fromVariables = (variables: TVars) => {\n      // Since normalized is always a fresh copy of options, it's safe to\n      // modify its properties here, rather than creating yet another new\n      // WatchQueryOptions object.\n      normalized.variables = variables;\n\n      const concastSources = this.fetchQueryByPolicy<TData, TVars>(\n        queryInfo,\n        normalized,\n        networkStatus,\n      );\n\n      if (\n        // If we're in standby, postpone advancing options.fetchPolicy using\n        // applyNextFetchPolicy.\n        normalized.fetchPolicy !== \"standby\" &&\n        // The \"standby\" policy currently returns [] from fetchQueryByPolicy, so\n        // this is another way to detect when nothing was done/fetched.\n        concastSources.length > 0 &&\n        queryInfo.observableQuery\n      ) {\n        queryInfo.observableQuery[\"applyNextFetchPolicy\"](\"after-fetch\", options);\n      }\n\n      return concastSources;\n    };\n\n    // This cancel function needs to be set before the concast is created,\n    // in case concast creation synchronously cancels the request.\n    const cleanupCancelFn = () => this.fetchCancelFns.delete(queryId);\n    this.fetchCancelFns.set(queryId, reason => {\n      cleanupCancelFn();\n      // This delay ensures the concast variable has been initialized.\n      setTimeout(() => concast.cancel(reason));\n    });\n\n    // A Concast<T> can be created either from an Iterable<Observable<T>>\n    // or from a PromiseLike<Iterable<Observable<T>>>, where T in this\n    // case is ApolloQueryResult<TData>.\n    const concast = new Concast(\n      // If the query has @export(as: ...) directives, then we need to\n      // process those directives asynchronously. When there are no\n      // @export directives (the common case), we deliberately avoid\n      // wrapping the result of this.fetchQueryByPolicy in a Promise,\n      // since the timing of result delivery is (unfortunately) important\n      // for backwards compatibility. TODO This code could be simpler if\n      // we deprecated and removed LocalState.\n      this.transform(normalized.query).hasClientExports\n        ? this.localState.addExportedVariables(\n          normalized.query,\n          normalized.variables,\n          normalized.context,\n        ).then(fromVariables)\n        : fromVariables(normalized.variables!)\n    );\n\n    concast.promise.then(cleanupCancelFn, cleanupCancelFn);\n\n    return concast;\n  }\n\n  public refetchQueries<TResult>({\n    updateCache,\n    include,\n    optimistic = false,\n    removeOptimistic = optimistic ? makeUniqueId(\"refetchQueries\") : void 0,\n    onQueryUpdated,\n  }: InternalRefetchQueriesOptions<ApolloCache<TStore>, TResult>\n  ): InternalRefetchQueriesMap<TResult> {\n    const includedQueriesById = new Map<string, {\n      oq: ObservableQuery<any>;\n      lastDiff?: Cache.DiffResult<any>;\n      diff?: Cache.DiffResult<any>;\n    }>();\n\n    if (include) {\n      this.getObservableQueries(include).forEach((oq, queryId) => {\n        includedQueriesById.set(queryId, {\n          oq,\n          lastDiff: this.getQuery(queryId).getDiff(),\n        });\n      });\n    }\n\n    const results: InternalRefetchQueriesMap<TResult> = new Map;\n\n    if (updateCache) {\n      this.cache.batch({\n        update: updateCache,\n\n        // Since you can perform any combination of cache reads and/or writes in\n        // the cache.batch update function, its optimistic option can be either\n        // a boolean or a string, representing three distinct modes of\n        // operation:\n        //\n        // * false: read/write only the root layer\n        // * true: read/write the topmost layer\n        // * string: read/write a fresh optimistic layer with that ID string\n        //\n        // When typeof optimistic === \"string\", a new optimistic layer will be\n        // temporarily created within cache.batch with that string as its ID. If\n        // we then pass that same string as the removeOptimistic option, we can\n        // make cache.batch immediately remove the optimistic layer after\n        // running the updateCache function, triggering only one broadcast.\n        //\n        // However, the refetchQueries method accepts only true or false for its\n        // optimistic option (not string). We interpret true to mean a temporary\n        // optimistic layer should be created, to allow efficiently rolling back\n        // the effect of the updateCache function, which involves passing a\n        // string instead of true as the optimistic option to cache.batch, when\n        // refetchQueries receives optimistic: true.\n        //\n        // In other words, we are deliberately not supporting the use case of\n        // writing to an *existing* optimistic layer (using the refetchQueries\n        // updateCache function), since that would potentially interfere with\n        // other optimistic updates in progress. Instead, you can read/write\n        // only the root layer by passing optimistic: false to refetchQueries,\n        // or you can read/write a brand new optimistic layer that will be\n        // automatically removed by passing optimistic: true.\n        optimistic: optimistic && removeOptimistic || false,\n\n        // The removeOptimistic option can also be provided by itself, even if\n        // optimistic === false, to remove some previously-added optimistic\n        // layer safely and efficiently, like we do in markMutationResult.\n        //\n        // If an explicit removeOptimistic string is provided with optimistic:\n        // true, the removeOptimistic string will determine the ID of the\n        // temporary optimistic layer, in case that ever matters.\n        removeOptimistic,\n\n        onWatchUpdated(watch, diff, lastDiff) {\n          const oq =\n            watch.watcher instanceof QueryInfo &&\n            watch.watcher.observableQuery;\n\n          if (oq) {\n            if (onQueryUpdated) {\n              // Since we're about to handle this query now, remove it from\n              // includedQueriesById, in case it was added earlier because of\n              // options.include.\n              includedQueriesById.delete(oq.queryId);\n\n              let result: TResult | boolean | Promise<ApolloQueryResult<any>> =\n                onQueryUpdated(oq, diff, lastDiff);\n\n              if (result === true) {\n                // The onQueryUpdated function requested the default refetching\n                // behavior by returning true.\n                result = oq.refetch();\n              }\n\n              // Record the result in the results Map, as long as onQueryUpdated\n              // did not return false to skip/ignore this result.\n              if (result !== false) {\n                results.set(oq, result as InternalRefetchQueriesResult<TResult>);\n              }\n\n              // Allow the default cache broadcast to happen, except when\n              // onQueryUpdated returns false.\n              return result;\n            }\n\n            if (onQueryUpdated !== null) {\n              // If we don't have an onQueryUpdated function, and onQueryUpdated\n              // was not disabled by passing null, make sure this query is\n              // \"included\" like any other options.include-specified query.\n              includedQueriesById.set(oq.queryId, { oq, lastDiff, diff });\n            }\n          }\n        },\n      });\n    }\n\n    if (includedQueriesById.size) {\n      includedQueriesById.forEach(({ oq, lastDiff, diff }, queryId) => {\n        let result: TResult | boolean | Promise<ApolloQueryResult<any>> | undefined;\n\n        // If onQueryUpdated is provided, we want to use it for all included\n        // queries, even the QueryOptions ones.\n        if (onQueryUpdated) {\n          if (!diff) {\n            const info = oq[\"queryInfo\"];\n            info.reset(); // Force info.getDiff() to read from cache.\n            diff = info.getDiff();\n          }\n          result = onQueryUpdated(oq, diff, lastDiff);\n        }\n\n        // Otherwise, we fall back to refetching.\n        if (!onQueryUpdated || result === true) {\n          result = oq.refetch();\n        }\n\n        if (result !== false) {\n          results.set(oq, result as InternalRefetchQueriesResult<TResult>);\n        }\n\n        if (queryId.indexOf(\"legacyOneTimeQuery\") >= 0) {\n          this.stopQueryNoBroadcast(queryId);\n        }\n      });\n    }\n\n    if (removeOptimistic) {\n      // In case no updateCache callback was provided (so cache.batch was not\n      // called above, and thus did not already remove the optimistic layer),\n      // remove it here. Since this is a no-op when the layer has already been\n      // removed, we do it even if we called cache.batch above, since it's\n      // possible this.cache is an instance of some ApolloCache subclass other\n      // than InMemoryCache, and does not fully support the removeOptimistic\n      // option for cache.batch.\n      this.cache.removeOptimistic(removeOptimistic);\n    }\n\n    return results;\n  }\n\n  private fetchQueryByPolicy<TData, TVars>(\n    queryInfo: QueryInfo,\n    { query,\n      variables,\n      fetchPolicy,\n      refetchWritePolicy,\n      errorPolicy,\n      returnPartialData,\n      context,\n      notifyOnNetworkStatusChange,\n    }: WatchQueryOptions<TVars, TData>,\n    // The initial networkStatus for this fetch, most often\n    // NetworkStatus.loading, but also possibly fetchMore, poll, refetch,\n    // or setVariables.\n    networkStatus: NetworkStatus,\n  ): ConcastSourcesArray<ApolloQueryResult<TData>> {\n    const oldNetworkStatus = queryInfo.networkStatus;\n\n    queryInfo.init({\n      document: this.transform(query).document,\n      variables,\n      networkStatus,\n    });\n\n    const readCache = () => queryInfo.getDiff(variables);\n\n    const resultsFromCache = (\n      diff: Cache.DiffResult<TData>,\n      networkStatus = queryInfo.networkStatus || NetworkStatus.loading,\n    ) => {\n      const data = diff.result;\n\n      if (__DEV__ &&\n          !returnPartialData &&\n          !equal(data, {})) {\n        logMissingFieldErrors(diff.missing);\n      }\n\n      const fromData = (data: TData | undefined) => Observable.of({\n        data,\n        loading: isNetworkRequestInFlight(networkStatus),\n        networkStatus,\n        ...(diff.complete ? null : { partial: true }),\n      } as ApolloQueryResult<TData>);\n\n      if (data && this.transform(query).hasForcedResolvers) {\n        return this.localState.runResolvers({\n          document: query,\n          remoteResult: { data },\n          context,\n          variables,\n          onlyRunForcedResolvers: true,\n        }).then(resolved => fromData(resolved.data || void 0));\n      }\n\n      return fromData(data);\n    };\n\n    const cacheWriteBehavior =\n      fetchPolicy === \"no-cache\" ? CacheWriteBehavior.FORBID :\n      ( // Watched queries must opt into overwriting existing data on refetch,\n        // by passing refetchWritePolicy: \"overwrite\" in their WatchQueryOptions.\n        networkStatus === NetworkStatus.refetch &&\n        refetchWritePolicy !== \"merge\"\n      ) ? CacheWriteBehavior.OVERWRITE\n        : CacheWriteBehavior.MERGE;\n\n    const resultsFromLink = () => this.getResultsFromLink<TData, TVars>(\n      queryInfo,\n      cacheWriteBehavior,\n      {\n        variables,\n        context,\n        fetchPolicy,\n        errorPolicy,\n      },\n    );\n\n    const shouldNotify =\n      notifyOnNetworkStatusChange &&\n      typeof oldNetworkStatus === \"number\" &&\n      oldNetworkStatus !== networkStatus &&\n      isNetworkRequestInFlight(networkStatus);\n\n    switch (fetchPolicy) {\n    default: case \"cache-first\": {\n      const diff = readCache();\n\n      if (diff.complete) {\n        return [\n          resultsFromCache(diff, queryInfo.markReady()),\n        ];\n      }\n\n      if (returnPartialData || shouldNotify) {\n        return [\n          resultsFromCache(diff),\n          resultsFromLink(),\n        ];\n      }\n\n      return [\n        resultsFromLink(),\n      ];\n    }\n\n    case \"cache-and-network\": {\n      const diff = readCache();\n\n      if (diff.complete || returnPartialData || shouldNotify) {\n        return [\n          resultsFromCache(diff),\n          resultsFromLink(),\n        ];\n      }\n\n      return [\n        resultsFromLink(),\n      ];\n    }\n\n    case \"cache-only\":\n      return [\n        resultsFromCache(readCache(), queryInfo.markReady()),\n      ];\n\n    case \"network-only\":\n      if (shouldNotify) {\n        return [\n          resultsFromCache(readCache()),\n          resultsFromLink(),\n        ];\n      }\n\n      return [resultsFromLink()];\n\n    case \"no-cache\":\n      if (shouldNotify) {\n        return [\n          // Note that queryInfo.getDiff() for no-cache queries does not call\n          // cache.diff, but instead returns a { complete: false } stub result\n          // when there is no queryInfo.diff already defined.\n          resultsFromCache(queryInfo.getDiff()),\n          resultsFromLink(),\n        ];\n      }\n\n      return [resultsFromLink()];\n\n    case \"standby\":\n      return [];\n    }\n  }\n\n  private getQuery(queryId: string): QueryInfo {\n    if (queryId && !this.queries.has(queryId)) {\n      this.queries.set(queryId, new QueryInfo(this, queryId));\n    }\n    return this.queries.get(queryId)!;\n  }\n\n  private prepareContext(context = {}) {\n    const newContext = this.localState.prepareContext(context);\n    return {\n      ...newContext,\n      clientAwareness: this.clientAwareness,\n    };\n  }\n}\n"]},"metadata":{},"sourceType":"module"}