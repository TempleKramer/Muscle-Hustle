{"ast":null,"code":"import{__assign,__spreadArray}from\"tslib\";import{invariant}from\"../globals/index.js\";import{visit}from'graphql';import{checkDocument,getOperationDefinition,getFragmentDefinition,getFragmentDefinitions,getMainDefinition}from\"./getFromAST.js\";import{filterInPlace}from\"../common/filterInPlace.js\";import{isField,isInlineFragment}from\"./storeUtils.js\";import{createFragmentMap}from\"./fragments.js\";var TYPENAME_FIELD={kind:'Field',name:{kind:'Name',value:'__typename'}};function isEmpty(op,fragmentMap){return!op||op.selectionSet.selections.every(function(selection){return selection.kind==='FragmentSpread'&&isEmpty(fragmentMap[selection.name.value],fragmentMap);});}function nullIfDocIsEmpty(doc){return isEmpty(getOperationDefinition(doc)||getFragmentDefinition(doc),createFragmentMap(getFragmentDefinitions(doc)))?null:doc;}function getDirectiveMatcher(directives){return function directiveMatcher(directive){return directives.some(function(dir){return dir.name&&dir.name===directive.name.value||dir.test&&dir.test(directive);});};}export function removeDirectivesFromDocument(directives,doc){var variablesInUse=Object.create(null);var variablesToRemove=[];var fragmentSpreadsInUse=Object.create(null);var fragmentSpreadsToRemove=[];var modifiedDoc=nullIfDocIsEmpty(visit(doc,{Variable:{enter:function enter(node,_key,parent){if(parent.kind!=='VariableDefinition'){variablesInUse[node.name.value]=true;}}},Field:{enter:function enter(node){if(directives&&node.directives){var shouldRemoveField=directives.some(function(directive){return directive.remove;});if(shouldRemoveField&&node.directives&&node.directives.some(getDirectiveMatcher(directives))){if(node.arguments){node.arguments.forEach(function(arg){if(arg.value.kind==='Variable'){variablesToRemove.push({name:arg.value.name.value});}});}if(node.selectionSet){getAllFragmentSpreadsFromSelectionSet(node.selectionSet).forEach(function(frag){fragmentSpreadsToRemove.push({name:frag.name.value});});}return null;}}}},FragmentSpread:{enter:function enter(node){fragmentSpreadsInUse[node.name.value]=true;}},Directive:{enter:function enter(node){if(getDirectiveMatcher(directives)(node)){return null;}}}}));if(modifiedDoc&&filterInPlace(variablesToRemove,function(v){return!!v.name&&!variablesInUse[v.name];}).length){modifiedDoc=removeArgumentsFromDocument(variablesToRemove,modifiedDoc);}if(modifiedDoc&&filterInPlace(fragmentSpreadsToRemove,function(fs){return!!fs.name&&!fragmentSpreadsInUse[fs.name];}).length){modifiedDoc=removeFragmentSpreadFromDocument(fragmentSpreadsToRemove,modifiedDoc);}return modifiedDoc;}export var addTypenameToDocument=Object.assign(function(doc){return visit(doc,{SelectionSet:{enter:function enter(node,_key,parent){if(parent&&parent.kind==='OperationDefinition'){return;}var selections=node.selections;if(!selections){return;}var skip=selections.some(function(selection){return isField(selection)&&(selection.name.value==='__typename'||selection.name.value.lastIndexOf('__',0)===0);});if(skip){return;}var field=parent;if(isField(field)&&field.directives&&field.directives.some(function(d){return d.name.value==='export';})){return;}return __assign(__assign({},node),{selections:__spreadArray(__spreadArray([],selections,true),[TYPENAME_FIELD],false)});}}});},{added:function added(field){return field===TYPENAME_FIELD;}});var connectionRemoveConfig={test:function test(directive){var willRemove=directive.name.value==='connection';if(willRemove){if(!directive.arguments||!directive.arguments.some(function(arg){return arg.name.value==='key';})){__DEV__&&invariant.warn('Removing an @connection directive even though it does not have a key. '+'You may want to use the key parameter to specify a store key.');}}return willRemove;}};export function removeConnectionDirectiveFromDocument(doc){return removeDirectivesFromDocument([connectionRemoveConfig],checkDocument(doc));}function hasDirectivesInSelectionSet(directives,selectionSet,nestedCheck){if(nestedCheck===void 0){nestedCheck=true;}return!!selectionSet&&selectionSet.selections&&selectionSet.selections.some(function(selection){return hasDirectivesInSelection(directives,selection,nestedCheck);});}function hasDirectivesInSelection(directives,selection,nestedCheck){if(nestedCheck===void 0){nestedCheck=true;}if(!isField(selection)){return true;}if(!selection.directives){return false;}return selection.directives.some(getDirectiveMatcher(directives))||nestedCheck&&hasDirectivesInSelectionSet(directives,selection.selectionSet,nestedCheck);}function getArgumentMatcher(config){return function argumentMatcher(argument){return config.some(function(aConfig){return argument.value&&argument.value.kind==='Variable'&&argument.value.name&&(aConfig.name===argument.value.name.value||aConfig.test&&aConfig.test(argument));});};}export function removeArgumentsFromDocument(config,doc){var argMatcher=getArgumentMatcher(config);return nullIfDocIsEmpty(visit(doc,{OperationDefinition:{enter:function enter(node){return __assign(__assign({},node),{variableDefinitions:node.variableDefinitions?node.variableDefinitions.filter(function(varDef){return!config.some(function(arg){return arg.name===varDef.variable.name.value;});}):[]});}},Field:{enter:function enter(node){var shouldRemoveField=config.some(function(argConfig){return argConfig.remove;});if(shouldRemoveField){var argMatchCount_1=0;if(node.arguments){node.arguments.forEach(function(arg){if(argMatcher(arg)){argMatchCount_1+=1;}});}if(argMatchCount_1===1){return null;}}}},Argument:{enter:function enter(node){if(argMatcher(node)){return null;}}}}));}export function removeFragmentSpreadFromDocument(config,doc){function enter(node){if(config.some(function(def){return def.name===node.name.value;})){return null;}}return nullIfDocIsEmpty(visit(doc,{FragmentSpread:{enter:enter},FragmentDefinition:{enter:enter}}));}function getAllFragmentSpreadsFromSelectionSet(selectionSet){var allFragments=[];selectionSet.selections.forEach(function(selection){if((isField(selection)||isInlineFragment(selection))&&selection.selectionSet){getAllFragmentSpreadsFromSelectionSet(selection.selectionSet).forEach(function(frag){return allFragments.push(frag);});}else if(selection.kind==='FragmentSpread'){allFragments.push(selection);}});return allFragments;}export function buildQueryFromSelectionSet(document){var definition=getMainDefinition(document);var definitionOperation=definition.operation;if(definitionOperation==='query'){return document;}var modifiedDoc=visit(document,{OperationDefinition:{enter:function enter(node){return __assign(__assign({},node),{operation:'query'});}}});return modifiedDoc;}export function removeClientSetsFromDocument(document){checkDocument(document);var modifiedDoc=removeDirectivesFromDocument([{test:function test(directive){return directive.name.value==='client';},remove:true}],document);if(modifiedDoc){modifiedDoc=visit(modifiedDoc,{FragmentDefinition:{enter:function enter(node){if(node.selectionSet){var isTypenameOnly=node.selectionSet.selections.every(function(selection){return isField(selection)&&selection.name.value==='__typename';});if(isTypenameOnly){return null;}}}}});}return modifiedDoc;}","map":{"version":3,"mappings":"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","names":["invariant","visit","checkDocument","getOperationDefinition","getFragmentDefinition","getFragmentDefinitions","getMainDefinition","filterInPlace","isField","isInlineFragment","createFragmentMap","TYPENAME_FIELD","kind","name","value","isEmpty","op","fragmentMap","selectionSet","selections","every","selection","nullIfDocIsEmpty","doc","getDirectiveMatcher","directives","directiveMatcher","directive","some","dir","test","removeDirectivesFromDocument","variablesInUse","Object","create","variablesToRemove","fragmentSpreadsInUse","fragmentSpreadsToRemove","modifiedDoc","Variable","enter","node","_key","parent","Field","shouldRemoveField","remove","arguments","forEach","arg","push","getAllFragmentSpreadsFromSelectionSet","frag","FragmentSpread","Directive","v","length","removeArgumentsFromDocument","fs","removeFragmentSpreadFromDocument","addTypenameToDocument","assign","SelectionSet","skip","lastIndexOf","field","added","connectionRemoveConfig","willRemove","__DEV__","removeConnectionDirectiveFromDocument","hasDirectivesInSelectionSet","nestedCheck","hasDirectivesInSelection","getArgumentMatcher","config","argumentMatcher","argument","aConfig","argMatcher","OperationDefinition","variableDefinitions","filter","varDef","variable","argMatchCount_1","Argument","FragmentDefinition","allFragments","buildQueryFromSelectionSet","document","definition","definitionOperation","operation","removeClientSetsFromDocument","isTypenameOnly"],"sourceRoot":"","sources":["../../../src/utilities/graphql/transform.ts"],"sourcesContent":["import { invariant } from '../globals';\n\nimport {\n  DocumentNode,\n  SelectionNode,\n  SelectionSetNode,\n  OperationDefinitionNode,\n  FieldNode,\n  DirectiveNode,\n  FragmentDefinitionNode,\n  ArgumentNode,\n  FragmentSpreadNode,\n  VariableDefinitionNode,\n  VariableNode,\n  visit,\n  ASTNode,\n} from 'graphql';\n\n// TODO(brian): A hack until this issue is resolved (https://github.com/graphql/graphql-js/issues/3356)\ntype Kind = any;\n\nimport {\n  checkDocument,\n  getOperationDefinition,\n  getFragmentDefinition,\n  getFragmentDefinitions,\n  getMainDefinition,\n} from './getFromAST';\nimport { filterInPlace } from '../common/filterInPlace';\nimport { isField, isInlineFragment } from './storeUtils';\nimport {\n  createFragmentMap,\n  FragmentMap,\n} from './fragments';\n\nexport type RemoveNodeConfig<N> = {\n  name?: string;\n  test?: (node: N) => boolean;\n  remove?: boolean;\n};\n\nexport type GetNodeConfig<N> = {\n  name?: string;\n  test?: (node: N) => boolean;\n};\n\nexport type RemoveDirectiveConfig = RemoveNodeConfig<DirectiveNode>;\nexport type GetDirectiveConfig = GetNodeConfig<DirectiveNode>;\nexport type RemoveArgumentsConfig = RemoveNodeConfig<ArgumentNode>;\nexport type GetFragmentSpreadConfig = GetNodeConfig<FragmentSpreadNode>;\nexport type RemoveFragmentSpreadConfig = RemoveNodeConfig<FragmentSpreadNode>;\nexport type RemoveFragmentDefinitionConfig = RemoveNodeConfig<\n  FragmentDefinitionNode\n>;\nexport type RemoveVariableDefinitionConfig = RemoveNodeConfig<\n  VariableDefinitionNode\n>;\n\nconst TYPENAME_FIELD: FieldNode = {\n  kind: 'Field' as Kind,\n  name: {\n    kind: 'Name' as Kind,\n    value: '__typename',\n  },\n};\n\nfunction isEmpty(\n  op: OperationDefinitionNode | FragmentDefinitionNode,\n  fragmentMap: FragmentMap,\n): boolean {\n  return !op || op.selectionSet.selections.every(\n    selection => selection.kind === 'FragmentSpread' &&\n      isEmpty(fragmentMap[selection.name.value], fragmentMap)\n  );\n}\n\nfunction nullIfDocIsEmpty(doc: DocumentNode) {\n  return isEmpty(\n    getOperationDefinition(doc) || getFragmentDefinition(doc),\n    createFragmentMap(getFragmentDefinitions(doc)),\n  )\n    ? null\n    : doc;\n}\n\nfunction getDirectiveMatcher(\n  directives: (RemoveDirectiveConfig | GetDirectiveConfig)[],\n) {\n  return function directiveMatcher(directive: DirectiveNode) {\n    return directives.some(\n      dir =>\n        (dir.name && dir.name === directive.name.value) ||\n        (dir.test && dir.test(directive)),\n    );\n  };\n}\n\nexport function removeDirectivesFromDocument(\n  directives: RemoveDirectiveConfig[],\n  doc: DocumentNode,\n): DocumentNode | null {\n  const variablesInUse: Record<string, boolean> = Object.create(null);\n  let variablesToRemove: RemoveArgumentsConfig[] = [];\n\n  const fragmentSpreadsInUse: Record<string, boolean> = Object.create(null);\n  let fragmentSpreadsToRemove: RemoveFragmentSpreadConfig[] = [];\n\n  let modifiedDoc = nullIfDocIsEmpty(\n    visit(doc, {\n      Variable: {\n        enter(node, _key, parent) {\n          // Store each variable that's referenced as part of an argument\n          // (excluding operation definition variables), so we know which\n          // variables are being used. If we later want to remove a variable\n          // we'll first check to see if it's being used, before continuing with\n          // the removal.\n          if (\n            (parent as VariableDefinitionNode).kind !== 'VariableDefinition'\n          ) {\n            variablesInUse[node.name.value] = true;\n          }\n        },\n      },\n\n      Field: {\n        enter(node) {\n          if (directives && node.directives) {\n            // If `remove` is set to true for a directive, and a directive match\n            // is found for a field, remove the field as well.\n            const shouldRemoveField = directives.some(\n              directive => directive.remove,\n            );\n\n            if (\n              shouldRemoveField &&\n              node.directives &&\n              node.directives.some(getDirectiveMatcher(directives))\n            ) {\n              if (node.arguments) {\n                // Store field argument variables so they can be removed\n                // from the operation definition.\n                node.arguments.forEach(arg => {\n                  if (arg.value.kind === 'Variable') {\n                    variablesToRemove.push({\n                      name: (arg.value as VariableNode).name.value,\n                    });\n                  }\n                });\n              }\n\n              if (node.selectionSet) {\n                // Store fragment spread names so they can be removed from the\n                // document.\n                getAllFragmentSpreadsFromSelectionSet(node.selectionSet).forEach(\n                  frag => {\n                    fragmentSpreadsToRemove.push({\n                      name: frag.name.value,\n                    });\n                  },\n                );\n              }\n\n              // Remove the field.\n              return null;\n            }\n          }\n        },\n      },\n\n      FragmentSpread: {\n        enter(node) {\n          // Keep track of referenced fragment spreads. This is used to\n          // determine if top level fragment definitions should be removed.\n          fragmentSpreadsInUse[node.name.value] = true;\n        },\n      },\n\n      Directive: {\n        enter(node) {\n          // If a matching directive is found, remove it.\n          if (getDirectiveMatcher(directives)(node)) {\n            return null;\n          }\n        },\n      },\n    }),\n  );\n\n  // If we've removed fields with arguments, make sure the associated\n  // variables are also removed from the rest of the document, as long as they\n  // aren't being used elsewhere.\n  if (\n    modifiedDoc &&\n    filterInPlace(variablesToRemove, v => !!v.name && !variablesInUse[v.name]).length\n  ) {\n    modifiedDoc = removeArgumentsFromDocument(variablesToRemove, modifiedDoc);\n  }\n\n  // If we've removed selection sets with fragment spreads, make sure the\n  // associated fragment definitions are also removed from the rest of the\n  // document, as long as they aren't being used elsewhere.\n  if (\n    modifiedDoc &&\n    filterInPlace(fragmentSpreadsToRemove, fs => !!fs.name && !fragmentSpreadsInUse[fs.name])\n      .length\n  ) {\n    modifiedDoc = removeFragmentSpreadFromDocument(\n      fragmentSpreadsToRemove,\n      modifiedDoc,\n    );\n  }\n\n  return modifiedDoc;\n}\n\nexport const addTypenameToDocument = Object.assign(function <\n  TNode extends ASTNode\n>(\n  doc: TNode\n): TNode {\n  return visit(doc, {\n    SelectionSet: {\n      enter(node, _key, parent) {\n        // Don't add __typename to OperationDefinitions.\n        if (\n          parent &&\n          (parent as OperationDefinitionNode).kind === 'OperationDefinition'\n        ) {\n          return;\n        }\n\n        // No changes if no selections.\n        const { selections } = node;\n        if (!selections) {\n          return;\n        }\n\n        // If selections already have a __typename, or are part of an\n        // introspection query, do nothing.\n        const skip = selections.some(selection => {\n          return (\n            isField(selection) &&\n            (selection.name.value === '__typename' ||\n              selection.name.value.lastIndexOf('__', 0) === 0)\n          );\n        });\n        if (skip) {\n          return;\n        }\n\n        // If this SelectionSet is @export-ed as an input variable, it should\n        // not have a __typename field (see issue #4691).\n        const field = parent as FieldNode;\n        if (\n          isField(field) &&\n          field.directives &&\n          field.directives.some(d => d.name.value === 'export')\n        ) {\n          return;\n        }\n\n        // Create and return a new SelectionSet with a __typename Field.\n        return {\n          ...node,\n          selections: [...selections, TYPENAME_FIELD],\n        };\n      },\n    },\n  });\n}, {\n  added(field: FieldNode): boolean {\n    return field === TYPENAME_FIELD;\n  },\n});\n\nconst connectionRemoveConfig = {\n  test: (directive: DirectiveNode) => {\n    const willRemove = directive.name.value === 'connection';\n    if (willRemove) {\n      if (\n        !directive.arguments ||\n        !directive.arguments.some(arg => arg.name.value === 'key')\n      ) {\n        invariant.warn(\n          'Removing an @connection directive even though it does not have a key. ' +\n            'You may want to use the key parameter to specify a store key.',\n        );\n      }\n    }\n\n    return willRemove;\n  },\n};\n\nexport function removeConnectionDirectiveFromDocument(doc: DocumentNode) {\n  return removeDirectivesFromDocument(\n    [connectionRemoveConfig],\n    checkDocument(doc),\n  );\n}\n\nfunction hasDirectivesInSelectionSet(\n  directives: GetDirectiveConfig[],\n  selectionSet: SelectionSetNode | undefined,\n  nestedCheck = true,\n): boolean {\n  return (\n    !!selectionSet &&\n    selectionSet.selections &&\n    selectionSet.selections.some(selection =>\n      hasDirectivesInSelection(directives, selection, nestedCheck),\n    )\n  );\n}\n\nfunction hasDirectivesInSelection(\n  directives: GetDirectiveConfig[],\n  selection: SelectionNode,\n  nestedCheck = true,\n): boolean {\n  if (!isField(selection)) {\n    return true;\n  }\n\n  if (!selection.directives) {\n    return false;\n  }\n\n  return (\n    selection.directives.some(getDirectiveMatcher(directives)) ||\n    (nestedCheck &&\n      hasDirectivesInSelectionSet(\n        directives,\n        selection.selectionSet,\n        nestedCheck,\n      ))\n  );\n}\n\nfunction getArgumentMatcher(config: RemoveArgumentsConfig[]) {\n  return function argumentMatcher(argument: ArgumentNode) {\n    return config.some(\n      (aConfig: RemoveArgumentsConfig) =>\n        argument.value &&\n        argument.value.kind === 'Variable' &&\n        argument.value.name &&\n        (aConfig.name === argument.value.name.value ||\n          (aConfig.test && aConfig.test(argument))),\n    );\n  };\n}\n\nexport function removeArgumentsFromDocument(\n  config: RemoveArgumentsConfig[],\n  doc: DocumentNode,\n): DocumentNode | null {\n  const argMatcher = getArgumentMatcher(config);\n\n  return nullIfDocIsEmpty(\n    visit(doc, {\n      OperationDefinition: {\n        enter(node) {\n          return {\n            ...node,\n            // Remove matching top level variables definitions.\n            variableDefinitions: node.variableDefinitions ? node.variableDefinitions.filter(\n              varDef =>\n                !config.some(arg => arg.name === varDef.variable.name.value),\n            ) : [],\n          };\n        },\n      },\n\n      Field: {\n        enter(node) {\n          // If `remove` is set to true for an argument, and an argument match\n          // is found for a field, remove the field as well.\n          const shouldRemoveField = config.some(argConfig => argConfig.remove);\n\n          if (shouldRemoveField) {\n            let argMatchCount = 0;\n            if (node.arguments) {\n              node.arguments.forEach(arg => {\n                if (argMatcher(arg)) {\n                  argMatchCount += 1;\n                }\n              });\n            }\n\n            if (argMatchCount === 1) {\n              return null;\n            }\n          }\n        },\n      },\n\n      Argument: {\n        enter(node) {\n          // Remove all matching arguments.\n          if (argMatcher(node)) {\n            return null;\n          }\n        },\n      },\n    }),\n  );\n}\n\nexport function removeFragmentSpreadFromDocument(\n  config: RemoveFragmentSpreadConfig[],\n  doc: DocumentNode,\n): DocumentNode | null {\n  function enter(\n    node: FragmentSpreadNode | FragmentDefinitionNode,\n  ): null | void {\n    if (config.some(def => def.name === node.name.value)) {\n      return null;\n    }\n  }\n\n  return nullIfDocIsEmpty(\n    visit(doc, {\n      FragmentSpread: { enter },\n      FragmentDefinition: { enter },\n    }),\n  );\n}\n\nfunction getAllFragmentSpreadsFromSelectionSet(\n  selectionSet: SelectionSetNode,\n): FragmentSpreadNode[] {\n  const allFragments: FragmentSpreadNode[] = [];\n\n  selectionSet.selections.forEach(selection => {\n    if (\n      (isField(selection) || isInlineFragment(selection)) &&\n      selection.selectionSet\n    ) {\n      getAllFragmentSpreadsFromSelectionSet(selection.selectionSet).forEach(\n        frag => allFragments.push(frag),\n      );\n    } else if (selection.kind === 'FragmentSpread') {\n      allFragments.push(selection);\n    }\n  });\n\n  return allFragments;\n}\n\n// If the incoming document is a query, return it as is. Otherwise, build a\n// new document containing a query operation based on the selection set\n// of the previous main operation.\nexport function buildQueryFromSelectionSet(\n  document: DocumentNode,\n): DocumentNode {\n  const definition = getMainDefinition(document);\n  const definitionOperation = (<OperationDefinitionNode>definition).operation;\n\n  if (definitionOperation === 'query') {\n    // Already a query, so return the existing document.\n    return document;\n  }\n\n  // Build a new query using the selection set of the main operation.\n  const modifiedDoc = visit(document, {\n    OperationDefinition: {\n      enter(node) {\n        return {\n          ...node,\n          operation: 'query',\n        };\n      },\n    },\n  });\n  return modifiedDoc;\n}\n\n// Remove fields / selection sets that include an @client directive.\nexport function removeClientSetsFromDocument(\n  document: DocumentNode,\n): DocumentNode | null {\n  checkDocument(document);\n\n  let modifiedDoc = removeDirectivesFromDocument(\n    [\n      {\n        test: (directive: DirectiveNode) => directive.name.value === 'client',\n        remove: true,\n      },\n    ],\n    document,\n  );\n\n  // After a fragment definition has had its @client related document\n  // sets removed, if the only field it has left is a __typename field,\n  // remove the entire fragment operation to prevent it from being fired\n  // on the server.\n  if (modifiedDoc) {\n    modifiedDoc = visit(modifiedDoc, {\n      FragmentDefinition: {\n        enter(node) {\n          if (node.selectionSet) {\n            const isTypenameOnly = node.selectionSet.selections.every(\n              selection =>\n                isField(selection) && selection.name.value === '__typename',\n            );\n            if (isTypenameOnly) {\n              return null;\n            }\n          }\n        },\n      },\n    });\n  }\n\n  return modifiedDoc;\n}\n"]},"metadata":{},"sourceType":"module"}