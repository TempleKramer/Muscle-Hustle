{"ast":null,"code":"import{invariant,InvariantError}from\"../globals/index.js\";import{valueToObjectRepresentation}from\"./storeUtils.js\";export function checkDocument(doc){__DEV__?invariant(doc&&doc.kind==='Document',\"Expecting a parsed GraphQL document. Perhaps you need to wrap the query string in a \\\"gql\\\" tag? http://docs.apollostack.com/apollo-client/core.html#gql\"):invariant(doc&&doc.kind==='Document',46);var operations=doc.definitions.filter(function(d){return d.kind!=='FragmentDefinition';}).map(function(definition){if(definition.kind!=='OperationDefinition'){throw __DEV__?new InvariantError(\"Schema type definitions not allowed in queries. Found: \\\"\".concat(definition.kind,\"\\\"\")):new InvariantError(47);}return definition;});__DEV__?invariant(operations.length<=1,\"Ambiguous GraphQL document: contains \".concat(operations.length,\" operations\")):invariant(operations.length<=1,48);return doc;}export function getOperationDefinition(doc){checkDocument(doc);return doc.definitions.filter(function(definition){return definition.kind==='OperationDefinition';})[0];}export function getOperationName(doc){return doc.definitions.filter(function(definition){return definition.kind==='OperationDefinition'&&definition.name;}).map(function(x){return x.name.value;})[0]||null;}export function getFragmentDefinitions(doc){return doc.definitions.filter(function(definition){return definition.kind==='FragmentDefinition';});}export function getQueryDefinition(doc){var queryDef=getOperationDefinition(doc);__DEV__?invariant(queryDef&&queryDef.operation==='query','Must contain a query definition.'):invariant(queryDef&&queryDef.operation==='query',49);return queryDef;}export function getFragmentDefinition(doc){__DEV__?invariant(doc.kind==='Document',\"Expecting a parsed GraphQL document. Perhaps you need to wrap the query string in a \\\"gql\\\" tag? http://docs.apollostack.com/apollo-client/core.html#gql\"):invariant(doc.kind==='Document',50);__DEV__?invariant(doc.definitions.length<=1,'Fragment must have exactly one definition.'):invariant(doc.definitions.length<=1,51);var fragmentDef=doc.definitions[0];__DEV__?invariant(fragmentDef.kind==='FragmentDefinition','Must be a fragment definition.'):invariant(fragmentDef.kind==='FragmentDefinition',52);return fragmentDef;}export function getMainDefinition(queryDoc){checkDocument(queryDoc);var fragmentDefinition;for(var _i=0,_a=queryDoc.definitions;_i<_a.length;_i++){var definition=_a[_i];if(definition.kind==='OperationDefinition'){var operation=definition.operation;if(operation==='query'||operation==='mutation'||operation==='subscription'){return definition;}}if(definition.kind==='FragmentDefinition'&&!fragmentDefinition){fragmentDefinition=definition;}}if(fragmentDefinition){return fragmentDefinition;}throw __DEV__?new InvariantError('Expected a parsed GraphQL query with a query, mutation, subscription, or a fragment.'):new InvariantError(53);}export function getDefaultValues(definition){var defaultValues=Object.create(null);var defs=definition&&definition.variableDefinitions;if(defs&&defs.length){defs.forEach(function(def){if(def.defaultValue){valueToObjectRepresentation(defaultValues,def.variable.name,def.defaultValue);}});}return defaultValues;}","map":{"version":3,"mappings":"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","names":["invariant","InvariantError","valueToObjectRepresentation","checkDocument","doc","__DEV__","operations","definitions","filter","kind","map","definition","concat","length","getOperationDefinition","getOperationName","name","x","value","getFragmentDefinitions","getQueryDefinition","queryDef","getFragmentDefinition","fragmentDef","getMainDefinition","queryDoc","fragmentDefinition","_i","operation","getDefaultValues","defaultValues","Object","create","defs","variableDefinitions","forEach","def","defaultValue","variable"],"sourceRoot":"","sources":["../../../src/utilities/graphql/getFromAST.ts"],"sourcesContent":["import { invariant, InvariantError } from '../globals';\n\nimport {\n  DocumentNode,\n  OperationDefinitionNode,\n  FragmentDefinitionNode,\n  ValueNode,\n} from 'graphql';\n\nimport { valueToObjectRepresentation } from './storeUtils';\n\n// Checks the document for errors and throws an exception if there is an error.\nexport function checkDocument(doc: DocumentNode) {\n  invariant(\n    doc && doc.kind === 'Document',\n    `Expecting a parsed GraphQL document. Perhaps you need to wrap the query \\\nstring in a \"gql\" tag? http://docs.apollostack.com/apollo-client/core.html#gql`,\n  );\n\n  const operations = doc.definitions\n    .filter(d => d.kind !== 'FragmentDefinition')\n    .map(definition => {\n      if (definition.kind !== 'OperationDefinition') {\n        throw new InvariantError(\n          `Schema type definitions not allowed in queries. Found: \"${\n            definition.kind\n          }\"`,\n        );\n      }\n      return definition;\n    });\n\n  invariant(\n    operations.length <= 1,\n    `Ambiguous GraphQL document: contains ${operations.length} operations`,\n  );\n\n  return doc;\n}\n\nexport function getOperationDefinition(\n  doc: DocumentNode,\n): OperationDefinitionNode | undefined {\n  checkDocument(doc);\n  return doc.definitions.filter(\n    definition => definition.kind === 'OperationDefinition',\n  )[0] as OperationDefinitionNode;\n}\n\nexport function getOperationName(doc: DocumentNode): string | null {\n  return (\n    doc.definitions\n      .filter(\n        definition =>\n          definition.kind === 'OperationDefinition' && definition.name,\n      )\n      .map((x: OperationDefinitionNode) => x!.name!.value)[0] || null\n  );\n}\n\n// Returns the FragmentDefinitions from a particular document as an array\nexport function getFragmentDefinitions(\n  doc: DocumentNode,\n): FragmentDefinitionNode[] {\n  return doc.definitions.filter(\n    definition => definition.kind === 'FragmentDefinition',\n  ) as FragmentDefinitionNode[];\n}\n\nexport function getQueryDefinition(doc: DocumentNode): OperationDefinitionNode {\n  const queryDef = getOperationDefinition(doc) as OperationDefinitionNode;\n\n  invariant(\n    queryDef && queryDef.operation === 'query',\n    'Must contain a query definition.',\n  );\n\n  return queryDef;\n}\n\nexport function getFragmentDefinition(\n  doc: DocumentNode,\n): FragmentDefinitionNode {\n  invariant(\n    doc.kind === 'Document',\n    `Expecting a parsed GraphQL document. Perhaps you need to wrap the query \\\nstring in a \"gql\" tag? http://docs.apollostack.com/apollo-client/core.html#gql`,\n  );\n\n  invariant(\n    doc.definitions.length <= 1,\n    'Fragment must have exactly one definition.',\n  );\n\n  const fragmentDef = doc.definitions[0] as FragmentDefinitionNode;\n\n  invariant(\n    fragmentDef.kind === 'FragmentDefinition',\n    'Must be a fragment definition.',\n  );\n\n  return fragmentDef as FragmentDefinitionNode;\n}\n\n/**\n * Returns the first operation definition found in this document.\n * If no operation definition is found, the first fragment definition will be returned.\n * If no definitions are found, an error will be thrown.\n */\nexport function getMainDefinition(\n  queryDoc: DocumentNode,\n): OperationDefinitionNode | FragmentDefinitionNode {\n  checkDocument(queryDoc);\n\n  let fragmentDefinition;\n\n  for (let definition of queryDoc.definitions) {\n    if (definition.kind === 'OperationDefinition') {\n      const operation = (definition as OperationDefinitionNode).operation;\n      if (\n        operation === 'query' ||\n        operation === 'mutation' ||\n        operation === 'subscription'\n      ) {\n        return definition as OperationDefinitionNode;\n      }\n    }\n    if (definition.kind === 'FragmentDefinition' && !fragmentDefinition) {\n      // we do this because we want to allow multiple fragment definitions\n      // to precede an operation definition.\n      fragmentDefinition = definition as FragmentDefinitionNode;\n    }\n  }\n\n  if (fragmentDefinition) {\n    return fragmentDefinition;\n  }\n\n  throw new InvariantError(\n    'Expected a parsed GraphQL query with a query, mutation, subscription, or a fragment.',\n  );\n}\n\nexport function getDefaultValues(\n  definition: OperationDefinitionNode | undefined,\n): Record<string, any> {\n  const defaultValues = Object.create(null);\n  const defs = definition && definition.variableDefinitions;\n  if (defs && defs.length) {\n    defs.forEach(def => {\n      if (def.defaultValue) {\n        valueToObjectRepresentation(\n          defaultValues,\n          def.variable.name,\n          def.defaultValue as ValueNode,\n        );\n      }\n    });\n  }\n  return defaultValues;\n}\n"]},"metadata":{},"sourceType":"module"}