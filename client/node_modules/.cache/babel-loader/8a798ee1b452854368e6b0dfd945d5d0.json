{"ast":null,"code":"import{invariant}from\"../globals/index.js\";import{visit,BREAK}from'graphql';export function shouldInclude(_a,variables){var directives=_a.directives;if(!directives||!directives.length){return true;}return getInclusionDirectives(directives).every(function(_a){var directive=_a.directive,ifArgument=_a.ifArgument;var evaledValue=false;if(ifArgument.value.kind==='Variable'){evaledValue=variables&&variables[ifArgument.value.name.value];__DEV__?invariant(evaledValue!==void 0,\"Invalid variable referenced in @\".concat(directive.name.value,\" directive.\")):invariant(evaledValue!==void 0,39);}else{evaledValue=ifArgument.value.value;}return directive.name.value==='skip'?!evaledValue:evaledValue;});}export function getDirectiveNames(root){var names=[];visit(root,{Directive:function Directive(node){names.push(node.name.value);}});return names;}export var hasAnyDirectives=function hasAnyDirectives(names,root){return hasDirectives(names,root,false);};export var hasAllDirectives=function hasAllDirectives(names,root){return hasDirectives(names,root,true);};export function hasDirectives(names,root,all){var nameSet=new Set(names);var uniqueCount=nameSet.size;visit(root,{Directive:function Directive(node){if(nameSet.delete(node.name.value)&&(!all||!nameSet.size)){return BREAK;}}});return all?!nameSet.size:nameSet.size<uniqueCount;}export function hasClientExports(document){return document&&hasDirectives(['client','export'],document,true);}function isInclusionDirective(_a){var value=_a.name.value;return value==='skip'||value==='include';}export function getInclusionDirectives(directives){var result=[];if(directives&&directives.length){directives.forEach(function(directive){if(!isInclusionDirective(directive))return;var directiveArguments=directive.arguments;var directiveName=directive.name.value;__DEV__?invariant(directiveArguments&&directiveArguments.length===1,\"Incorrect number of arguments for the @\".concat(directiveName,\" directive.\")):invariant(directiveArguments&&directiveArguments.length===1,40);var ifArgument=directiveArguments[0];__DEV__?invariant(ifArgument.name&&ifArgument.name.value==='if',\"Invalid argument for the @\".concat(directiveName,\" directive.\")):invariant(ifArgument.name&&ifArgument.name.value==='if',41);var ifValue=ifArgument.value;__DEV__?invariant(ifValue&&(ifValue.kind==='Variable'||ifValue.kind==='BooleanValue'),\"Argument for the @\".concat(directiveName,\" directive must be a variable or a boolean value.\")):invariant(ifValue&&(ifValue.kind==='Variable'||ifValue.kind==='BooleanValue'),42);result.push({directive:directive,ifArgument:ifArgument});});}return result;}","map":{"version":3,"mappings":"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","names":["invariant","visit","BREAK","shouldInclude","_a","variables","directives","length","getInclusionDirectives","every","directive","ifArgument","evaledValue","value","kind","name","__DEV__","concat","getDirectiveNames","root","names","Directive","node","push","hasAnyDirectives","hasAllDirectives","hasDirectives","all","nameSet","Set","uniqueCount","size","delete","hasClientExports","document","isInclusionDirective","result","forEach","directiveArguments","arguments","directiveName","ifValue"],"sourceRoot":"","sources":["../../../src/utilities/graphql/directives.ts"],"sourcesContent":["import { invariant } from '../globals';\n\n// Provides the methods that allow QueryManager to handle the `skip` and\n// `include` directives within GraphQL.\nimport {\n  SelectionNode,\n  VariableNode,\n  BooleanValueNode,\n  DirectiveNode,\n  DocumentNode,\n  ArgumentNode,\n  ValueNode,\n  ASTNode,\n  visit,\n  BREAK,\n} from 'graphql';\n\nexport type DirectiveInfo = {\n  [fieldName: string]: { [argName: string]: any };\n};\n\nexport function shouldInclude(\n  { directives }: SelectionNode,\n  variables?: Record<string, any>,\n): boolean {\n  if (!directives || !directives.length) {\n    return true;\n  }\n  return getInclusionDirectives(\n    directives\n  ).every(({ directive, ifArgument }) => {\n    let evaledValue: boolean = false;\n    if (ifArgument.value.kind === 'Variable') {\n      evaledValue = variables && variables[(ifArgument.value as VariableNode).name.value];\n      invariant(\n        evaledValue !== void 0,\n        `Invalid variable referenced in @${directive.name.value} directive.`,\n      );\n    } else {\n      evaledValue = (ifArgument.value as BooleanValueNode).value;\n    }\n    return directive.name.value === 'skip' ? !evaledValue : evaledValue;\n  });\n}\n\nexport function getDirectiveNames(root: ASTNode) {\n  const names: string[] = [];\n\n  visit(root, {\n    Directive(node: DirectiveNode) {\n      names.push(node.name.value);\n    },\n  });\n\n  return names;\n}\n\nexport const hasAnyDirectives = (\n  names: string[],\n  root: ASTNode,\n) => hasDirectives(names, root, false);\n\nexport const hasAllDirectives = (\n  names: string[],\n  root: ASTNode,\n) => hasDirectives(names, root, true);\n\nexport function hasDirectives(\n  names: string[],\n  root: ASTNode,\n  all?: boolean,\n) {\n  const nameSet = new Set(names);\n  const uniqueCount = nameSet.size;\n\n  visit(root, {\n    Directive(node) {\n      if (\n        nameSet.delete(node.name.value) &&\n        (!all || !nameSet.size)\n      ) {\n        return BREAK;\n      }\n    },\n  });\n\n  // If we found all the names, nameSet will be empty. If we only care about\n  // finding some of them, the < condition is sufficient.\n  return all ? !nameSet.size : nameSet.size < uniqueCount;\n}\n\nexport function hasClientExports(document: DocumentNode) {\n  return document && hasDirectives(['client', 'export'], document, true);\n}\n\nexport type InclusionDirectives = Array<{\n  directive: DirectiveNode;\n  ifArgument: ArgumentNode;\n}>;\n\nfunction isInclusionDirective({ name: { value } }: DirectiveNode): boolean {\n  return value === 'skip' || value === 'include';\n}\n\nexport function getInclusionDirectives(\n  directives: ReadonlyArray<DirectiveNode>,\n): InclusionDirectives {\n  const result: InclusionDirectives = [];\n\n  if (directives && directives.length) {\n    directives.forEach(directive => {\n      if (!isInclusionDirective(directive)) return;\n\n      const directiveArguments = directive.arguments;\n      const directiveName = directive.name.value;\n\n      invariant(\n        directiveArguments && directiveArguments.length === 1,\n        `Incorrect number of arguments for the @${directiveName} directive.`,\n      );\n\n      const ifArgument = directiveArguments![0];\n      invariant(\n        ifArgument.name && ifArgument.name.value === 'if',\n        `Invalid argument for the @${directiveName} directive.`,\n      );\n\n      const ifValue: ValueNode = ifArgument.value;\n\n      // means it has to be a variable value if this is a valid @skip or @include directive\n      invariant(\n        ifValue &&\n          (ifValue.kind === 'Variable' || ifValue.kind === 'BooleanValue'),\n        `Argument for the @${directiveName} directive must be a variable or a boolean value.`,\n      );\n\n      result.push({ directive, ifArgument });\n    });\n  }\n\n  return result;\n}\n\n"]},"metadata":{},"sourceType":"module"}