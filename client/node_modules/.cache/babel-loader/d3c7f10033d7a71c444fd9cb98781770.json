{"ast":null,"code":"import{__assign,__rest}from\"tslib\";import{invariant}from\"../../utilities/globals/index.js\";import{useCallback,useContext,useMemo,useRef,useState}from'react';import{useSyncExternalStore}from\"./useSyncExternalStore.js\";import{equal}from'@wry/equality';import{mergeOptions}from\"../../core/index.js\";import{getApolloContext}from\"../context/index.js\";import{ApolloError}from\"../../errors/index.js\";import{NetworkStatus}from\"../../core/index.js\";import{DocumentType,verifyDocumentType}from\"../parser/index.js\";import{useApolloClient}from\"./useApolloClient.js\";import{canUseWeakMap,canUseWeakSet,compact,isNonEmptyArray,maybeDeepFreeze}from\"../../utilities/index.js\";var hasOwnProperty=Object.prototype.hasOwnProperty;export function useQuery(query,options){if(options===void 0){options=Object.create(null);}return useInternalState(useApolloClient(options.client),query).useQuery(options);}export function useInternalState(client,query){var stateRef=useRef();if(!stateRef.current||client!==stateRef.current.client||query!==stateRef.current.query){stateRef.current=new InternalState(client,query,stateRef.current);}var state=stateRef.current;var _a=useState(0),_tick=_a[0],setTick=_a[1];state.forceUpdate=function(){setTick(function(tick){return tick+1;});};return state;}var InternalState=function(){function InternalState(client,query,previous){this.client=client;this.query=query;this.asyncResolveFns=new Set();this.optionsToIgnoreOnce=new(canUseWeakSet?WeakSet:Set)();this.ssrDisabledResult=maybeDeepFreeze({loading:true,data:void 0,error:void 0,networkStatus:NetworkStatus.loading});this.skipStandbyResult=maybeDeepFreeze({loading:false,data:void 0,error:void 0,networkStatus:NetworkStatus.ready});this.toQueryResultCache=new(canUseWeakMap?WeakMap:Map)();verifyDocumentType(query,DocumentType.Query);var previousResult=previous&&previous.result;var previousData=previousResult&&previousResult.data;if(previousData){this.previousData=previousData;}}InternalState.prototype.forceUpdate=function(){__DEV__&&invariant.warn(\"Calling default no-op implementation of InternalState#forceUpdate\");};InternalState.prototype.asyncUpdate=function(){var _this=this;return new Promise(function(resolve){_this.asyncResolveFns.add(resolve);_this.optionsToIgnoreOnce.add(_this.watchQueryOptions);_this.forceUpdate();});};InternalState.prototype.useQuery=function(options){var _this=this;this.renderPromises=useContext(getApolloContext()).renderPromises;this.useOptions(options);var obsQuery=this.useObservableQuery();var result=useSyncExternalStore(useCallback(function(){if(_this.renderPromises){return function(){};}var onNext=function onNext(){var previousResult=_this.result;var result=obsQuery.getCurrentResult();if(previousResult&&previousResult.loading===result.loading&&previousResult.networkStatus===result.networkStatus&&equal(previousResult.data,result.data)){return;}_this.setResult(result);};var onError=function onError(error){var last=obsQuery[\"last\"];subscription.unsubscribe();try{obsQuery.resetLastResults();subscription=obsQuery.subscribe(onNext,onError);}finally{obsQuery[\"last\"]=last;}if(!hasOwnProperty.call(error,'graphQLErrors')){throw error;}var previousResult=_this.result;if(!previousResult||previousResult&&previousResult.loading||!equal(error,previousResult.error)){_this.setResult({data:previousResult&&previousResult.data,error:error,loading:false,networkStatus:NetworkStatus.error});}};var subscription=obsQuery.subscribe(onNext,onError);return function(){return subscription.unsubscribe();};},[obsQuery,this.renderPromises,this.client.disableNetworkFetches]),function(){return _this.getCurrentResult();},function(){return _this.getCurrentResult();});this.unsafeHandlePartialRefetch(result);var queryResult=this.toQueryResult(result);if(!queryResult.loading&&this.asyncResolveFns.size){this.asyncResolveFns.forEach(function(resolve){return resolve(queryResult);});this.asyncResolveFns.clear();}return queryResult;};InternalState.prototype.useOptions=function(options){var _a;var watchQueryOptions=this.createWatchQueryOptions(this.queryHookOptions=options);var currentWatchQueryOptions=this.watchQueryOptions;if(this.optionsToIgnoreOnce.has(currentWatchQueryOptions)||!equal(watchQueryOptions,currentWatchQueryOptions)){this.watchQueryOptions=watchQueryOptions;if(currentWatchQueryOptions&&this.observable){this.optionsToIgnoreOnce.delete(currentWatchQueryOptions);this.observable.reobserve(this.getObsQueryOptions());this.previousData=((_a=this.result)===null||_a===void 0?void 0:_a.data)||this.previousData;this.result=void 0;}}this.onCompleted=options.onCompleted||InternalState.prototype.onCompleted;this.onError=options.onError||InternalState.prototype.onError;if((this.renderPromises||this.client.disableNetworkFetches)&&this.queryHookOptions.ssr===false&&!this.queryHookOptions.skip){this.result=this.ssrDisabledResult;}else if(this.queryHookOptions.skip||this.watchQueryOptions.fetchPolicy==='standby'){this.result=this.skipStandbyResult;}else if(this.result===this.ssrDisabledResult||this.result===this.skipStandbyResult){this.result=void 0;}};InternalState.prototype.getObsQueryOptions=function(){var toMerge=[];var globalDefaults=this.client.defaultOptions.watchQuery;if(globalDefaults)toMerge.push(globalDefaults);if(this.queryHookOptions.defaultOptions){toMerge.push(this.queryHookOptions.defaultOptions);}toMerge.push(compact(this.observable&&this.observable.options,this.watchQueryOptions));return toMerge.reduce(mergeOptions);};InternalState.prototype.createWatchQueryOptions=function(_a){var _b;if(_a===void 0){_a={};}var skip=_a.skip,ssr=_a.ssr,onCompleted=_a.onCompleted,onError=_a.onError,defaultOptions=_a.defaultOptions,otherOptions=__rest(_a,[\"skip\",\"ssr\",\"onCompleted\",\"onError\",\"defaultOptions\"]);var watchQueryOptions=Object.assign(otherOptions,{query:this.query});if(this.renderPromises&&(watchQueryOptions.fetchPolicy==='network-only'||watchQueryOptions.fetchPolicy==='cache-and-network')){watchQueryOptions.fetchPolicy='cache-first';}if(!watchQueryOptions.variables){watchQueryOptions.variables={};}if(skip){var _c=watchQueryOptions.fetchPolicy,fetchPolicy=_c===void 0?this.getDefaultFetchPolicy():_c,_d=watchQueryOptions.initialFetchPolicy,initialFetchPolicy=_d===void 0?fetchPolicy:_d;Object.assign(watchQueryOptions,{initialFetchPolicy:initialFetchPolicy,fetchPolicy:'standby'});}else if(!watchQueryOptions.fetchPolicy){watchQueryOptions.fetchPolicy=((_b=this.observable)===null||_b===void 0?void 0:_b.options.initialFetchPolicy)||this.getDefaultFetchPolicy();}return watchQueryOptions;};InternalState.prototype.getDefaultFetchPolicy=function(){var _a,_b;return((_a=this.queryHookOptions.defaultOptions)===null||_a===void 0?void 0:_a.fetchPolicy)||((_b=this.client.defaultOptions.watchQuery)===null||_b===void 0?void 0:_b.fetchPolicy)||\"cache-first\";};InternalState.prototype.onCompleted=function(data){};InternalState.prototype.onError=function(error){};InternalState.prototype.useObservableQuery=function(){var obsQuery=this.observable=this.renderPromises&&this.renderPromises.getSSRObservable(this.watchQueryOptions)||this.observable||this.client.watchQuery(this.getObsQueryOptions());this.obsQueryFields=useMemo(function(){return{refetch:obsQuery.refetch.bind(obsQuery),reobserve:obsQuery.reobserve.bind(obsQuery),fetchMore:obsQuery.fetchMore.bind(obsQuery),updateQuery:obsQuery.updateQuery.bind(obsQuery),startPolling:obsQuery.startPolling.bind(obsQuery),stopPolling:obsQuery.stopPolling.bind(obsQuery),subscribeToMore:obsQuery.subscribeToMore.bind(obsQuery)};},[obsQuery]);var ssrAllowed=!(this.queryHookOptions.ssr===false||this.queryHookOptions.skip);if(this.renderPromises&&ssrAllowed){this.renderPromises.registerSSRObservable(obsQuery);if(obsQuery.getCurrentResult().loading){this.renderPromises.addObservableQueryPromise(obsQuery);}}return obsQuery;};InternalState.prototype.setResult=function(nextResult){var previousResult=this.result;if(previousResult&&previousResult.data){this.previousData=previousResult.data;}this.result=nextResult;this.forceUpdate();this.handleErrorOrCompleted(nextResult);};InternalState.prototype.handleErrorOrCompleted=function(result){var _this=this;if(!result.loading){Promise.resolve().then(function(){if(result.error){_this.onError(result.error);}else if(result.data){_this.onCompleted(result.data);}}).catch(function(error){__DEV__&&invariant.warn(error);});}};InternalState.prototype.getCurrentResult=function(){if(!this.result){this.handleErrorOrCompleted(this.result=this.observable.getCurrentResult());}return this.result;};InternalState.prototype.toQueryResult=function(result){var queryResult=this.toQueryResultCache.get(result);if(queryResult)return queryResult;var data=result.data,partial=result.partial,resultWithoutPartial=__rest(result,[\"data\",\"partial\"]);this.toQueryResultCache.set(result,queryResult=__assign(__assign(__assign({data:data},resultWithoutPartial),this.obsQueryFields),{client:this.client,observable:this.observable,variables:this.observable.variables,called:!this.queryHookOptions.skip,previousData:this.previousData}));if(!queryResult.error&&isNonEmptyArray(result.errors)){queryResult.error=new ApolloError({graphQLErrors:result.errors});}return queryResult;};InternalState.prototype.unsafeHandlePartialRefetch=function(result){if(result.partial&&this.queryHookOptions.partialRefetch&&!result.loading&&(!result.data||Object.keys(result.data).length===0)&&this.observable.options.fetchPolicy!=='cache-only'){Object.assign(result,{loading:true,networkStatus:NetworkStatus.refetch});this.observable.refetch();}};return InternalState;}();","map":{"version":3,"mappings":"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","names":["invariant","useCallback","useContext","useMemo","useRef","useState","useSyncExternalStore","equal","mergeOptions","getApolloContext","ApolloError","NetworkStatus","DocumentType","verifyDocumentType","useApolloClient","canUseWeakMap","canUseWeakSet","compact","isNonEmptyArray","maybeDeepFreeze","Object","hasOwnProperty","useQuery","query","options","create","useInternalState","client","stateRef","current","InternalState","state","_tick","setTick","forceUpdate","previous","Set","WeakSet","loading","data","error","networkStatus","ready","WeakMap","Map","Query","previousResult","result","previousData","__DEV__","Promise","_this","asyncResolveFns","add","resolve","optionsToIgnoreOnce","watchQueryOptions","renderPromises","useOptions","obsQuery","useObservableQuery","onNext","getCurrentResult","setResult","onError","last","subscription","unsubscribe","resetLastResults","subscribe","call","disableNetworkFetches","unsafeHandlePartialRefetch","queryResult","toQueryResult","size","forEach","clear","createWatchQueryOptions","queryHookOptions","currentWatchQueryOptions","has","observable","delete","reobserve","getObsQueryOptions","_a","onCompleted","prototype","ssr","skip","ssrDisabledResult","fetchPolicy","skipStandbyResult","toMerge","globalDefaults","defaultOptions","watchQuery","push","reduce","otherOptions","assign","variables","getDefaultFetchPolicy","_c","_d","initialFetchPolicy","_b","getSSRObservable","obsQueryFields","refetch","bind","fetchMore","updateQuery","startPolling","stopPolling","subscribeToMore","ssrAllowed","registerSSRObservable","addObservableQueryPromise","nextResult","handleErrorOrCompleted","then","catch","warn","toQueryResultCache","get","partial","resultWithoutPartial","set","called","errors","graphQLErrors","partialRefetch","keys","length"],"sourceRoot":"","sources":["../../../src/react/hooks/useQuery.ts"],"sourcesContent":["import { invariant } from '../../utilities/globals';\n\nimport {\n  useCallback,\n  useContext,\n  useMemo,\n  useRef,\n  useState,\n} from 'react';\nimport { useSyncExternalStore } from './useSyncExternalStore';\nimport { equal } from '@wry/equality';\n\nimport { mergeOptions, OperationVariables, WatchQueryFetchPolicy } from '../../core';\nimport { ApolloContextValue, getApolloContext } from '../context';\nimport { ApolloError } from '../../errors';\nimport {\n  ApolloClient,\n  ApolloQueryResult,\n  NetworkStatus,\n  ObservableQuery,\n  DocumentNode,\n  TypedDocumentNode,\n  WatchQueryOptions,\n} from '../../core';\nimport {\n  QueryHookOptions,\n  QueryResult,\n  ObservableQueryFields,\n} from '../types/types';\n\nimport { DocumentType, verifyDocumentType } from '../parser';\nimport { useApolloClient } from './useApolloClient';\nimport { canUseWeakMap, canUseWeakSet, compact, isNonEmptyArray, maybeDeepFreeze } from '../../utilities';\n\nconst {\n  prototype: {\n    hasOwnProperty,\n  },\n} = Object;\n\nexport function useQuery<\n  TData = any,\n  TVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: QueryHookOptions<TData, TVariables> = Object.create(null),\n): QueryResult<TData, TVariables> {\n  return useInternalState(\n    useApolloClient(options.client),\n    query,\n  ).useQuery(options);\n}\n\nexport function useInternalState<TData, TVariables>(\n  client: ApolloClient<any>,\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n): InternalState<TData, TVariables> {\n  const stateRef = useRef<InternalState<TData, TVariables>>();\n  if (\n    !stateRef.current ||\n    client !== stateRef.current.client ||\n    query !== stateRef.current.query\n  ) {\n    stateRef.current = new InternalState(client, query, stateRef.current);\n  }\n  const state = stateRef.current;\n\n  // By default, InternalState.prototype.forceUpdate is an empty function, but\n  // we replace it here (before anyone has had a chance to see this state yet)\n  // with a function that unconditionally forces an update, using the latest\n  // setTick function. Updating this state by calling state.forceUpdate is the\n  // only way we trigger React component updates (no other useState calls within\n  // the InternalState class).\n  const [_tick, setTick] = useState(0);\n  state.forceUpdate = () => {\n    setTick(tick => tick + 1);\n  };\n\n  return state;\n}\n\nclass InternalState<TData, TVariables> {\n  constructor(\n    public readonly client: ReturnType<typeof useApolloClient>,\n    public readonly query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n    previous?: InternalState<TData, TVariables>,\n  ) {\n    verifyDocumentType(query, DocumentType.Query);\n\n    // Reuse previousData from previous InternalState (if any) to provide\n    // continuity of previousData even if/when the query or client changes.\n    const previousResult = previous && previous.result;\n    const previousData = previousResult && previousResult.data;\n    if (previousData) {\n      this.previousData = previousData;\n    }\n  }\n\n  forceUpdate() {\n    // Replaced (in useInternalState) with a method that triggers an update.\n    invariant.warn(\"Calling default no-op implementation of InternalState#forceUpdate\");\n  }\n\n  asyncUpdate() {\n    return new Promise<QueryResult<TData, TVariables>>(resolve => {\n      this.asyncResolveFns.add(resolve);\n      this.optionsToIgnoreOnce.add(this.watchQueryOptions);\n      this.forceUpdate();\n    });\n  }\n\n  private asyncResolveFns = new Set<\n    (result: QueryResult<TData, TVariables>) => void\n  >();\n\n  private optionsToIgnoreOnce = new (canUseWeakSet ? WeakSet : Set)<\n    WatchQueryOptions<TVariables, TData>\n  >();\n\n  // Methods beginning with use- should be called according to the standard\n  // rules of React hooks: only at the top level of the calling function, and\n  // without any dynamic conditional logic.\n  useQuery(options: QueryHookOptions<TData, TVariables>) {\n    // The renderPromises field gets initialized here in the useQuery method, at\n    // the beginning of everything (for a given component rendering, at least),\n    // so we can safely use this.renderPromises in other/later InternalState\n    // methods without worrying it might be uninitialized. Even after\n    // initialization, this.renderPromises is usually undefined (unless SSR is\n    // happening), but that's fine as long as it has been initialized that way,\n    // rather than left uninitialized.\n    this.renderPromises = useContext(getApolloContext()).renderPromises;\n\n    this.useOptions(options);\n\n    const obsQuery = this.useObservableQuery();\n\n    const result = useSyncExternalStore(\n      useCallback(() => {\n        if (this.renderPromises) {\n          return () => {};\n        }\n\n        const onNext = () => {\n          const previousResult = this.result;\n          // We use `getCurrentResult()` instead of the onNext argument because\n          // the values differ slightly. Specifically, loading results will have\n          // an empty object for data instead of `undefined` for some reason.\n          const result = obsQuery.getCurrentResult();\n          // Make sure we're not attempting to re-render similar results\n          if (\n            previousResult &&\n            previousResult.loading === result.loading &&\n            previousResult.networkStatus === result.networkStatus &&\n            equal(previousResult.data, result.data)\n          ) {\n            return;\n          }\n\n          this.setResult(result);\n        };\n\n        const onError = (error: Error) => {\n          const last = obsQuery[\"last\"];\n          subscription.unsubscribe();\n          // Unfortunately, if `lastError` is set in the current\n          // `observableQuery` when the subscription is re-created,\n          // the subscription will immediately receive the error, which will\n          // cause it to terminate again. To avoid this, we first clear\n          // the last error/result from the `observableQuery` before re-starting\n          // the subscription, and restore it afterwards (so the subscription\n          // has a chance to stay open).\n          try {\n            obsQuery.resetLastResults();\n            subscription = obsQuery.subscribe(onNext, onError);\n          } finally {\n            obsQuery[\"last\"] = last;\n          }\n\n          if (!hasOwnProperty.call(error, 'graphQLErrors')) {\n            // The error is not a GraphQL error\n            throw error;\n          }\n\n          const previousResult = this.result;\n          if (\n            !previousResult ||\n            (previousResult && previousResult.loading) ||\n            !equal(error, previousResult.error)\n          ) {\n            this.setResult({\n              data: (previousResult && previousResult.data) as TData,\n              error: error as ApolloError,\n              loading: false,\n              networkStatus: NetworkStatus.error,\n            });\n          }\n        };\n\n        let subscription = obsQuery.subscribe(onNext, onError);\n\n        return () => subscription.unsubscribe();\n      }, [\n        // We memoize the subscribe function using useCallback and the following\n        // dependency keys, because the subscribe function reference is all that\n        // useSyncExternalStore uses internally as a dependency key for the\n        // useEffect ultimately responsible for the subscription, so we are\n        // effectively passing this dependency array to that useEffect buried\n        // inside useSyncExternalStore, as desired.\n        obsQuery,\n        this.renderPromises,\n        this.client.disableNetworkFetches,\n      ]),\n\n      () => this.getCurrentResult(),\n      () => this.getCurrentResult(),\n    );\n\n    // TODO Remove this method when we remove support for options.partialRefetch.\n    this.unsafeHandlePartialRefetch(result);\n\n    const queryResult = this.toQueryResult(result);\n\n    if (!queryResult.loading && this.asyncResolveFns.size) {\n      this.asyncResolveFns.forEach(resolve => resolve(queryResult));\n      this.asyncResolveFns.clear();\n    }\n\n    return queryResult;\n  }\n\n  // These members (except for renderPromises) are all populated by the\n  // useOptions method, which is called unconditionally at the beginning of the\n  // useQuery method, so we can safely use these members in other/later methods\n  // without worrying they might be uninitialized.\n  private renderPromises: ApolloContextValue[\"renderPromises\"];\n  private queryHookOptions: QueryHookOptions<TData, TVariables>;\n  private watchQueryOptions: WatchQueryOptions<TVariables, TData>;\n\n  private useOptions(\n    options: QueryHookOptions<TData, TVariables>,\n  ) {\n    const watchQueryOptions = this.createWatchQueryOptions(\n      this.queryHookOptions = options,\n    );\n\n    // Update this.watchQueryOptions, but only when they have changed, which\n    // allows us to depend on the referential stability of\n    // this.watchQueryOptions elsewhere.\n    const currentWatchQueryOptions = this.watchQueryOptions;\n\n    // To force this equality test to \"fail,\" thereby reliably triggering\n    // observable.reobserve, add any current WatchQueryOptions object(s) you\n    // want to be ignored to this.optionsToIgnoreOnce. A similar effect could be\n    // achieved by nullifying this.watchQueryOptions so the equality test\n    // immediately fails because currentWatchQueryOptions is null, but this way\n    // we can promise a truthy this.watchQueryOptions at all times.\n    if (\n      this.optionsToIgnoreOnce.has(currentWatchQueryOptions) ||\n      !equal(watchQueryOptions, currentWatchQueryOptions)\n    ) {\n      this.watchQueryOptions = watchQueryOptions;\n\n      if (currentWatchQueryOptions && this.observable) {\n        // As advertised in the -Once of this.optionsToIgnoreOnce, this trick is\n        // only good for one forced execution of observable.reobserve per\n        // ignored WatchQueryOptions object, though it is unlikely we will ever\n        // see this exact currentWatchQueryOptions object again here, since we\n        // just replaced this.watchQueryOptions with watchQueryOptions.\n        this.optionsToIgnoreOnce.delete(currentWatchQueryOptions);\n\n        // Though it might be tempting to postpone this reobserve call to the\n        // useEffect block, we need getCurrentResult to return an appropriate\n        // loading:true result synchronously (later within the same call to\n        // useQuery). Since we already have this.observable here (not true for\n        // the very first call to useQuery), we are not initiating any new\n        // subscriptions, though it does feel less than ideal that reobserve\n        // (potentially) kicks off a network request (for example, when the\n        // variables have changed), which is technically a side-effect.\n        this.observable.reobserve(this.getObsQueryOptions());\n\n        // Make sure getCurrentResult returns a fresh ApolloQueryResult<TData>,\n        // but save the current data as this.previousData, just like setResult\n        // usually does.\n        this.previousData = this.result?.data || this.previousData;\n        this.result = void 0;\n      }\n    }\n\n    // Make sure state.onCompleted and state.onError always reflect the latest\n    // options.onCompleted and options.onError callbacks provided to useQuery,\n    // since those functions are often recreated every time useQuery is called.\n    // Like the forceUpdate method, the versions of these methods inherited from\n    // InternalState.prototype are empty no-ops, but we can override them on the\n    // base state object (without modifying the prototype).\n    this.onCompleted = options.onCompleted || InternalState.prototype.onCompleted;\n    this.onError = options.onError || InternalState.prototype.onError;\n\n    if (\n      (this.renderPromises || this.client.disableNetworkFetches) &&\n      this.queryHookOptions.ssr === false &&\n      !this.queryHookOptions.skip\n    ) {\n      // If SSR has been explicitly disabled, and this function has been called\n      // on the server side, return the default loading state.\n      this.result = this.ssrDisabledResult;\n    } else if (\n      this.queryHookOptions.skip ||\n      this.watchQueryOptions.fetchPolicy === 'standby'\n    ) {\n      // When skipping a query (ie. we're not querying for data but still want to\n      // render children), make sure the `data` is cleared out and `loading` is\n      // set to `false` (since we aren't loading anything).\n      //\n      // NOTE: We no longer think this is the correct behavior. Skipping should\n      // not automatically set `data` to `undefined`, but instead leave the\n      // previous data in place. In other words, skipping should not mandate that\n      // previously received data is all of a sudden removed. Unfortunately,\n      // changing this is breaking, so we'll have to wait until Apollo Client 4.0\n      // to address this.\n      this.result = this.skipStandbyResult;\n    } else if (\n      this.result === this.ssrDisabledResult ||\n      this.result === this.skipStandbyResult\n    ) {\n      this.result = void 0;\n    }\n  }\n\n  private getObsQueryOptions(): WatchQueryOptions<TVariables, TData> {\n    const toMerge: Array<\n      Partial<WatchQueryOptions<TVariables, TData>>\n    > = [];\n\n    const globalDefaults = this.client.defaultOptions.watchQuery;\n    if (globalDefaults) toMerge.push(globalDefaults);\n\n    if (this.queryHookOptions.defaultOptions) {\n      toMerge.push(this.queryHookOptions.defaultOptions);\n    }\n\n    // We use compact rather than mergeOptions for this part of the merge,\n    // because we want watchQueryOptions.variables (if defined) to replace\n    // this.observable.options.variables whole. This replacement allows\n    // removing variables by removing them from the variables input to\n    // useQuery. If the variables were always merged together (rather than\n    // replaced), there would be no way to remove existing variables.\n    // However, the variables from options.defaultOptions and globalDefaults\n    // (if provided) should be merged, to ensure individual defaulted\n    // variables always have values, if not otherwise defined in\n    // observable.options or watchQueryOptions.\n    toMerge.push(compact(\n      this.observable && this.observable.options,\n      this.watchQueryOptions,\n    ));\n\n    return toMerge.reduce(\n      mergeOptions\n    ) as WatchQueryOptions<TVariables, TData>;\n  }\n\n  private ssrDisabledResult = maybeDeepFreeze({\n    loading: true,\n    data: void 0 as unknown as TData,\n    error: void 0,\n    networkStatus: NetworkStatus.loading,\n  });\n\n  private skipStandbyResult = maybeDeepFreeze({\n    loading: false,\n    data: void 0 as unknown as TData,\n    error: void 0,\n    networkStatus: NetworkStatus.ready,\n  });\n\n  // A function to massage options before passing them to ObservableQuery.\n  private createWatchQueryOptions({\n    skip,\n    ssr,\n    onCompleted,\n    onError,\n    defaultOptions,\n    // The above options are useQuery-specific, so this ...otherOptions spread\n    // makes otherOptions almost a WatchQueryOptions object, except for the\n    // query property that we add below.\n    ...otherOptions\n  }: QueryHookOptions<TData, TVariables> = {}): WatchQueryOptions<TVariables, TData> {\n    // This Object.assign is safe because otherOptions is a fresh ...rest object\n    // that did not exist until just now, so modifications are still allowed.\n    const watchQueryOptions: WatchQueryOptions<TVariables, TData> =\n      Object.assign(otherOptions, { query: this.query });\n\n    if (\n      this.renderPromises &&\n      (\n        watchQueryOptions.fetchPolicy === 'network-only' ||\n        watchQueryOptions.fetchPolicy === 'cache-and-network'\n      )\n    ) {\n      // this behavior was added to react-apollo without explanation in this PR\n      // https://github.com/apollographql/react-apollo/pull/1579\n      watchQueryOptions.fetchPolicy = 'cache-first';\n    }\n\n    if (!watchQueryOptions.variables) {\n      watchQueryOptions.variables = {} as TVariables;\n    }\n\n    if (skip) {\n      const {\n        fetchPolicy = this.getDefaultFetchPolicy(),\n        initialFetchPolicy = fetchPolicy,\n      } = watchQueryOptions;\n\n      // When skipping, we set watchQueryOptions.fetchPolicy initially to\n      // \"standby\", but we also need/want to preserve the initial non-standby\n      // fetchPolicy that would have been used if not skipping.\n      Object.assign(watchQueryOptions, {\n        initialFetchPolicy,\n        fetchPolicy: 'standby',\n      });\n    } else if (!watchQueryOptions.fetchPolicy) {\n      watchQueryOptions.fetchPolicy =\n        this.observable?.options.initialFetchPolicy ||\n        this.getDefaultFetchPolicy();\n    }\n\n    return watchQueryOptions;\n  }\n\n  getDefaultFetchPolicy(): WatchQueryFetchPolicy {\n    return (\n      this.queryHookOptions.defaultOptions?.fetchPolicy ||\n      this.client.defaultOptions.watchQuery?.fetchPolicy ||\n      \"cache-first\"\n    );\n  }\n\n  // Defining these methods as no-ops on the prototype allows us to call\n  // state.onCompleted and/or state.onError without worrying about whether a\n  // callback was provided.\n  private onCompleted(data: TData) {}\n  private onError(error: ApolloError) {}\n\n  private observable: ObservableQuery<TData, TVariables>;\n  private obsQueryFields: Omit<\n    ObservableQueryFields<TData, TVariables>,\n    \"variables\"\n  >;\n\n  private useObservableQuery() {\n    // See if there is an existing observable that was used to fetch the same\n    // data and if so, use it instead since it will contain the proper queryId\n    // to fetch the result set. This is used during SSR.\n    const obsQuery = this.observable =\n      this.renderPromises\n        && this.renderPromises.getSSRObservable(this.watchQueryOptions)\n        || this.observable // Reuse this.observable if possible (and not SSR)\n        || this.client.watchQuery(this.getObsQueryOptions());\n\n    this.obsQueryFields = useMemo(() => ({\n      refetch: obsQuery.refetch.bind(obsQuery),\n      reobserve: obsQuery.reobserve.bind(obsQuery),\n      fetchMore: obsQuery.fetchMore.bind(obsQuery),\n      updateQuery: obsQuery.updateQuery.bind(obsQuery),\n      startPolling: obsQuery.startPolling.bind(obsQuery),\n      stopPolling: obsQuery.stopPolling.bind(obsQuery),\n      subscribeToMore: obsQuery.subscribeToMore.bind(obsQuery),\n    }), [obsQuery]);\n\n    const ssrAllowed = !(\n      this.queryHookOptions.ssr === false ||\n      this.queryHookOptions.skip\n    );\n\n    if (this.renderPromises && ssrAllowed) {\n      this.renderPromises.registerSSRObservable(obsQuery);\n\n      if (obsQuery.getCurrentResult().loading) {\n        // TODO: This is a legacy API which could probably be cleaned up\n        this.renderPromises.addObservableQueryPromise(obsQuery);\n      }\n    }\n\n    return obsQuery;\n  }\n\n  // These members are populated by getCurrentResult and setResult, and it's\n  // okay/normal for them to be initially undefined.\n  private result: undefined | ApolloQueryResult<TData>;\n  private previousData: undefined | TData;\n\n  private setResult(nextResult: ApolloQueryResult<TData>) {\n    const previousResult = this.result;\n    if (previousResult && previousResult.data) {\n      this.previousData = previousResult.data;\n    }\n    this.result = nextResult;\n    // Calling state.setResult always triggers an update, though some call sites\n    // perform additional equality checks before committing to an update.\n    this.forceUpdate();\n    this.handleErrorOrCompleted(nextResult);\n  }\n\n  private handleErrorOrCompleted(result: ApolloQueryResult<TData>) {\n    if (!result.loading) {\n      // wait a tick in case we are in the middle of rendering a component\n      Promise.resolve().then(() => {\n        if (result.error) {\n          this.onError(result.error);\n        } else if (result.data) {\n          this.onCompleted(result.data);\n        }\n      }).catch(error => {\n        invariant.warn(error);\n      });\n    }\n  }\n\n  private getCurrentResult(): ApolloQueryResult<TData> {\n    // Using this.result as a cache ensures getCurrentResult continues returning\n    // the same (===) result object, unless state.setResult has been called, or\n    // we're doing server rendering and therefore override the result below.\n    if (!this.result) {\n      this.handleErrorOrCompleted(\n        this.result = this.observable.getCurrentResult()\n      );\n    }\n    return this.result;\n  }\n\n  // This cache allows the referential stability of this.result (as returned by\n  // getCurrentResult) to translate into referential stability of the resulting\n  // QueryResult object returned by toQueryResult.\n  private toQueryResultCache = new (canUseWeakMap ? WeakMap : Map)<\n    ApolloQueryResult<TData>,\n    QueryResult<TData, TVariables>\n  >();\n\n  toQueryResult(\n    result: ApolloQueryResult<TData>,\n  ): QueryResult<TData, TVariables> {\n    let queryResult = this.toQueryResultCache.get(result);\n    if (queryResult) return queryResult;\n\n    const { data, partial, ...resultWithoutPartial } = result;\n    this.toQueryResultCache.set(result, queryResult = {\n      data, // Ensure always defined, even if result.data is missing.\n      ...resultWithoutPartial,\n      ...this.obsQueryFields,\n      client: this.client,\n      observable: this.observable,\n      variables: this.observable.variables,\n      called: !this.queryHookOptions.skip,\n      previousData: this.previousData,\n    });\n\n    if (!queryResult.error && isNonEmptyArray(result.errors)) {\n      // Until a set naming convention for networkError and graphQLErrors is\n      // decided upon, we map errors (graphQLErrors) to the error options.\n      // TODO: Is it possible for both result.error and result.errors to be\n      // defined here?\n      queryResult.error = new ApolloError({ graphQLErrors: result.errors });\n    }\n\n    return queryResult;\n  }\n\n  private unsafeHandlePartialRefetch(result: ApolloQueryResult<TData>) {\n    // WARNING: SIDE-EFFECTS IN THE RENDER FUNCTION\n    //\n    // TODO: This code should be removed when the partialRefetch option is\n    // removed. I was unable to get this hook to behave reasonably in certain\n    // edge cases when this block was put in an effect.\n    if (\n      result.partial &&\n      this.queryHookOptions.partialRefetch &&\n      !result.loading &&\n      (!result.data || Object.keys(result.data).length === 0) &&\n      this.observable.options.fetchPolicy !== 'cache-only'\n    ) {\n      Object.assign(result, {\n        loading: true,\n        networkStatus: NetworkStatus.refetch,\n      });\n      this.observable.refetch();\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}