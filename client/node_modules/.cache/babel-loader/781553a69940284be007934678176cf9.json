{"ast":null,"code":"import inspect from\"../../jsutils/inspect.mjs\";import{GraphQLError}from\"../../error/GraphQLError.mjs\";import{isCompositeType}from\"../../type/definition.mjs\";import{typeFromAST}from\"../../utilities/typeFromAST.mjs\";import{doTypesOverlap}from\"../../utilities/typeComparators.mjs\";/**\n * Possible fragment spread\n *\n * A fragment spread is only valid if the type condition could ever possibly\n * be true: if there is a non-empty intersection of the possible parent types,\n * and possible types which pass the type condition.\n */export function PossibleFragmentSpreadsRule(context){return{InlineFragment:function InlineFragment(node){var fragType=context.getType();var parentType=context.getParentType();if(isCompositeType(fragType)&&isCompositeType(parentType)&&!doTypesOverlap(context.getSchema(),fragType,parentType)){var parentTypeStr=inspect(parentType);var fragTypeStr=inspect(fragType);context.reportError(new GraphQLError(\"Fragment cannot be spread here as objects of type \\\"\".concat(parentTypeStr,\"\\\" can never be of type \\\"\").concat(fragTypeStr,\"\\\".\"),node));}},FragmentSpread:function FragmentSpread(node){var fragName=node.name.value;var fragType=getFragmentType(context,fragName);var parentType=context.getParentType();if(fragType&&parentType&&!doTypesOverlap(context.getSchema(),fragType,parentType)){var parentTypeStr=inspect(parentType);var fragTypeStr=inspect(fragType);context.reportError(new GraphQLError(\"Fragment \\\"\".concat(fragName,\"\\\" cannot be spread here as objects of type \\\"\").concat(parentTypeStr,\"\\\" can never be of type \\\"\").concat(fragTypeStr,\"\\\".\"),node));}}};}function getFragmentType(context,name){var frag=context.getFragment(name);if(frag){var type=typeFromAST(context.getSchema(),frag.typeCondition);if(isCompositeType(type)){return type;}}}","map":{"version":3,"names":["inspect","GraphQLError","isCompositeType","typeFromAST","doTypesOverlap","PossibleFragmentSpreadsRule","context","InlineFragment","node","fragType","getType","parentType","getParentType","getSchema","parentTypeStr","fragTypeStr","reportError","concat","FragmentSpread","fragName","name","value","getFragmentType","frag","getFragment","type","typeCondition"],"sources":["C:/Users/jarma/school/challenges/Project3_Final/client/src/node_modules/graphql/validation/rules/PossibleFragmentSpreadsRule.mjs"],"sourcesContent":["import inspect from \"../../jsutils/inspect.mjs\";\nimport { GraphQLError } from \"../../error/GraphQLError.mjs\";\nimport { isCompositeType } from \"../../type/definition.mjs\";\nimport { typeFromAST } from \"../../utilities/typeFromAST.mjs\";\nimport { doTypesOverlap } from \"../../utilities/typeComparators.mjs\";\n\n/**\n * Possible fragment spread\n *\n * A fragment spread is only valid if the type condition could ever possibly\n * be true: if there is a non-empty intersection of the possible parent types,\n * and possible types which pass the type condition.\n */\nexport function PossibleFragmentSpreadsRule(context) {\n  return {\n    InlineFragment: function InlineFragment(node) {\n      var fragType = context.getType();\n      var parentType = context.getParentType();\n\n      if (isCompositeType(fragType) && isCompositeType(parentType) && !doTypesOverlap(context.getSchema(), fragType, parentType)) {\n        var parentTypeStr = inspect(parentType);\n        var fragTypeStr = inspect(fragType);\n        context.reportError(new GraphQLError(\"Fragment cannot be spread here as objects of type \\\"\".concat(parentTypeStr, \"\\\" can never be of type \\\"\").concat(fragTypeStr, \"\\\".\"), node));\n      }\n    },\n    FragmentSpread: function FragmentSpread(node) {\n      var fragName = node.name.value;\n      var fragType = getFragmentType(context, fragName);\n      var parentType = context.getParentType();\n\n      if (fragType && parentType && !doTypesOverlap(context.getSchema(), fragType, parentType)) {\n        var parentTypeStr = inspect(parentType);\n        var fragTypeStr = inspect(fragType);\n        context.reportError(new GraphQLError(\"Fragment \\\"\".concat(fragName, \"\\\" cannot be spread here as objects of type \\\"\").concat(parentTypeStr, \"\\\" can never be of type \\\"\").concat(fragTypeStr, \"\\\".\"), node));\n      }\n    }\n  };\n}\n\nfunction getFragmentType(context, name) {\n  var frag = context.getFragment(name);\n\n  if (frag) {\n    var type = typeFromAST(context.getSchema(), frag.typeCondition);\n\n    if (isCompositeType(type)) {\n      return type;\n    }\n  }\n}\n"],"mappings":"AAAA,MAAOA,QAAP,KAAoB,2BAApB,CACA,OAASC,YAAT,KAA6B,8BAA7B,CACA,OAASC,eAAT,KAAgC,2BAAhC,CACA,OAASC,WAAT,KAA4B,iCAA5B,CACA,OAASC,cAAT,KAA+B,qCAA/B,CAEA;AACA;AACA;AACA;AACA;AACA;AACA,GACA,MAAO,SAASC,4BAAT,CAAqCC,OAArC,CAA8C,CACnD,MAAO,CACLC,cAAc,CAAE,QAASA,eAAT,CAAwBC,IAAxB,CAA8B,CAC5C,GAAIC,SAAQ,CAAGH,OAAO,CAACI,OAAR,EAAf,CACA,GAAIC,WAAU,CAAGL,OAAO,CAACM,aAAR,EAAjB,CAEA,GAAIV,eAAe,CAACO,QAAD,CAAf,EAA6BP,eAAe,CAACS,UAAD,CAA5C,EAA4D,CAACP,cAAc,CAACE,OAAO,CAACO,SAAR,EAAD,CAAsBJ,QAAtB,CAAgCE,UAAhC,CAA/E,CAA4H,CAC1H,GAAIG,cAAa,CAAGd,OAAO,CAACW,UAAD,CAA3B,CACA,GAAII,YAAW,CAAGf,OAAO,CAACS,QAAD,CAAzB,CACAH,OAAO,CAACU,WAAR,CAAoB,GAAIf,aAAJ,CAAiB,uDAAuDgB,MAAvD,CAA8DH,aAA9D,CAA6E,4BAA7E,EAA2GG,MAA3G,CAAkHF,WAAlH,CAA+H,KAA/H,CAAjB,CAAwJP,IAAxJ,CAApB,EACD,CACF,CAVI,CAWLU,cAAc,CAAE,QAASA,eAAT,CAAwBV,IAAxB,CAA8B,CAC5C,GAAIW,SAAQ,CAAGX,IAAI,CAACY,IAAL,CAAUC,KAAzB,CACA,GAAIZ,SAAQ,CAAGa,eAAe,CAAChB,OAAD,CAAUa,QAAV,CAA9B,CACA,GAAIR,WAAU,CAAGL,OAAO,CAACM,aAAR,EAAjB,CAEA,GAAIH,QAAQ,EAAIE,UAAZ,EAA0B,CAACP,cAAc,CAACE,OAAO,CAACO,SAAR,EAAD,CAAsBJ,QAAtB,CAAgCE,UAAhC,CAA7C,CAA0F,CACxF,GAAIG,cAAa,CAAGd,OAAO,CAACW,UAAD,CAA3B,CACA,GAAII,YAAW,CAAGf,OAAO,CAACS,QAAD,CAAzB,CACAH,OAAO,CAACU,WAAR,CAAoB,GAAIf,aAAJ,CAAiB,cAAcgB,MAAd,CAAqBE,QAArB,CAA+B,gDAA/B,EAAiFF,MAAjF,CAAwFH,aAAxF,CAAuG,4BAAvG,EAAqIG,MAArI,CAA4IF,WAA5I,CAAyJ,KAAzJ,CAAjB,CAAkLP,IAAlL,CAApB,EACD,CACF,CArBI,CAAP,CAuBD,CAED,QAASc,gBAAT,CAAyBhB,OAAzB,CAAkCc,IAAlC,CAAwC,CACtC,GAAIG,KAAI,CAAGjB,OAAO,CAACkB,WAAR,CAAoBJ,IAApB,CAAX,CAEA,GAAIG,IAAJ,CAAU,CACR,GAAIE,KAAI,CAAGtB,WAAW,CAACG,OAAO,CAACO,SAAR,EAAD,CAAsBU,IAAI,CAACG,aAA3B,CAAtB,CAEA,GAAIxB,eAAe,CAACuB,IAAD,CAAnB,CAA2B,CACzB,MAAOA,KAAP,CACD,CACF,CACF"},"metadata":{},"sourceType":"module"}