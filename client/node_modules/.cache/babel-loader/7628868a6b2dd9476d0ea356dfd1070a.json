{"ast":null,"code":"import{__assign}from\"tslib\";import{invariant,InvariantError}from\"../../utilities/globals/index.js\";import{Kind}from'graphql';import{wrap}from'optimism';import{isField,resultKeyNameFromField,isReference,makeReference,shouldInclude,addTypenameToDocument,getDefaultValues,getMainDefinition,getQueryDefinition,getFragmentFromSelection,maybeDeepFreeze,mergeDeepArray,DeepMerger,isNonNullObject,canUseWeakMap,compact}from\"../../utilities/index.js\";import{maybeDependOnExistenceOfEntity,supportsResultCaching}from\"./entityStore.js\";import{isArray,extractFragmentContext,getTypenameFromStoreObject,shouldCanonizeResults}from\"./helpers.js\";import{MissingFieldError}from\"../core/types/common.js\";import{canonicalStringify,ObjectCanon}from\"./object-canon.js\";;function execSelectionSetKeyArgs(options){return[options.selectionSet,options.objectOrReference,options.context,options.context.canonizeResults];}var StoreReader=function(){function StoreReader(config){var _this=this;this.knownResults=new(canUseWeakMap?WeakMap:Map)();this.config=compact(config,{addTypename:config.addTypename!==false,canonizeResults:shouldCanonizeResults(config)});this.canon=config.canon||new ObjectCanon();this.executeSelectionSet=wrap(function(options){var _a;var canonizeResults=options.context.canonizeResults;var peekArgs=execSelectionSetKeyArgs(options);peekArgs[3]=!canonizeResults;var other=(_a=_this.executeSelectionSet).peek.apply(_a,peekArgs);if(other){if(canonizeResults){return __assign(__assign({},other),{result:_this.canon.admit(other.result)});}return other;}maybeDependOnExistenceOfEntity(options.context.store,options.enclosingRef.__ref);return _this.execSelectionSetImpl(options);},{max:this.config.resultCacheMaxSize,keyArgs:execSelectionSetKeyArgs,makeCacheKey:function makeCacheKey(selectionSet,parent,context,canonizeResults){if(supportsResultCaching(context.store)){return context.store.makeCacheKey(selectionSet,isReference(parent)?parent.__ref:parent,context.varString,canonizeResults);}}});this.executeSubSelectedArray=wrap(function(options){maybeDependOnExistenceOfEntity(options.context.store,options.enclosingRef.__ref);return _this.execSubSelectedArrayImpl(options);},{max:this.config.resultCacheMaxSize,makeCacheKey:function makeCacheKey(_a){var field=_a.field,array=_a.array,context=_a.context;if(supportsResultCaching(context.store)){return context.store.makeCacheKey(field,array,context.varString);}}});}StoreReader.prototype.resetCanon=function(){this.canon=new ObjectCanon();};StoreReader.prototype.diffQueryAgainstStore=function(_a){var store=_a.store,query=_a.query,_b=_a.rootId,rootId=_b===void 0?'ROOT_QUERY':_b,variables=_a.variables,_c=_a.returnPartialData,returnPartialData=_c===void 0?true:_c,_d=_a.canonizeResults,canonizeResults=_d===void 0?this.config.canonizeResults:_d;var policies=this.config.cache.policies;variables=__assign(__assign({},getDefaultValues(getQueryDefinition(query))),variables);var rootRef=makeReference(rootId);var execResult=this.executeSelectionSet({selectionSet:getMainDefinition(query).selectionSet,objectOrReference:rootRef,enclosingRef:rootRef,context:__assign({store:store,query:query,policies:policies,variables:variables,varString:canonicalStringify(variables),canonizeResults:canonizeResults},extractFragmentContext(query,this.config.fragments))});var missing;if(execResult.missing){missing=[new MissingFieldError(firstMissing(execResult.missing),execResult.missing,query,variables)];if(!returnPartialData){throw missing[0];}}return{result:execResult.result,complete:!missing,missing:missing};};StoreReader.prototype.isFresh=function(result,parent,selectionSet,context){if(supportsResultCaching(context.store)&&this.knownResults.get(result)===selectionSet){var latest=this.executeSelectionSet.peek(selectionSet,parent,context,this.canon.isKnown(result));if(latest&&result===latest.result){return true;}}return false;};StoreReader.prototype.execSelectionSetImpl=function(_a){var _this=this;var selectionSet=_a.selectionSet,objectOrReference=_a.objectOrReference,enclosingRef=_a.enclosingRef,context=_a.context;if(isReference(objectOrReference)&&!context.policies.rootTypenamesById[objectOrReference.__ref]&&!context.store.has(objectOrReference.__ref)){return{result:this.canon.empty,missing:\"Dangling reference to missing \".concat(objectOrReference.__ref,\" object\")};}var variables=context.variables,policies=context.policies,store=context.store;var typename=store.getFieldValue(objectOrReference,\"__typename\");var objectsToMerge=[];var missing;var missingMerger=new DeepMerger();if(this.config.addTypename&&typeof typename===\"string\"&&!policies.rootIdsByTypename[typename]){objectsToMerge.push({__typename:typename});}function handleMissing(result,resultName){var _a;if(result.missing){missing=missingMerger.merge(missing,(_a={},_a[resultName]=result.missing,_a));}return result.result;}var workSet=new Set(selectionSet.selections);workSet.forEach(function(selection){var _a,_b;if(!shouldInclude(selection,variables))return;if(isField(selection)){var fieldValue=policies.readField({fieldName:selection.name.value,field:selection,variables:context.variables,from:objectOrReference},context);var resultName=resultKeyNameFromField(selection);if(fieldValue===void 0){if(!addTypenameToDocument.added(selection)){missing=missingMerger.merge(missing,(_a={},_a[resultName]=\"Can't find field '\".concat(selection.name.value,\"' on \").concat(isReference(objectOrReference)?objectOrReference.__ref+\" object\":\"object \"+JSON.stringify(objectOrReference,null,2)),_a));}}else if(isArray(fieldValue)){fieldValue=handleMissing(_this.executeSubSelectedArray({field:selection,array:fieldValue,enclosingRef:enclosingRef,context:context}),resultName);}else if(!selection.selectionSet){if(context.canonizeResults){fieldValue=_this.canon.pass(fieldValue);}}else if(fieldValue!=null){fieldValue=handleMissing(_this.executeSelectionSet({selectionSet:selection.selectionSet,objectOrReference:fieldValue,enclosingRef:isReference(fieldValue)?fieldValue:enclosingRef,context:context}),resultName);}if(fieldValue!==void 0){objectsToMerge.push((_b={},_b[resultName]=fieldValue,_b));}}else{var fragment=getFragmentFromSelection(selection,context.lookupFragment);if(!fragment&&selection.kind===Kind.FRAGMENT_SPREAD){throw __DEV__?new InvariantError(\"No fragment named \".concat(selection.name.value)):new InvariantError(5);}if(fragment&&policies.fragmentMatches(fragment,typename)){fragment.selectionSet.selections.forEach(workSet.add,workSet);}}});var result=mergeDeepArray(objectsToMerge);var finalResult={result:result,missing:missing};var frozen=context.canonizeResults?this.canon.admit(finalResult):maybeDeepFreeze(finalResult);if(frozen.result){this.knownResults.set(frozen.result,selectionSet);}return frozen;};StoreReader.prototype.execSubSelectedArrayImpl=function(_a){var _this=this;var field=_a.field,array=_a.array,enclosingRef=_a.enclosingRef,context=_a.context;var missing;var missingMerger=new DeepMerger();function handleMissing(childResult,i){var _a;if(childResult.missing){missing=missingMerger.merge(missing,(_a={},_a[i]=childResult.missing,_a));}return childResult.result;}if(field.selectionSet){array=array.filter(context.store.canRead);}array=array.map(function(item,i){if(item===null){return null;}if(isArray(item)){return handleMissing(_this.executeSubSelectedArray({field:field,array:item,enclosingRef:enclosingRef,context:context}),i);}if(field.selectionSet){return handleMissing(_this.executeSelectionSet({selectionSet:field.selectionSet,objectOrReference:item,enclosingRef:isReference(item)?item:enclosingRef,context:context}),i);}if(__DEV__){assertSelectionSetForIdValue(context.store,field,item);}return item;});return{result:context.canonizeResults?this.canon.admit(array):array,missing:missing};};return StoreReader;}();export{StoreReader};function firstMissing(tree){try{JSON.stringify(tree,function(_,value){if(typeof value===\"string\")throw value;return value;});}catch(result){return result;}}function assertSelectionSetForIdValue(store,field,fieldValue){if(!field.selectionSet){var workSet_1=new Set([fieldValue]);workSet_1.forEach(function(value){if(isNonNullObject(value)){__DEV__?invariant(!isReference(value),\"Missing selection set for object of type \".concat(getTypenameFromStoreObject(store,value),\" returned for query field \").concat(field.name.value)):invariant(!isReference(value),6);Object.values(value).forEach(workSet_1.add,workSet_1);}});}}","map":{"version":3,"mappings":"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","names":["invariant","InvariantError","Kind","wrap","isField","resultKeyNameFromField","isReference","makeReference","shouldInclude","addTypenameToDocument","getDefaultValues","getMainDefinition","getQueryDefinition","getFragmentFromSelection","maybeDeepFreeze","mergeDeepArray","DeepMerger","isNonNullObject","canUseWeakMap","compact","maybeDependOnExistenceOfEntity","supportsResultCaching","isArray","extractFragmentContext","getTypenameFromStoreObject","shouldCanonizeResults","MissingFieldError","canonicalStringify","ObjectCanon","execSelectionSetKeyArgs","options","selectionSet","objectOrReference","context","canonizeResults","config","WeakMap","Map","addTypename","canon","executeSelectionSet","peekArgs","other","peek","apply","_a","result","_this","admit","store","enclosingRef","__ref","execSelectionSetImpl","max","resultCacheMaxSize","keyArgs","makeCacheKey","parent","varString","executeSubSelectedArray","execSubSelectedArrayImpl","field","array","StoreReader","query","_b","variables","_c","_d","policies","cache","rootRef","rootId","execResult","fragments","missing","firstMissing","returnPartialData","complete","knownResults","get","latest","isKnown","rootTypenamesById","has","empty","typename","getFieldValue","objectsToMerge","missingMerger","rootIdsByTypename","push","__typename","handleMissing","resultName","merge","workSet","Set","selections","forEach","selection","fieldValue","readField","fieldName","name","value","from","added","concat","JSON","stringify","pass","fragment","lookupFragment","kind","FRAGMENT_SPREAD","__DEV__","fragmentMatches","add","finalResult","frozen","set","childResult","i","filter","canRead","map","item","assertSelectionSetForIdValue","tree","_","workSet_1","Object","values"],"sourceRoot":"","sources":["../../../src/cache/inmemory/readFromStore.ts"],"sourcesContent":["import { invariant, InvariantError } from '../../utilities/globals';\n\nimport {\n  DocumentNode,\n  FieldNode,\n  Kind,\n  SelectionSetNode,\n} from 'graphql';\nimport { wrap, OptimisticWrapperFunction } from 'optimism';\n\nimport {\n  isField,\n  resultKeyNameFromField,\n  Reference,\n  isReference,\n  makeReference,\n  StoreObject,\n  FragmentMap,\n  shouldInclude,\n  addTypenameToDocument,\n  getDefaultValues,\n  getMainDefinition,\n  getQueryDefinition,\n  getFragmentFromSelection,\n  maybeDeepFreeze,\n  mergeDeepArray,\n  DeepMerger,\n  isNonNullObject,\n  canUseWeakMap,\n  compact,\n  FragmentMapFunction,\n} from '../../utilities';\nimport { Cache } from '../core/types/Cache';\nimport {\n  DiffQueryAgainstStoreOptions,\n  InMemoryCacheConfig,\n  NormalizedCache,\n  ReadMergeModifyContext,\n} from './types';\nimport { maybeDependOnExistenceOfEntity, supportsResultCaching } from './entityStore';\nimport { isArray, extractFragmentContext, getTypenameFromStoreObject, shouldCanonizeResults } from './helpers';\nimport { Policies } from './policies';\nimport { InMemoryCache } from './inMemoryCache';\nimport { MissingFieldError, MissingTree } from '../core/types/common';\nimport { canonicalStringify, ObjectCanon } from './object-canon';\n\nexport type VariableMap = { [name: string]: any };\n\ninterface ReadContext extends ReadMergeModifyContext {\n  query: DocumentNode;\n  policies: Policies;\n  canonizeResults: boolean;\n  fragmentMap: FragmentMap;\n  lookupFragment: FragmentMapFunction;\n};\n\nexport type ExecResult<R = any> = {\n  result: R;\n  missing?: MissingTree;\n};\n\ntype ExecSelectionSetOptions = {\n  selectionSet: SelectionSetNode;\n  objectOrReference: StoreObject | Reference;\n  enclosingRef: Reference;\n  context: ReadContext;\n};\n\ntype ExecSubSelectedArrayOptions = {\n  field: FieldNode;\n  array: readonly any[];\n  enclosingRef: Reference;\n  context: ReadContext;\n};\n\nexport interface StoreReaderConfig {\n  cache: InMemoryCache,\n  addTypename?: boolean;\n  resultCacheMaxSize?: number;\n  canonizeResults?: boolean;\n  canon?: ObjectCanon;\n  fragments?: InMemoryCacheConfig[\"fragments\"];\n}\n\n// Arguments type after keyArgs translation.\ntype ExecSelectionSetKeyArgs = [\n  SelectionSetNode,\n  StoreObject | Reference,\n  ReadMergeModifyContext,\n  boolean,\n];\n\nfunction execSelectionSetKeyArgs(\n  options: ExecSelectionSetOptions,\n): ExecSelectionSetKeyArgs {\n  return [\n    options.selectionSet,\n    options.objectOrReference,\n    options.context,\n    // We split out this property so we can pass different values\n    // independently without modifying options.context itself.\n    options.context.canonizeResults,\n  ];\n}\n\nexport class StoreReader {\n  // cached version of executeSelectionSet\n  private executeSelectionSet: OptimisticWrapperFunction<\n    [ExecSelectionSetOptions], // Actual arguments tuple type.\n    ExecResult, // Actual return type.\n    ExecSelectionSetKeyArgs\n  >;\n\n  // cached version of executeSubSelectedArray\n  private executeSubSelectedArray: OptimisticWrapperFunction<\n    [ExecSubSelectedArrayOptions],\n    ExecResult<any>,\n    [ExecSubSelectedArrayOptions]>;\n\n  private config: {\n    cache: InMemoryCache,\n    addTypename: boolean;\n    resultCacheMaxSize?: number;\n    canonizeResults: boolean;\n    fragments?: InMemoryCacheConfig[\"fragments\"];\n  };\n\n  private knownResults = new (\n    canUseWeakMap ? WeakMap : Map\n  )<Record<string, any>, SelectionSetNode>();\n\n  public canon: ObjectCanon;\n  public resetCanon() {\n    this.canon = new ObjectCanon;\n  }\n\n  constructor(config: StoreReaderConfig) {\n    this.config = compact(config, {\n      addTypename: config.addTypename !== false,\n      canonizeResults: shouldCanonizeResults(config),\n    });\n\n    this.canon = config.canon || new ObjectCanon;\n\n    this.executeSelectionSet = wrap(options => {\n      const { canonizeResults } = options.context;\n\n      const peekArgs = execSelectionSetKeyArgs(options);\n\n      // Negate this boolean option so we can find out if we've already read\n      // this result using the other boolean value.\n      peekArgs[3] = !canonizeResults;\n\n      const other = this.executeSelectionSet.peek(...peekArgs);\n\n      if (other) {\n        if (canonizeResults) {\n          return {\n            ...other,\n            // If we previously read this result without canonizing it, we can\n            // reuse that result simply by canonizing it now.\n            result: this.canon.admit(other.result),\n          };\n        }\n        // If we previously read this result with canonization enabled, we can\n        // return that canonized result as-is.\n        return other;\n      }\n\n      maybeDependOnExistenceOfEntity(\n        options.context.store,\n        options.enclosingRef.__ref,\n      );\n\n      // Finally, if we didn't find any useful previous results, run the real\n      // execSelectionSetImpl method with the given options.\n      return this.execSelectionSetImpl(options);\n\n    }, {\n      max: this.config.resultCacheMaxSize,\n      keyArgs: execSelectionSetKeyArgs,\n      // Note that the parameters of makeCacheKey are determined by the\n      // array returned by keyArgs.\n      makeCacheKey(selectionSet, parent, context, canonizeResults) {\n        if (supportsResultCaching(context.store)) {\n          return context.store.makeCacheKey(\n            selectionSet,\n            isReference(parent) ? parent.__ref : parent,\n            context.varString,\n            canonizeResults,\n          );\n        }\n      }\n    });\n\n    this.executeSubSelectedArray = wrap((options: ExecSubSelectedArrayOptions) => {\n      maybeDependOnExistenceOfEntity(\n        options.context.store,\n        options.enclosingRef.__ref,\n      );\n      return this.execSubSelectedArrayImpl(options);\n    }, {\n      max: this.config.resultCacheMaxSize,\n      makeCacheKey({ field, array, context }) {\n        if (supportsResultCaching(context.store)) {\n          return context.store.makeCacheKey(\n            field,\n            array,\n            context.varString,\n          );\n        }\n      }\n    });\n  }\n\n  /**\n   * Given a store and a query, return as much of the result as possible and\n   * identify if any data was missing from the store.\n   * @param  {DocumentNode} query A parsed GraphQL query document\n   * @param  {Store} store The Apollo Client store object\n   * @return {result: Object, complete: [boolean]}\n   */\n  public diffQueryAgainstStore<T>({\n    store,\n    query,\n    rootId = 'ROOT_QUERY',\n    variables,\n    returnPartialData = true,\n    canonizeResults = this.config.canonizeResults,\n  }: DiffQueryAgainstStoreOptions): Cache.DiffResult<T> {\n    const policies = this.config.cache.policies;\n\n    variables = {\n      ...getDefaultValues(getQueryDefinition(query)),\n      ...variables!,\n    };\n\n    const rootRef = makeReference(rootId);\n    const execResult = this.executeSelectionSet({\n      selectionSet: getMainDefinition(query).selectionSet,\n      objectOrReference: rootRef,\n      enclosingRef: rootRef,\n      context: {\n        store,\n        query,\n        policies,\n        variables,\n        varString: canonicalStringify(variables),\n        canonizeResults,\n        ...extractFragmentContext(query, this.config.fragments),\n      },\n    });\n\n    let missing: MissingFieldError[] | undefined;\n    if (execResult.missing) {\n      // For backwards compatibility we still report an array of\n      // MissingFieldError objects, even though there will only ever be at most\n      // one of them, now that all missing field error messages are grouped\n      // together in the execResult.missing tree.\n      missing = [new MissingFieldError(\n        firstMissing(execResult.missing)!,\n        execResult.missing,\n        query,\n        variables,\n      )];\n      if (!returnPartialData) {\n        throw missing[0];\n      }\n    }\n\n    return {\n      result: execResult.result,\n      complete: !missing,\n      missing,\n    };\n  }\n\n  public isFresh(\n    result: Record<string, any>,\n    parent: StoreObject | Reference,\n    selectionSet: SelectionSetNode,\n    context: ReadMergeModifyContext,\n  ): boolean {\n    if (supportsResultCaching(context.store) &&\n        this.knownResults.get(result) === selectionSet) {\n      const latest = this.executeSelectionSet.peek(\n        selectionSet,\n        parent,\n        context,\n        // If result is canonical, then it could only have been previously\n        // cached by the canonizing version of executeSelectionSet, so we can\n        // avoid checking both possibilities here.\n        this.canon.isKnown(result),\n      );\n      if (latest && result === latest.result) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  // Uncached version of executeSelectionSet.\n  private execSelectionSetImpl({\n    selectionSet,\n    objectOrReference,\n    enclosingRef,\n    context,\n  }: ExecSelectionSetOptions): ExecResult {\n    if (isReference(objectOrReference) &&\n        !context.policies.rootTypenamesById[objectOrReference.__ref] &&\n        !context.store.has(objectOrReference.__ref)) {\n      return {\n        result: this.canon.empty,\n        missing: `Dangling reference to missing ${objectOrReference.__ref} object`,\n      };\n    }\n\n    const { variables, policies, store } = context;\n    const typename = store.getFieldValue<string>(objectOrReference, \"__typename\");\n\n    const objectsToMerge: Record<string, any>[] = [];\n    let missing: MissingTree | undefined;\n    const missingMerger = new DeepMerger();\n\n    if (this.config.addTypename &&\n        typeof typename === \"string\" &&\n        !policies.rootIdsByTypename[typename]) {\n      // Ensure we always include a default value for the __typename\n      // field, if we have one, and this.config.addTypename is true. Note\n      // that this field can be overridden by other merged objects.\n      objectsToMerge.push({ __typename: typename });\n    }\n\n    function handleMissing<T>(result: ExecResult<T>, resultName: string): T {\n      if (result.missing) {\n        missing = missingMerger.merge(missing, { [resultName]: result.missing });\n      }\n      return result.result;\n    }\n\n    const workSet = new Set(selectionSet.selections);\n\n    workSet.forEach(selection => {\n      // Omit fields with directives @skip(if: <truthy value>) or\n      // @include(if: <falsy value>).\n      if (!shouldInclude(selection, variables)) return;\n\n      if (isField(selection)) {\n        let fieldValue = policies.readField({\n          fieldName: selection.name.value,\n          field: selection,\n          variables: context.variables,\n          from: objectOrReference,\n        }, context);\n\n        const resultName = resultKeyNameFromField(selection);\n\n        if (fieldValue === void 0) {\n          if (!addTypenameToDocument.added(selection)) {\n            missing = missingMerger.merge(missing, {\n              [resultName]: `Can't find field '${\n                selection.name.value\n              }' on ${\n                isReference(objectOrReference)\n                  ? objectOrReference.__ref + \" object\"\n                  : \"object \" + JSON.stringify(objectOrReference, null, 2)\n              }`\n            });\n          }\n\n        } else if (isArray(fieldValue)) {\n          fieldValue = handleMissing(this.executeSubSelectedArray({\n            field: selection,\n            array: fieldValue,\n            enclosingRef,\n            context,\n          }), resultName);\n\n        } else if (!selection.selectionSet) {\n          // If the field does not have a selection set, then we handle it\n          // as a scalar value. To keep this.canon from canonicalizing\n          // this value, we use this.canon.pass to wrap fieldValue in a\n          // Pass object that this.canon.admit will later unwrap as-is.\n          if (context.canonizeResults) {\n            fieldValue = this.canon.pass(fieldValue);\n          }\n\n        } else if (fieldValue != null) {\n          // In this case, because we know the field has a selection set,\n          // it must be trying to query a GraphQLObjectType, which is why\n          // fieldValue must be != null.\n          fieldValue = handleMissing(this.executeSelectionSet({\n            selectionSet: selection.selectionSet,\n            objectOrReference: fieldValue as StoreObject | Reference,\n            enclosingRef: isReference(fieldValue) ? fieldValue : enclosingRef,\n            context,\n          }), resultName);\n        }\n\n        if (fieldValue !== void 0) {\n          objectsToMerge.push({ [resultName]: fieldValue });\n        }\n\n      } else {\n        const fragment = getFragmentFromSelection(\n          selection,\n          context.lookupFragment,\n        );\n\n        if (!fragment && selection.kind === Kind.FRAGMENT_SPREAD) {\n          throw new InvariantError(`No fragment named ${selection.name.value}`);\n        }\n\n        if (fragment && policies.fragmentMatches(fragment, typename)) {\n          fragment.selectionSet.selections.forEach(workSet.add, workSet);\n        }\n      }\n    });\n\n    const result = mergeDeepArray(objectsToMerge);\n    const finalResult: ExecResult = { result, missing };\n    const frozen = context.canonizeResults\n      ? this.canon.admit(finalResult)\n      // Since this.canon is normally responsible for freezing results (only in\n      // development), freeze them manually if canonization is disabled.\n      : maybeDeepFreeze(finalResult);\n\n    // Store this result with its selection set so that we can quickly\n    // recognize it again in the StoreReader#isFresh method.\n    if (frozen.result) {\n      this.knownResults.set(frozen.result, selectionSet);\n    }\n\n    return frozen;\n  }\n\n  // Uncached version of executeSubSelectedArray.\n  private execSubSelectedArrayImpl({\n    field,\n    array,\n    enclosingRef,\n    context,\n  }: ExecSubSelectedArrayOptions): ExecResult {\n    let missing: MissingTree | undefined;\n    let missingMerger = new DeepMerger<MissingTree[]>();\n\n    function handleMissing<T>(childResult: ExecResult<T>, i: number): T {\n      if (childResult.missing) {\n        missing = missingMerger.merge(missing, { [i]: childResult.missing });\n      }\n      return childResult.result;\n    }\n\n    if (field.selectionSet) {\n      array = array.filter(context.store.canRead);\n    }\n\n    array = array.map((item, i) => {\n      // null value in array\n      if (item === null) {\n        return null;\n      }\n\n      // This is a nested array, recurse\n      if (isArray(item)) {\n        return handleMissing(this.executeSubSelectedArray({\n          field,\n          array: item,\n          enclosingRef,\n          context,\n        }), i);\n      }\n\n      // This is an object, run the selection set on it\n      if (field.selectionSet) {\n        return handleMissing(this.executeSelectionSet({\n          selectionSet: field.selectionSet,\n          objectOrReference: item,\n          enclosingRef: isReference(item) ? item : enclosingRef,\n          context,\n        }), i);\n      }\n\n      if (__DEV__) {\n        assertSelectionSetForIdValue(context.store, field, item);\n      }\n\n      return item;\n    });\n\n    return {\n      result: context.canonizeResults ? this.canon.admit(array) : array,\n      missing,\n    };\n  }\n}\n\nfunction firstMissing(tree: MissingTree): string | undefined {\n  try {\n    JSON.stringify(tree, (_, value) => {\n      if (typeof value === \"string\") throw value;\n      return value;\n    });\n  } catch (result) {\n    return result;\n  }\n}\n\nfunction assertSelectionSetForIdValue(\n  store: NormalizedCache,\n  field: FieldNode,\n  fieldValue: any,\n) {\n  if (!field.selectionSet) {\n    const workSet = new Set([fieldValue]);\n    workSet.forEach(value => {\n      if (isNonNullObject(value)) {\n        invariant(\n          !isReference(value),\n          `Missing selection set for object of type ${\n            getTypenameFromStoreObject(store, value)\n          } returned for query field ${field.name.value}`,\n        );\n        Object.values(value).forEach(workSet.add, workSet);\n      }\n    });\n  }\n}\n"]},"metadata":{},"sourceType":"module"}