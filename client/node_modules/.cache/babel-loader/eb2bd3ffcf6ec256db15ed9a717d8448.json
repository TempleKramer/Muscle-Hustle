{"ast":null,"code":"import{__assign}from\"tslib\";import{invariant,InvariantError}from\"../../utilities/globals/index.js\";import{equal}from'@wry/equality';import{Trie}from'@wry/trie';import{Kind}from'graphql';import{getFragmentFromSelection,getDefaultValues,getOperationDefinition,getTypenameFromResult,makeReference,isField,resultKeyNameFromField,isReference,shouldInclude,cloneDeep,addTypenameToDocument,isNonEmptyArray,argumentsObjectFromField}from\"../../utilities/index.js\";import{isArray,makeProcessedFieldsMerger,fieldNameFromStoreName,storeValueIsStoreObject,extractFragmentContext}from\"./helpers.js\";import{canonicalStringify}from\"./object-canon.js\";import{normalizeReadFieldOptions}from\"./policies.js\";;function getContextFlavor(context,clientOnly,deferred){var key=\"\".concat(clientOnly).concat(deferred);var flavored=context.flavors.get(key);if(!flavored){context.flavors.set(key,flavored=context.clientOnly===clientOnly&&context.deferred===deferred?context:__assign(__assign({},context),{clientOnly:clientOnly,deferred:deferred}));}return flavored;}var StoreWriter=function(){function StoreWriter(cache,reader,fragments){this.cache=cache;this.reader=reader;this.fragments=fragments;}StoreWriter.prototype.writeToStore=function(store,_a){var _this=this;var query=_a.query,result=_a.result,dataId=_a.dataId,variables=_a.variables,overwrite=_a.overwrite;var operationDefinition=getOperationDefinition(query);var merger=makeProcessedFieldsMerger();variables=__assign(__assign({},getDefaultValues(operationDefinition)),variables);var context=__assign(__assign({store:store,written:Object.create(null),merge:function merge(existing,incoming){return merger.merge(existing,incoming);},variables:variables,varString:canonicalStringify(variables)},extractFragmentContext(query,this.fragments)),{overwrite:!!overwrite,incomingById:new Map(),clientOnly:false,deferred:false,flavors:new Map()});var ref=this.processSelectionSet({result:result||Object.create(null),dataId:dataId,selectionSet:operationDefinition.selectionSet,mergeTree:{map:new Map()},context:context});if(!isReference(ref)){throw __DEV__?new InvariantError(\"Could not identify object \".concat(JSON.stringify(result))):new InvariantError(7);}context.incomingById.forEach(function(_a,dataId){var storeObject=_a.storeObject,mergeTree=_a.mergeTree,fieldNodeSet=_a.fieldNodeSet;var entityRef=makeReference(dataId);if(mergeTree&&mergeTree.map.size){var applied=_this.applyMerges(mergeTree,entityRef,storeObject,context);if(isReference(applied)){return;}storeObject=applied;}if(__DEV__&&!context.overwrite){var fieldsWithSelectionSets_1=Object.create(null);fieldNodeSet.forEach(function(field){if(field.selectionSet){fieldsWithSelectionSets_1[field.name.value]=true;}});var hasSelectionSet_1=function hasSelectionSet_1(storeFieldName){return fieldsWithSelectionSets_1[fieldNameFromStoreName(storeFieldName)]===true;};var hasMergeFunction_1=function hasMergeFunction_1(storeFieldName){var childTree=mergeTree&&mergeTree.map.get(storeFieldName);return Boolean(childTree&&childTree.info&&childTree.info.merge);};Object.keys(storeObject).forEach(function(storeFieldName){if(hasSelectionSet_1(storeFieldName)&&!hasMergeFunction_1(storeFieldName)){warnAboutDataLoss(entityRef,storeObject,storeFieldName,context.store);}});}store.merge(dataId,storeObject);});store.retain(ref.__ref);return ref;};StoreWriter.prototype.processSelectionSet=function(_a){var _this=this;var dataId=_a.dataId,result=_a.result,selectionSet=_a.selectionSet,context=_a.context,mergeTree=_a.mergeTree;var policies=this.cache.policies;var incoming=Object.create(null);var typename=dataId&&policies.rootTypenamesById[dataId]||getTypenameFromResult(result,selectionSet,context.fragmentMap)||dataId&&context.store.get(dataId,\"__typename\");if(\"string\"===typeof typename){incoming.__typename=typename;}var readField=function readField(){var options=normalizeReadFieldOptions(arguments,incoming,context.variables);if(isReference(options.from)){var info=context.incomingById.get(options.from.__ref);if(info){var result_1=policies.readField(__assign(__assign({},options),{from:info.storeObject}),context);if(result_1!==void 0){return result_1;}}}return policies.readField(options,context);};var fieldNodeSet=new Set();this.flattenFields(selectionSet,result,context,typename).forEach(function(context,field){var _a;var resultFieldKey=resultKeyNameFromField(field);var value=result[resultFieldKey];fieldNodeSet.add(field);if(value!==void 0){var storeFieldName=policies.getStoreFieldName({typename:typename,fieldName:field.name.value,field:field,variables:context.variables});var childTree=getChildMergeTree(mergeTree,storeFieldName);var incomingValue=_this.processFieldValue(value,field,field.selectionSet?getContextFlavor(context,false,false):context,childTree);var childTypename=void 0;if(field.selectionSet&&(isReference(incomingValue)||storeValueIsStoreObject(incomingValue))){childTypename=readField(\"__typename\",incomingValue);}var merge=policies.getMergeFunction(typename,field.name.value,childTypename);if(merge){childTree.info={field:field,typename:typename,merge:merge};}else{maybeRecycleChildMergeTree(mergeTree,storeFieldName);}incoming=context.merge(incoming,(_a={},_a[storeFieldName]=incomingValue,_a));}else if(__DEV__&&!context.clientOnly&&!context.deferred&&!addTypenameToDocument.added(field)&&!policies.getReadFunction(typename,field.name.value)){__DEV__&&invariant.error(\"Missing field '\".concat(resultKeyNameFromField(field),\"' while writing result \").concat(JSON.stringify(result,null,2)).substring(0,1000));}});try{var _b=policies.identify(result,{typename:typename,selectionSet:selectionSet,fragmentMap:context.fragmentMap,storeObject:incoming,readField:readField}),id=_b[0],keyObject=_b[1];dataId=dataId||id;if(keyObject){incoming=context.merge(incoming,keyObject);}}catch(e){if(!dataId)throw e;}if(\"string\"===typeof dataId){var dataRef=makeReference(dataId);var sets=context.written[dataId]||(context.written[dataId]=[]);if(sets.indexOf(selectionSet)>=0)return dataRef;sets.push(selectionSet);if(this.reader&&this.reader.isFresh(result,dataRef,selectionSet,context)){return dataRef;}var previous_1=context.incomingById.get(dataId);if(previous_1){previous_1.storeObject=context.merge(previous_1.storeObject,incoming);previous_1.mergeTree=mergeMergeTrees(previous_1.mergeTree,mergeTree);fieldNodeSet.forEach(function(field){return previous_1.fieldNodeSet.add(field);});}else{context.incomingById.set(dataId,{storeObject:incoming,mergeTree:mergeTreeIsEmpty(mergeTree)?void 0:mergeTree,fieldNodeSet:fieldNodeSet});}return dataRef;}return incoming;};StoreWriter.prototype.processFieldValue=function(value,field,context,mergeTree){var _this=this;if(!field.selectionSet||value===null){return __DEV__?cloneDeep(value):value;}if(isArray(value)){return value.map(function(item,i){var value=_this.processFieldValue(item,field,context,getChildMergeTree(mergeTree,i));maybeRecycleChildMergeTree(mergeTree,i);return value;});}return this.processSelectionSet({result:value,selectionSet:field.selectionSet,context:context,mergeTree:mergeTree});};StoreWriter.prototype.flattenFields=function(selectionSet,result,context,typename){if(typename===void 0){typename=getTypenameFromResult(result,selectionSet,context.fragmentMap);}var fieldMap=new Map();var policies=this.cache.policies;var limitingTrie=new Trie(false);(function flatten(selectionSet,inheritedContext){var visitedNode=limitingTrie.lookup(selectionSet,inheritedContext.clientOnly,inheritedContext.deferred);if(visitedNode.visited)return;visitedNode.visited=true;selectionSet.selections.forEach(function(selection){if(!shouldInclude(selection,context.variables))return;var clientOnly=inheritedContext.clientOnly,deferred=inheritedContext.deferred;if(!(clientOnly&&deferred)&&isNonEmptyArray(selection.directives)){selection.directives.forEach(function(dir){var name=dir.name.value;if(name===\"client\")clientOnly=true;if(name===\"defer\"){var args=argumentsObjectFromField(dir,context.variables);if(!args||args.if!==false){deferred=true;}}});}if(isField(selection)){var existing=fieldMap.get(selection);if(existing){clientOnly=clientOnly&&existing.clientOnly;deferred=deferred&&existing.deferred;}fieldMap.set(selection,getContextFlavor(context,clientOnly,deferred));}else{var fragment=getFragmentFromSelection(selection,context.lookupFragment);if(!fragment&&selection.kind===Kind.FRAGMENT_SPREAD){throw __DEV__?new InvariantError(\"No fragment named \".concat(selection.name.value)):new InvariantError(8);}if(fragment&&policies.fragmentMatches(fragment,typename,result,context.variables)){flatten(fragment.selectionSet,getContextFlavor(context,clientOnly,deferred));}}});})(selectionSet,context);return fieldMap;};StoreWriter.prototype.applyMerges=function(mergeTree,existing,incoming,context,getStorageArgs){var _a;var _this=this;if(mergeTree.map.size&&!isReference(incoming)){var e_1=!isArray(incoming)&&(isReference(existing)||storeValueIsStoreObject(existing))?existing:void 0;var i_1=incoming;if(e_1&&!getStorageArgs){getStorageArgs=[isReference(e_1)?e_1.__ref:e_1];}var changedFields_1;var getValue_1=function getValue_1(from,name){return isArray(from)?typeof name===\"number\"?from[name]:void 0:context.store.getFieldValue(from,String(name));};mergeTree.map.forEach(function(childTree,storeFieldName){var eVal=getValue_1(e_1,storeFieldName);var iVal=getValue_1(i_1,storeFieldName);if(void 0===iVal)return;if(getStorageArgs){getStorageArgs.push(storeFieldName);}var aVal=_this.applyMerges(childTree,eVal,iVal,context,getStorageArgs);if(aVal!==iVal){changedFields_1=changedFields_1||new Map();changedFields_1.set(storeFieldName,aVal);}if(getStorageArgs){invariant(getStorageArgs.pop()===storeFieldName);}});if(changedFields_1){incoming=isArray(i_1)?i_1.slice(0):__assign({},i_1);changedFields_1.forEach(function(value,name){incoming[name]=value;});}}if(mergeTree.info){return this.cache.policies.runMergeFunction(existing,incoming,mergeTree.info,context,getStorageArgs&&(_a=context.store).getStorage.apply(_a,getStorageArgs));}return incoming;};return StoreWriter;}();export{StoreWriter};var emptyMergeTreePool=[];function getChildMergeTree(_a,name){var map=_a.map;if(!map.has(name)){map.set(name,emptyMergeTreePool.pop()||{map:new Map()});}return map.get(name);}function mergeMergeTrees(left,right){if(left===right||!right||mergeTreeIsEmpty(right))return left;if(!left||mergeTreeIsEmpty(left))return right;var info=left.info&&right.info?__assign(__assign({},left.info),right.info):left.info||right.info;var needToMergeMaps=left.map.size&&right.map.size;var map=needToMergeMaps?new Map():left.map.size?left.map:right.map;var merged={info:info,map:map};if(needToMergeMaps){var remainingRightKeys_1=new Set(right.map.keys());left.map.forEach(function(leftTree,key){merged.map.set(key,mergeMergeTrees(leftTree,right.map.get(key)));remainingRightKeys_1.delete(key);});remainingRightKeys_1.forEach(function(key){merged.map.set(key,mergeMergeTrees(right.map.get(key),left.map.get(key)));});}return merged;}function mergeTreeIsEmpty(tree){return!tree||!(tree.info||tree.map.size);}function maybeRecycleChildMergeTree(_a,name){var map=_a.map;var childTree=map.get(name);if(childTree&&mergeTreeIsEmpty(childTree)){emptyMergeTreePool.push(childTree);map.delete(name);}}var warnings=new Set();function warnAboutDataLoss(existingRef,incomingObj,storeFieldName,store){var getChild=function getChild(objOrRef){var child=store.getFieldValue(objOrRef,storeFieldName);return typeof child===\"object\"&&child;};var existing=getChild(existingRef);if(!existing)return;var incoming=getChild(incomingObj);if(!incoming)return;if(isReference(existing))return;if(equal(existing,incoming))return;if(Object.keys(existing).every(function(key){return store.getFieldValue(incoming,key)!==void 0;})){return;}var parentType=store.getFieldValue(existingRef,\"__typename\")||store.getFieldValue(incomingObj,\"__typename\");var fieldName=fieldNameFromStoreName(storeFieldName);var typeDotName=\"\".concat(parentType,\".\").concat(fieldName);if(warnings.has(typeDotName))return;warnings.add(typeDotName);var childTypenames=[];if(!isArray(existing)&&!isArray(incoming)){[existing,incoming].forEach(function(child){var typename=store.getFieldValue(child,\"__typename\");if(typeof typename===\"string\"&&!childTypenames.includes(typename)){childTypenames.push(typename);}});}__DEV__&&invariant.warn(\"Cache data may be lost when replacing the \".concat(fieldName,\" field of a \").concat(parentType,\" object.\\n\\nTo address this problem (which is not a bug in Apollo Client), \").concat(childTypenames.length?\"either ensure all objects of type \"+childTypenames.join(\" and \")+\" have an ID or a custom merge function, or \":\"\",\"define a custom merge function for the \").concat(typeDotName,\" field, so InMemoryCache can safely merge these objects:\\n\\n  existing: \").concat(JSON.stringify(existing).slice(0,1000),\"\\n  incoming: \").concat(JSON.stringify(incoming).slice(0,1000),\"\\n\\nFor more information about these options, please refer to the documentation:\\n\\n  * Ensuring entity objects have IDs: https://go.apollo.dev/c/generating-unique-identifiers\\n  * Defining custom merge functions: https://go.apollo.dev/c/merging-non-normalized-objects\\n\"));}","map":{"version":3,"mappings":"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","names":["invariant","InvariantError","equal","Trie","Kind","getFragmentFromSelection","getDefaultValues","getOperationDefinition","getTypenameFromResult","makeReference","isField","resultKeyNameFromField","isReference","shouldInclude","cloneDeep","addTypenameToDocument","isNonEmptyArray","argumentsObjectFromField","isArray","makeProcessedFieldsMerger","fieldNameFromStoreName","storeValueIsStoreObject","extractFragmentContext","canonicalStringify","normalizeReadFieldOptions","getContextFlavor","context","clientOnly","deferred","key","concat","flavored","flavors","get","set","__assign","cache","reader","fragments","StoreWriter","store","_a","query","result","dataId","variables","overwrite","operationDefinition","merger","written","Object","create","merge","existing","incoming","varString","incomingById","Map","ref","processSelectionSet","selectionSet","mergeTree","map","__DEV__","JSON","stringify","forEach","storeObject","fieldNodeSet","entityRef","size","applied","_this","applyMerges","fieldsWithSelectionSets_1","field","name","value","hasSelectionSet_1","storeFieldName","hasMergeFunction_1","childTree","Boolean","info","keys","warnAboutDataLoss","retain","__ref","policies","typename","rootTypenamesById","fragmentMap","__typename","readField","options","arguments","from","result_1","Set","flattenFields","resultFieldKey","add","getStoreFieldName","fieldName","getChildMergeTree","incomingValue","processFieldValue","childTypename","getMergeFunction","maybeRecycleChildMergeTree","added","getReadFunction","substring","identify","id","keyObject","e","dataRef","sets","indexOf","push","isFresh","previous_1","mergeMergeTrees","mergeTreeIsEmpty","item","i","fieldMap","limitingTrie","flatten","inheritedContext","visitedNode","lookup","visited","selections","selection","directives","dir","args","if","fragment","lookupFragment","kind","FRAGMENT_SPREAD","fragmentMatches","getStorageArgs","e_1","i_1","changedFields_1","getValue_1","getFieldValue","String","eVal","iVal","aVal","pop","slice","runMergeFunction","getStorage","apply","emptyMergeTreePool","has","left","right","needToMergeMaps","merged","remainingRightKeys_1","leftTree","delete","tree","warnings","existingRef","incomingObj","getChild","objOrRef","child","every","parentType","typeDotName","childTypenames","includes","join"],"sourceRoot":"","sources":["../../../src/cache/inmemory/writeToStore.ts"],"sourcesContent":["import { invariant, InvariantError } from '../../utilities/globals';\nimport { equal } from '@wry/equality';\nimport { Trie } from '@wry/trie';\nimport {\n  SelectionSetNode,\n  FieldNode,\n  Kind,\n} from 'graphql';\n\nimport {\n  FragmentMap,\n  FragmentMapFunction,\n  getFragmentFromSelection,\n  getDefaultValues,\n  getOperationDefinition,\n  getTypenameFromResult,\n  makeReference,\n  isField,\n  resultKeyNameFromField,\n  StoreValue,\n  StoreObject,\n  Reference,\n  isReference,\n  shouldInclude,\n  cloneDeep,\n  addTypenameToDocument,\n  isNonEmptyArray,\n  argumentsObjectFromField,\n} from '../../utilities';\n\nimport { NormalizedCache, ReadMergeModifyContext, MergeTree, InMemoryCacheConfig } from './types';\nimport { isArray, makeProcessedFieldsMerger, fieldNameFromStoreName, storeValueIsStoreObject, extractFragmentContext } from './helpers';\nimport { StoreReader } from './readFromStore';\nimport { InMemoryCache } from './inMemoryCache';\nimport { EntityStore } from './entityStore';\nimport { Cache } from '../../core';\nimport { canonicalStringify } from './object-canon';\nimport { normalizeReadFieldOptions } from './policies';\nimport { ReadFieldFunction } from '../core/types/common';\n\nexport interface WriteContext extends ReadMergeModifyContext {\n  readonly written: {\n    [dataId: string]: SelectionSetNode[];\n  };\n  readonly fragmentMap: FragmentMap;\n  lookupFragment: FragmentMapFunction;\n  // General-purpose deep-merge function for use during writes.\n  merge<T>(existing: T, incoming: T): T;\n  // If true, merge functions will be called with undefined existing data.\n  overwrite: boolean;\n  incomingById: Map<string, {\n    storeObject: StoreObject;\n    mergeTree?: MergeTree;\n    fieldNodeSet: Set<FieldNode>;\n  }>;\n  // Directive metadata for @client and @defer. We could use a bitfield for this\n  // information to save some space, and use that bitfield number as the keys in\n  // the context.flavors Map.\n  clientOnly: boolean;\n  deferred: boolean;\n  flavors: Map<string, FlavorableWriteContext>;\n};\n\ntype FlavorableWriteContext = Pick<\n  WriteContext,\n  | \"clientOnly\"\n  | \"deferred\"\n  | \"flavors\"\n>;\n\n// Since there are only four possible combinations of context.clientOnly and\n// context.deferred values, we should need at most four \"flavors\" of any given\n// WriteContext. To avoid creating multiple copies of the same context, we cache\n// the contexts in the context.flavors Map (shared by all flavors) according to\n// their clientOnly and deferred values (always in that order).\nfunction getContextFlavor<TContext extends FlavorableWriteContext>(\n  context: TContext,\n  clientOnly: TContext[\"clientOnly\"],\n  deferred: TContext[\"deferred\"],\n): TContext {\n  const key = `${clientOnly}${deferred}`;\n  let flavored = context.flavors.get(key);\n  if (!flavored) {\n    context.flavors.set(key, flavored = (\n      context.clientOnly === clientOnly &&\n      context.deferred === deferred\n    ) ? context : {\n      ...context,\n      clientOnly,\n      deferred,\n    });\n  }\n  return flavored as TContext;\n}\n\ninterface ProcessSelectionSetOptions {\n  dataId?: string,\n  result: Record<string, any>;\n  selectionSet: SelectionSetNode;\n  context: WriteContext;\n  mergeTree: MergeTree;\n}\n\nexport class StoreWriter {\n  constructor(\n    public readonly cache: InMemoryCache,\n    private reader?: StoreReader,\n    private fragments?: InMemoryCacheConfig[\"fragments\"],\n  ) {}\n\n  public writeToStore(store: NormalizedCache, {\n    query,\n    result,\n    dataId,\n    variables,\n    overwrite,\n  }: Cache.WriteOptions): Reference | undefined {\n    const operationDefinition = getOperationDefinition(query)!;\n    const merger = makeProcessedFieldsMerger();\n\n    variables = {\n      ...getDefaultValues(operationDefinition),\n      ...variables!,\n    };\n\n    const context: WriteContext = {\n      store,\n      written: Object.create(null),\n      merge<T>(existing: T, incoming: T) {\n        return merger.merge(existing, incoming) as T;\n      },\n      variables,\n      varString: canonicalStringify(variables),\n      ...extractFragmentContext(query, this.fragments),\n      overwrite: !!overwrite,\n      incomingById: new Map,\n      clientOnly: false,\n      deferred: false,\n      flavors: new Map,\n    };\n\n    const ref = this.processSelectionSet({\n      result: result || Object.create(null),\n      dataId,\n      selectionSet: operationDefinition.selectionSet,\n      mergeTree: { map: new Map },\n      context,\n    });\n\n    if (!isReference(ref)) {\n      throw new InvariantError(`Could not identify object ${JSON.stringify(result)}`);\n    }\n\n    // So far, the store has not been modified, so now it's time to process\n    // context.incomingById and merge those incoming fields into context.store.\n    context.incomingById.forEach(({ storeObject, mergeTree, fieldNodeSet }, dataId) => {\n      const entityRef = makeReference(dataId);\n\n      if (mergeTree && mergeTree.map.size) {\n        const applied = this.applyMerges(mergeTree, entityRef, storeObject, context);\n        if (isReference(applied)) {\n          // Assume References returned by applyMerges have already been merged\n          // into the store. See makeMergeObjectsFunction in policies.ts for an\n          // example of how this can happen.\n          return;\n        }\n        // Otherwise, applyMerges returned a StoreObject, whose fields we should\n        // merge into the store (see store.merge statement below).\n        storeObject = applied;\n      }\n\n      if (__DEV__ && !context.overwrite) {\n        const fieldsWithSelectionSets: Record<string, true> = Object.create(null);\n        fieldNodeSet.forEach(field => {\n          if (field.selectionSet) {\n            fieldsWithSelectionSets[field.name.value] = true;\n          }\n        });\n\n        const hasSelectionSet = (storeFieldName: string) =>\n          fieldsWithSelectionSets[\n            fieldNameFromStoreName(storeFieldName)\n          ] === true;\n\n        const hasMergeFunction = (storeFieldName: string) => {\n          const childTree = mergeTree && mergeTree.map.get(storeFieldName);\n          return Boolean(childTree && childTree.info && childTree.info.merge);\n        };\n\n        Object.keys(storeObject).forEach(storeFieldName => {\n          // If a merge function was defined for this field, trust that it\n          // did the right thing about (not) clobbering data. If the field\n          // has no selection set, it's a scalar field, so it doesn't need\n          // a merge function (even if it's an object, like JSON data).\n          if (hasSelectionSet(storeFieldName) &&\n              !hasMergeFunction(storeFieldName)) {\n            warnAboutDataLoss(\n              entityRef,\n              storeObject,\n              storeFieldName,\n              context.store,\n            );\n          }\n        });\n      }\n\n      store.merge(dataId, storeObject);\n    });\n\n    // Any IDs written explicitly to the cache will be retained as\n    // reachable root IDs for garbage collection purposes. Although this\n    // logic includes root IDs like ROOT_QUERY and ROOT_MUTATION, their\n    // retainment counts are effectively ignored because cache.gc() always\n    // includes them in its root ID set.\n    store.retain(ref.__ref);\n\n    return ref;\n  }\n\n  private processSelectionSet({\n    dataId,\n    result,\n    selectionSet,\n    context,\n    // This object allows processSelectionSet to report useful information\n    // to its callers without explicitly returning that information.\n    mergeTree,\n  }: ProcessSelectionSetOptions): StoreObject | Reference {\n    const { policies } = this.cache;\n\n    // This variable will be repeatedly updated using context.merge to\n    // accumulate all fields that need to be written into the store.\n    let incoming: StoreObject = Object.create(null);\n\n    // If typename was not passed in, infer it. Note that typename is\n    // always passed in for tricky-to-infer cases such as \"Query\" for\n    // ROOT_QUERY.\n    const typename: string | undefined =\n      (dataId && policies.rootTypenamesById[dataId]) ||\n      getTypenameFromResult(result, selectionSet, context.fragmentMap) ||\n      (dataId && context.store.get(dataId, \"__typename\") as string);\n\n    if (\"string\" === typeof typename) {\n      incoming.__typename = typename;\n    }\n\n    // This readField function will be passed as context.readField in the\n    // KeyFieldsContext object created within policies.identify (called below).\n    // In addition to reading from the existing context.store (thanks to the\n    // policies.readField(options, context) line at the very bottom), this\n    // version of readField can read from Reference objects that are currently\n    // pending in context.incomingById, which is important whenever keyFields\n    // need to be extracted from a child object that processSelectionSet has\n    // turned into a Reference.\n    const readField: ReadFieldFunction = function (this: void) {\n      const options = normalizeReadFieldOptions(\n        arguments,\n        incoming,\n        context.variables,\n      );\n\n      if (isReference(options.from)) {\n        const info = context.incomingById.get(options.from.__ref);\n        if (info) {\n          const result = policies.readField({\n            ...options,\n            from: info.storeObject\n          }, context);\n\n          if (result !== void 0) {\n            return result;\n          }\n        }\n      }\n\n      return policies.readField(options, context);\n    };\n\n    const fieldNodeSet = new Set<FieldNode>();\n\n    this.flattenFields(\n      selectionSet,\n      result,\n      // This WriteContext will be the default context value for fields returned\n      // by the flattenFields method, but some fields may be assigned a modified\n      // context, depending on the presence of @client and other directives.\n      context,\n      typename,\n    ).forEach((context, field) => {\n      const resultFieldKey = resultKeyNameFromField(field);\n      const value = result[resultFieldKey];\n\n      fieldNodeSet.add(field);\n\n      if (value !== void 0) {\n        const storeFieldName = policies.getStoreFieldName({\n          typename,\n          fieldName: field.name.value,\n          field,\n          variables: context.variables,\n        });\n\n        const childTree = getChildMergeTree(mergeTree, storeFieldName);\n\n        let incomingValue = this.processFieldValue(\n          value,\n          field,\n          // Reset context.clientOnly and context.deferred to their default\n          // values before processing nested selection sets.\n          field.selectionSet\n            ? getContextFlavor(context, false, false)\n            : context,\n          childTree,\n        );\n\n        // To determine if this field holds a child object with a merge function\n        // defined in its type policy (see PR #7070), we need to figure out the\n        // child object's __typename.\n        let childTypename: string | undefined;\n\n        // The field's value can be an object that has a __typename only if the\n        // field has a selection set. Otherwise incomingValue is scalar.\n        if (field.selectionSet &&\n            (isReference(incomingValue) ||\n             storeValueIsStoreObject(incomingValue))) {\n          childTypename = readField<string>(\"__typename\", incomingValue);\n        }\n\n        const merge = policies.getMergeFunction(\n          typename,\n          field.name.value,\n          childTypename,\n        );\n\n        if (merge) {\n          childTree.info = {\n            // TODO Check compatibility against any existing childTree.field?\n            field,\n            typename,\n            merge,\n          };\n        } else {\n          maybeRecycleChildMergeTree(mergeTree, storeFieldName);\n        }\n\n        incoming = context.merge(incoming, {\n          [storeFieldName]: incomingValue,\n        });\n\n      } else if (\n        __DEV__ &&\n        !context.clientOnly &&\n        !context.deferred &&\n        !addTypenameToDocument.added(field) &&\n        // If the field has a read function, it may be a synthetic field or\n        // provide a default value, so its absence from the written data should\n        // not be cause for alarm.\n        !policies.getReadFunction(typename, field.name.value)\n      ) {\n        invariant.error(`Missing field '${\n          resultKeyNameFromField(field)\n        }' while writing result ${\n          JSON.stringify(result, null, 2)\n        }`.substring(0, 1000));\n      }\n    });\n\n    // Identify the result object, even if dataId was already provided,\n    // since we always need keyObject below.\n    try {\n      const [id, keyObject] = policies.identify(result, {\n        typename,\n        selectionSet,\n        fragmentMap: context.fragmentMap,\n        storeObject: incoming,\n        readField,\n      });\n\n      // If dataId was not provided, fall back to the id just generated by\n      // policies.identify.\n      dataId = dataId || id;\n\n      // Write any key fields that were used during identification, even if\n      // they were not mentioned in the original query.\n      if (keyObject) {\n        // TODO Reverse the order of the arguments?\n        incoming = context.merge(incoming, keyObject);\n      }\n    } catch (e) {\n      // If dataId was provided, tolerate failure of policies.identify.\n      if (!dataId) throw e;\n    }\n\n    if (\"string\" === typeof dataId) {\n      const dataRef = makeReference(dataId);\n\n      // Avoid processing the same entity object using the same selection\n      // set more than once. We use an array instead of a Set since most\n      // entity IDs will be written using only one selection set, so the\n      // size of this array is likely to be very small, meaning indexOf is\n      // likely to be faster than Set.prototype.has.\n      const sets = context.written[dataId] || (context.written[dataId] = []);\n      if (sets.indexOf(selectionSet) >= 0) return dataRef;\n      sets.push(selectionSet);\n\n      // If we're about to write a result object into the store, but we\n      // happen to know that the exact same (===) result object would be\n      // returned if we were to reread the result with the same inputs,\n      // then we can skip the rest of the processSelectionSet work for\n      // this object, and immediately return a Reference to it.\n      if (this.reader && this.reader.isFresh(\n        result,\n        dataRef,\n        selectionSet,\n        context,\n      )) {\n        return dataRef;\n      }\n\n      const previous = context.incomingById.get(dataId);\n      if (previous) {\n        previous.storeObject = context.merge(previous.storeObject, incoming);\n        previous.mergeTree = mergeMergeTrees(previous.mergeTree, mergeTree);\n        fieldNodeSet.forEach(field => previous.fieldNodeSet.add(field));\n      } else {\n        context.incomingById.set(dataId, {\n          storeObject: incoming,\n          // Save a reference to mergeTree only if it is not empty, because\n          // empty MergeTrees may be recycled by maybeRecycleChildMergeTree and\n          // reused for entirely different parts of the result tree.\n          mergeTree: mergeTreeIsEmpty(mergeTree) ? void 0 : mergeTree,\n          fieldNodeSet,\n        });\n      }\n\n      return dataRef;\n    }\n\n    return incoming;\n  }\n\n  private processFieldValue(\n    value: any,\n    field: FieldNode,\n    context: WriteContext,\n    mergeTree: MergeTree,\n  ): StoreValue {\n    if (!field.selectionSet || value === null) {\n      // In development, we need to clone scalar values so that they can be\n      // safely frozen with maybeDeepFreeze in readFromStore.ts. In production,\n      // it's cheaper to store the scalar values directly in the cache.\n      return __DEV__ ? cloneDeep(value) : value;\n    }\n\n    if (isArray(value)) {\n      return value.map((item, i) => {\n        const value = this.processFieldValue(\n          item, field, context, getChildMergeTree(mergeTree, i));\n        maybeRecycleChildMergeTree(mergeTree, i);\n        return value;\n      });\n    }\n\n    return this.processSelectionSet({\n      result: value,\n      selectionSet: field.selectionSet,\n      context,\n      mergeTree,\n    });\n  }\n\n  // Implements https://spec.graphql.org/draft/#sec-Field-Collection, but with\n  // some additions for tracking @client and @defer directives.\n  private flattenFields<TContext extends Pick<\n    WriteContext,\n    | \"clientOnly\"\n    | \"deferred\"\n    | \"flavors\"\n    | \"fragmentMap\"\n    | \"lookupFragment\"\n    | \"variables\"\n  >>(\n    selectionSet: SelectionSetNode,\n    result: Record<string, any>,\n    context: TContext,\n    typename = getTypenameFromResult(result, selectionSet, context.fragmentMap),\n  ): Map<FieldNode, TContext> {\n    const fieldMap = new Map<FieldNode, TContext>();\n    const { policies } = this.cache;\n\n    const limitingTrie = new Trie<{\n      // Tracks whether (selectionSet, clientOnly, deferred) has been flattened\n      // before. The GraphQL specification only uses the fragment name for\n      // skipping previously visited fragments, but the top-level fragment\n      // selection set corresponds 1:1 with the fagment name (and is slightly\n      // easier too work with), and we need to consider clientOnly and deferred\n      // values as well, potentially revisiting selection sets that were\n      // previously visited with different inherited configurations of those\n      // directives.\n      visited?: boolean;\n    }>(false); // No need for WeakMap, since limitingTrie does not escape.\n\n    (function flatten(\n      this: void,\n      selectionSet: SelectionSetNode,\n      inheritedContext: TContext,\n    ) {\n      const visitedNode = limitingTrie.lookup(\n        selectionSet,\n        // Because we take inheritedClientOnly and inheritedDeferred into\n        // consideration here (in addition to selectionSet), it's possible for\n        // the same selection set to be flattened more than once, if it appears\n        // in the query with different @client and/or @directive configurations.\n        inheritedContext.clientOnly,\n        inheritedContext.deferred,\n      );\n      if (visitedNode.visited) return;\n      visitedNode.visited = true;\n\n      selectionSet.selections.forEach(selection => {\n        if (!shouldInclude(selection, context.variables)) return;\n\n        let { clientOnly, deferred } = inheritedContext;\n        if (\n          // Since the presence of @client or @defer on this field can only\n          // cause clientOnly or deferred to become true, we can skip the\n          // forEach loop if both clientOnly and deferred are already true.\n          !(clientOnly && deferred) &&\n          isNonEmptyArray(selection.directives)\n        ) {\n          selection.directives.forEach(dir => {\n            const name = dir.name.value;\n            if (name === \"client\") clientOnly = true;\n            if (name === \"defer\") {\n              const args = argumentsObjectFromField(dir, context.variables);\n              // The @defer directive takes an optional args.if boolean\n              // argument, similar to @include(if: boolean). Note that\n              // @defer(if: false) does not make context.deferred false, but\n              // instead behaves as if there was no @defer directive.\n              if (!args || (args as { if?: boolean }).if !== false) {\n                deferred = true;\n              }\n              // TODO In the future, we may want to record args.label using\n              // context.deferred, if a label is specified.\n            }\n          });\n        }\n\n        if (isField(selection)) {\n          const existing = fieldMap.get(selection);\n          if (existing) {\n            // If this field has been visited along another recursive path\n            // before, the final context should have clientOnly or deferred set\n            // to true only if *all* paths have the directive (hence the &&).\n            clientOnly = clientOnly && existing.clientOnly;\n            deferred = deferred && existing.deferred;\n          }\n\n          fieldMap.set(\n            selection,\n            getContextFlavor(context, clientOnly, deferred),\n          );\n\n        } else {\n          const fragment = getFragmentFromSelection(\n            selection,\n            context.lookupFragment,\n          );\n\n          if (!fragment && selection.kind === Kind.FRAGMENT_SPREAD) {\n            throw new InvariantError(`No fragment named ${selection.name.value}`);\n          }\n\n          if (fragment &&\n              policies.fragmentMatches(\n                fragment, typename, result, context.variables)) {\n\n            flatten(\n              fragment.selectionSet,\n              getContextFlavor(context, clientOnly, deferred),\n            );\n          }\n        }\n      });\n    })(selectionSet, context);\n\n    return fieldMap;\n  }\n\n  private applyMerges<T extends StoreValue>(\n    mergeTree: MergeTree,\n    existing: StoreValue,\n    incoming: T,\n    context: WriteContext,\n    getStorageArgs?: Parameters<EntityStore[\"getStorage\"]>,\n  ): T | Reference {\n    if (mergeTree.map.size && !isReference(incoming)) {\n      const e: StoreObject | Reference | undefined = (\n        // Items in the same position in different arrays are not\n        // necessarily related to each other, so when incoming is an array\n        // we process its elements as if there was no existing data.\n        !isArray(incoming) &&\n        // Likewise, existing must be either a Reference or a StoreObject\n        // in order for its fields to be safe to merge with the fields of\n        // the incoming object.\n        (isReference(existing) || storeValueIsStoreObject(existing))\n      ) ? existing : void 0;\n\n      // This narrowing is implied by mergeTree.map.size > 0 and\n      // !isReference(incoming), though TypeScript understandably cannot\n      // hope to infer this type.\n      const i = incoming as StoreObject | StoreValue[];\n\n      // The options.storage objects provided to read and merge functions\n      // are derived from the identity of the parent object plus a\n      // sequence of storeFieldName strings/numbers identifying the nested\n      // field name path of each field value to be merged.\n      if (e && !getStorageArgs) {\n        getStorageArgs = [isReference(e) ? e.__ref : e];\n      }\n\n      // It's possible that applying merge functions to this subtree will\n      // not change the incoming data, so this variable tracks the fields\n      // that did change, so we can create a new incoming object when (and\n      // only when) at least one incoming field has changed. We use a Map\n      // to preserve the type of numeric keys.\n      let changedFields: Map<string | number, StoreValue> | undefined;\n\n      const getValue = (\n        from: typeof e | typeof i,\n        name: string | number,\n      ): StoreValue => {\n        return isArray(from)\n          ? (typeof name === \"number\" ? from[name] : void 0)\n          : context.store.getFieldValue(from, String(name))\n      };\n\n      mergeTree.map.forEach((childTree, storeFieldName) => {\n        const eVal = getValue(e, storeFieldName);\n        const iVal = getValue(i, storeFieldName);\n        // If we have no incoming data, leave any existing data untouched.\n        if (void 0 === iVal) return;\n        if (getStorageArgs) {\n          getStorageArgs.push(storeFieldName);\n        }\n        const aVal = this.applyMerges(\n          childTree,\n          eVal,\n          iVal,\n          context,\n          getStorageArgs,\n        );\n        if (aVal !== iVal) {\n          changedFields = changedFields || new Map;\n          changedFields.set(storeFieldName, aVal);\n        }\n        if (getStorageArgs) {\n          invariant(getStorageArgs.pop() === storeFieldName);\n        }\n      });\n\n      if (changedFields) {\n        // Shallow clone i so we can add changed fields to it.\n        incoming = (isArray(i) ? i.slice(0) : { ...i }) as T;\n        changedFields.forEach((value, name) => {\n          (incoming as any)[name] = value;\n        });\n      }\n    }\n\n    if (mergeTree.info) {\n      return this.cache.policies.runMergeFunction(\n        existing,\n        incoming,\n        mergeTree.info,\n        context,\n        getStorageArgs && context.store.getStorage(...getStorageArgs),\n      );\n    }\n\n    return incoming;\n  }\n}\n\nconst emptyMergeTreePool: MergeTree[] = [];\n\nfunction getChildMergeTree(\n  { map }: MergeTree,\n  name: string | number,\n): MergeTree {\n  if (!map.has(name)) {\n    map.set(name, emptyMergeTreePool.pop() || { map: new Map });\n  }\n  return map.get(name)!;\n}\n\nfunction mergeMergeTrees(\n  left: MergeTree | undefined,\n  right: MergeTree | undefined,\n): MergeTree {\n  if (left === right || !right || mergeTreeIsEmpty(right)) return left!;\n  if (!left || mergeTreeIsEmpty(left)) return right;\n\n  const info = left.info && right.info ? {\n    ...left.info,\n    ...right.info,\n  } : left.info || right.info;\n\n  const needToMergeMaps = left.map.size && right.map.size;\n  const map = needToMergeMaps ? new Map :\n    left.map.size ? left.map : right.map;\n\n  const merged = { info, map };\n\n  if (needToMergeMaps) {\n    const remainingRightKeys = new Set(right.map.keys());\n\n    left.map.forEach((leftTree, key) => {\n      merged.map.set(\n        key,\n        mergeMergeTrees(leftTree, right.map.get(key)),\n      );\n      remainingRightKeys.delete(key);\n    });\n\n    remainingRightKeys.forEach(key => {\n      merged.map.set(\n        key,\n        mergeMergeTrees(\n          right.map.get(key),\n          left.map.get(key),\n        ),\n      );\n    });\n  }\n\n  return merged;\n}\n\nfunction mergeTreeIsEmpty(tree: MergeTree | undefined): boolean {\n  return !tree || !(tree.info || tree.map.size);\n}\n\nfunction maybeRecycleChildMergeTree(\n  { map }: MergeTree,\n  name: string | number,\n) {\n  const childTree = map.get(name);\n  if (childTree && mergeTreeIsEmpty(childTree)) {\n    emptyMergeTreePool.push(childTree);\n    map.delete(name);\n  }\n}\n\nconst warnings = new Set<string>();\n\n// Note that this function is unused in production, and thus should be\n// pruned by any well-configured minifier.\nfunction warnAboutDataLoss(\n  existingRef: Reference,\n  incomingObj: StoreObject,\n  storeFieldName: string,\n  store: NormalizedCache,\n) {\n  const getChild = (objOrRef: StoreObject | Reference): StoreObject | false => {\n    const child = store.getFieldValue<StoreObject>(objOrRef, storeFieldName);\n    return typeof child === \"object\" && child;\n  };\n\n  const existing = getChild(existingRef);\n  if (!existing) return;\n\n  const incoming = getChild(incomingObj);\n  if (!incoming) return;\n\n  // It's always safe to replace a reference, since it refers to data\n  // safely stored elsewhere.\n  if (isReference(existing)) return;\n\n  // If the values are structurally equivalent, we do not need to worry\n  // about incoming replacing existing.\n  if (equal(existing, incoming)) return;\n\n  // If we're replacing every key of the existing object, then the\n  // existing data would be overwritten even if the objects were\n  // normalized, so warning would not be helpful here.\n  if (Object.keys(existing).every(\n    key => store.getFieldValue(incoming, key) !== void 0)) {\n    return;\n  }\n\n  const parentType =\n    store.getFieldValue<string>(existingRef, \"__typename\") ||\n    store.getFieldValue<string>(incomingObj, \"__typename\");\n  const fieldName = fieldNameFromStoreName(storeFieldName);\n  const typeDotName = `${parentType}.${fieldName}`;\n  // Avoid warning more than once for the same type and field name.\n  if (warnings.has(typeDotName)) return;\n  warnings.add(typeDotName);\n\n  const childTypenames: string[] = [];\n  // Arrays do not have __typename fields, and always need a custom merge\n  // function, even if their elements are normalized entities.\n  if (!isArray(existing) &&\n      !isArray(incoming)) {\n    [existing, incoming].forEach(child => {\n      const typename = store.getFieldValue(child, \"__typename\");\n      if (typeof typename === \"string\" &&\n          !childTypenames.includes(typename)) {\n        childTypenames.push(typename);\n      }\n    });\n  }\n\n  invariant.warn(\n`Cache data may be lost when replacing the ${fieldName} field of a ${parentType} object.\n\nTo address this problem (which is not a bug in Apollo Client), ${\n  childTypenames.length\n    ? \"either ensure all objects of type \" +\n        childTypenames.join(\" and \") + \" have an ID or a custom merge function, or \"\n    : \"\"\n}define a custom merge function for the ${\n  typeDotName\n} field, so InMemoryCache can safely merge these objects:\n\n  existing: ${JSON.stringify(existing).slice(0, 1000)}\n  incoming: ${JSON.stringify(incoming).slice(0, 1000)}\n\nFor more information about these options, please refer to the documentation:\n\n  * Ensuring entity objects have IDs: https://go.apollo.dev/c/generating-unique-identifiers\n  * Defining custom merge functions: https://go.apollo.dev/c/merging-non-normalized-objects\n`);\n}\n"]},"metadata":{},"sourceType":"module"}