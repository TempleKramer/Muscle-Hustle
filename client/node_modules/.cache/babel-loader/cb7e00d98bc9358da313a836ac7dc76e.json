{"ast":null,"code":"import{__assign,__rest as __rest_1,__spreadArray}from\"tslib\";import{__rest}from\"tslib\";import{mergeDeep}from\"../common/mergeDeep.js\";export function concatPagination(keyArgs){if(keyArgs===void 0){keyArgs=false;}return{keyArgs:keyArgs,merge:function merge(existing,incoming){return existing?__spreadArray(__spreadArray([],existing,true),incoming,true):incoming;}};}export function offsetLimitPagination(keyArgs){if(keyArgs===void 0){keyArgs=false;}return{keyArgs:keyArgs,merge:function merge(existing,incoming,_a){var args=_a.args;var merged=existing?existing.slice(0):[];if(incoming){if(args){var _b=args.offset,offset=_b===void 0?0:_b;for(var i=0;i<incoming.length;++i){merged[offset+i]=incoming[i];}}else{merged.push.apply(merged,incoming);}}return merged;}};}export function relayStylePagination(keyArgs){if(keyArgs===void 0){keyArgs=false;}return{keyArgs:keyArgs,read:function read(existing,_a){var canRead=_a.canRead,readField=_a.readField;if(!existing)return existing;var edges=[];var firstEdgeCursor=\"\";var lastEdgeCursor=\"\";existing.edges.forEach(function(edge){if(canRead(readField(\"node\",edge))){edges.push(edge);if(edge.cursor){firstEdgeCursor=firstEdgeCursor||edge.cursor||\"\";lastEdgeCursor=edge.cursor||lastEdgeCursor;}}});var _b=existing.pageInfo||{},startCursor=_b.startCursor,endCursor=_b.endCursor;return __assign(__assign({},getExtras(existing)),{edges:edges,pageInfo:__assign(__assign({},existing.pageInfo),{startCursor:startCursor||firstEdgeCursor,endCursor:endCursor||lastEdgeCursor})});},merge:function merge(existing,incoming,_a){var args=_a.args,isReference=_a.isReference,readField=_a.readField;if(!existing){existing=makeEmptyData();}if(!incoming){return existing;}var incomingEdges=incoming.edges?incoming.edges.map(function(edge){if(isReference(edge=__assign({},edge))){edge.cursor=readField(\"cursor\",edge);}return edge;}):[];if(incoming.pageInfo){var pageInfo_1=incoming.pageInfo;var startCursor=pageInfo_1.startCursor,endCursor=pageInfo_1.endCursor;var firstEdge=incomingEdges[0];var lastEdge=incomingEdges[incomingEdges.length-1];if(firstEdge&&startCursor){firstEdge.cursor=startCursor;}if(lastEdge&&endCursor){lastEdge.cursor=endCursor;}var firstCursor=firstEdge&&firstEdge.cursor;if(firstCursor&&!startCursor){incoming=mergeDeep(incoming,{pageInfo:{startCursor:firstCursor}});}var lastCursor=lastEdge&&lastEdge.cursor;if(lastCursor&&!endCursor){incoming=mergeDeep(incoming,{pageInfo:{endCursor:lastCursor}});}}var prefix=existing.edges;var suffix=[];if(args&&args.after){var index=prefix.findIndex(function(edge){return edge.cursor===args.after;});if(index>=0){prefix=prefix.slice(0,index+1);}}else if(args&&args.before){var index=prefix.findIndex(function(edge){return edge.cursor===args.before;});suffix=index<0?prefix:prefix.slice(index);prefix=[];}else if(incoming.edges){prefix=[];}var edges=__spreadArray(__spreadArray(__spreadArray([],prefix,true),incomingEdges,true),suffix,true);var pageInfo=__assign(__assign({},incoming.pageInfo),existing.pageInfo);if(incoming.pageInfo){var _b=incoming.pageInfo,hasPreviousPage=_b.hasPreviousPage,hasNextPage=_b.hasNextPage,startCursor=_b.startCursor,endCursor=_b.endCursor,extras=__rest_1(_b,[\"hasPreviousPage\",\"hasNextPage\",\"startCursor\",\"endCursor\"]);Object.assign(pageInfo,extras);if(!prefix.length){if(void 0!==hasPreviousPage)pageInfo.hasPreviousPage=hasPreviousPage;if(void 0!==startCursor)pageInfo.startCursor=startCursor;}if(!suffix.length){if(void 0!==hasNextPage)pageInfo.hasNextPage=hasNextPage;if(void 0!==endCursor)pageInfo.endCursor=endCursor;}}return __assign(__assign(__assign({},getExtras(existing)),getExtras(incoming)),{edges:edges,pageInfo:pageInfo});}};}var getExtras=function getExtras(obj){return __rest(obj,notExtras);};var notExtras=[\"edges\",\"pageInfo\"];function makeEmptyData(){return{edges:[],pageInfo:{hasPreviousPage:false,hasNextPage:true,startCursor:\"\",endCursor:\"\"}};}","map":{"version":3,"mappings":"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","names":["__rest","mergeDeep","concatPagination","keyArgs","merge","existing","incoming","__spreadArray","offsetLimitPagination","_a","args","merged","slice","_b","i","length","offset","push","apply","relayStylePagination","read","canRead","readField","edges","firstEdgeCursor","lastEdgeCursor","forEach","edge","cursor","pageInfo","startCursor","endCursor","getExtras","isReference","makeEmptyData","incomingEdges","map","pageInfo_1","firstEdge","lastEdge","firstCursor","lastCursor","prefix","suffix","after","index","findIndex","before","hasPreviousPage","hasNextPage","extras","Object","assign","obj","notExtras"],"sourceRoot":"","sources":["../../../src/utilities/policies/pagination.ts"],"sourcesContent":["import { __rest } from \"tslib\";\n\nimport { FieldPolicy, Reference } from '../../cache';\nimport { mergeDeep } from '../common/mergeDeep';\n\ntype KeyArgs = FieldPolicy<any>[\"keyArgs\"];\n\n// A very basic pagination field policy that always concatenates new\n// results onto the existing array, without examining options.args.\nexport function concatPagination<T = Reference>(\n  keyArgs: KeyArgs = false,\n): FieldPolicy<T[]> {\n  return {\n    keyArgs,\n    merge(existing, incoming) {\n      return existing ? [\n        ...existing,\n        ...incoming,\n      ] : incoming;\n    },\n  };\n}\n\n// A basic field policy that uses options.args.{offset,limit} to splice\n// the incoming data into the existing array. If your arguments are called\n// something different (like args.{start,count}), feel free to copy/paste\n// this implementation and make the appropriate changes.\nexport function offsetLimitPagination<T = Reference>(\n  keyArgs: KeyArgs = false,\n): FieldPolicy<T[]> {\n  return {\n    keyArgs,\n    merge(existing, incoming, { args }) {\n      const merged = existing ? existing.slice(0) : [];\n\n      if (incoming) {\n        if (args) {\n          // Assume an offset of 0 if args.offset omitted.\n          const { offset = 0 } = args;\n          for (let i = 0; i < incoming.length; ++i) {\n            merged[offset + i] = incoming[i];\n          }\n        } else {\n          // It's unusual (probably a mistake) for a paginated field not\n          // to receive any arguments, so you might prefer to throw an\n          // exception here, instead of recovering by appending incoming\n          // onto the existing array.\n          merged.push.apply(merged, incoming);\n        }\n      }\n\n      return merged;\n    },\n  };\n}\n\n// Whether TRelayEdge<TNode> is a normalized Reference or a non-normalized\n// object, it needs a .cursor property where the relayStylePagination\n// merge function can store cursor strings taken from pageInfo. Storing an\n// extra reference.cursor property should be safe, and is easier than\n// attempting to update the cursor field of the normalized StoreObject\n// that the reference refers to, or managing edge wrapper objects\n// (something I attempted in #7023, but abandoned because of #7088).\nexport type TRelayEdge<TNode> = {\n  cursor?: string;\n  node: TNode;\n} | (Reference & { cursor?: string });\n\nexport type TRelayPageInfo = {\n  hasPreviousPage: boolean;\n  hasNextPage: boolean;\n  startCursor: string;\n  endCursor: string;\n};\n\nexport type TExistingRelay<TNode> = Readonly<{\n  edges: TRelayEdge<TNode>[];\n  pageInfo: TRelayPageInfo;\n}>;\n\nexport type TIncomingRelay<TNode> = {\n  edges?: TRelayEdge<TNode>[];\n  pageInfo?: TRelayPageInfo;\n};\n\nexport type RelayFieldPolicy<TNode> = FieldPolicy<\n  TExistingRelay<TNode> | null,\n  TIncomingRelay<TNode> | null,\n  TIncomingRelay<TNode> | null\n>;\n\n// As proof of the flexibility of field policies, this function generates\n// one that handles Relay-style pagination, without Apollo Client knowing\n// anything about connections, edges, cursors, or pageInfo objects.\nexport function relayStylePagination<TNode = Reference>(\n  keyArgs: KeyArgs = false,\n): RelayFieldPolicy<TNode> {\n  return {\n    keyArgs,\n\n    read(existing, { canRead, readField }) {\n      if (!existing) return existing;\n\n      const edges: TRelayEdge<TNode>[] = [];\n      let firstEdgeCursor = \"\";\n      let lastEdgeCursor = \"\";\n      existing.edges.forEach(edge => {\n        // Edges themselves could be Reference objects, so it's important\n        // to use readField to access the edge.edge.node property.\n        if (canRead(readField(\"node\", edge))) {\n          edges.push(edge);\n          if (edge.cursor) {\n            firstEdgeCursor = firstEdgeCursor || edge.cursor || \"\";\n            lastEdgeCursor = edge.cursor || lastEdgeCursor;\n          }\n        }\n      });\n\n      const {\n        startCursor,\n        endCursor,\n      } = existing.pageInfo || {};\n\n      return {\n        // Some implementations return additional Connection fields, such\n        // as existing.totalCount. These fields are saved by the merge\n        // function, so the read function should also preserve them.\n        ...getExtras(existing),\n        edges,\n        pageInfo: {\n          ...existing.pageInfo,\n          // If existing.pageInfo.{start,end}Cursor are undefined or \"\", default\n          // to firstEdgeCursor and/or lastEdgeCursor.\n          startCursor: startCursor || firstEdgeCursor,\n          endCursor: endCursor || lastEdgeCursor,\n        },\n      };\n    },\n\n    merge(existing, incoming, { args, isReference, readField }) {\n      if (!existing) {\n        existing = makeEmptyData();\n      }\n\n      if (!incoming) {\n        return existing;\n      }\n\n      const incomingEdges = incoming.edges ? incoming.edges.map(edge => {\n        if (isReference(edge = { ...edge })) {\n          // In case edge is a Reference, we read out its cursor field and\n          // store it as an extra property of the Reference object.\n          edge.cursor = readField<string>(\"cursor\", edge);\n        }\n        return edge;\n      }) : [];\n\n      if (incoming.pageInfo) {\n        const { pageInfo } = incoming;\n        const { startCursor, endCursor } = pageInfo;\n        const firstEdge = incomingEdges[0];\n        const lastEdge = incomingEdges[incomingEdges.length - 1];\n        // In case we did not request the cursor field for edges in this\n        // query, we can still infer cursors from pageInfo.\n        if (firstEdge && startCursor) {\n          firstEdge.cursor = startCursor;\n        }\n        if (lastEdge && endCursor) {\n          lastEdge.cursor = endCursor;\n        }\n        // Cursors can also come from edges, so we default\n        // pageInfo.{start,end}Cursor to {first,last}Edge.cursor.\n        const firstCursor = firstEdge && firstEdge.cursor;\n        if (firstCursor && !startCursor) {\n          incoming = mergeDeep(incoming, {\n            pageInfo: {\n              startCursor: firstCursor,\n            },\n          });\n        }\n        const lastCursor = lastEdge && lastEdge.cursor;\n        if (lastCursor && !endCursor) {\n          incoming = mergeDeep(incoming, {\n            pageInfo: {\n              endCursor: lastCursor,\n            },\n          });\n        }\n      }\n\n      let prefix = existing.edges;\n      let suffix: typeof prefix = [];\n\n      if (args && args.after) {\n        // This comparison does not need to use readField(\"cursor\", edge),\n        // because we stored the cursor field of any Reference edges as an\n        // extra property of the Reference object.\n        const index = prefix.findIndex(edge => edge.cursor === args.after);\n        if (index >= 0) {\n          prefix = prefix.slice(0, index + 1);\n          // suffix = []; // already true\n        }\n      } else if (args && args.before) {\n        const index = prefix.findIndex(edge => edge.cursor === args.before);\n        suffix = index < 0 ? prefix : prefix.slice(index);\n        prefix = [];\n      } else if (incoming.edges) {\n        // If we have neither args.after nor args.before, the incoming\n        // edges cannot be spliced into the existing edges, so they must\n        // replace the existing edges. See #6592 for a motivating example.\n        prefix = [];\n      }\n\n      const edges = [\n        ...prefix,\n        ...incomingEdges,\n        ...suffix,\n      ];\n\n      const pageInfo: TRelayPageInfo = {\n        // The ordering of these two ...spreads may be surprising, but it\n        // makes sense because we want to combine PageInfo properties with a\n        // preference for existing values, *unless* the existing values are\n        // overridden by the logic below, which is permitted only when the\n        // incoming page falls at the beginning or end of the data.\n        ...incoming.pageInfo,\n        ...existing.pageInfo,\n      };\n\n      if (incoming.pageInfo) {\n        const {\n          hasPreviousPage, hasNextPage,\n          startCursor, endCursor,\n          ...extras\n        } = incoming.pageInfo;\n\n        // If incoming.pageInfo had any extra non-standard properties,\n        // assume they should take precedence over any existing properties\n        // of the same name, regardless of where this page falls with\n        // respect to the existing data.\n        Object.assign(pageInfo, extras);\n\n        // Keep existing.pageInfo.has{Previous,Next}Page unless the\n        // placement of the incoming edges means incoming.hasPreviousPage\n        // or incoming.hasNextPage should become the new values for those\n        // properties in existing.pageInfo. Note that these updates are\n        // only permitted when the beginning or end of the incoming page\n        // coincides with the beginning or end of the existing data, as\n        // determined using prefix.length and suffix.length.\n        if (!prefix.length) {\n          if (void 0 !== hasPreviousPage) pageInfo.hasPreviousPage = hasPreviousPage;\n          if (void 0 !== startCursor) pageInfo.startCursor = startCursor;\n        }\n        if (!suffix.length) {\n          if (void 0 !== hasNextPage) pageInfo.hasNextPage = hasNextPage;\n          if (void 0 !== endCursor) pageInfo.endCursor = endCursor;\n        }\n      }\n\n      return {\n        ...getExtras(existing),\n        ...getExtras(incoming),\n        edges,\n        pageInfo,\n      };\n    },\n  };\n}\n\n// Returns any unrecognized properties of the given object.\nconst getExtras = (obj: Record<string, any>) => __rest(obj, notExtras);\nconst notExtras = [\"edges\", \"pageInfo\"];\n\nfunction makeEmptyData(): TExistingRelay<any> {\n  return {\n    edges: [],\n    pageInfo: {\n      hasPreviousPage: false,\n      hasNextPage: true,\n      startCursor: \"\",\n      endCursor: \"\",\n    },\n  };\n}\n"]},"metadata":{},"sourceType":"module"}