{"ast":null,"code":"import{__assign}from\"tslib\";import{useCallback,useMemo,useRef}from'react';import{mergeOptions}from\"../../utilities/index.js\";import{useInternalState}from\"./useQuery.js\";import{useApolloClient}from\"./useApolloClient.js\";var EAGER_METHODS=['refetch','reobserve','fetchMore','updateQuery','startPolling','subscribeToMore'];export function useLazyQuery(query,options){var internalState=useInternalState(useApolloClient(options&&options.client),query);var execOptionsRef=useRef();var merged=execOptionsRef.current?mergeOptions(options,execOptionsRef.current):options;var useQueryResult=internalState.useQuery(__assign(__assign({},merged),{skip:!execOptionsRef.current}));var initialFetchPolicy=useQueryResult.observable.options.initialFetchPolicy||internalState.getDefaultFetchPolicy();var result=Object.assign(useQueryResult,{called:!!execOptionsRef.current});var eagerMethods=useMemo(function(){var eagerMethods={};var _loop_1=function _loop_1(key){var method=result[key];eagerMethods[key]=function(){if(!execOptionsRef.current){execOptionsRef.current=Object.create(null);internalState.forceUpdate();}return method.apply(this,arguments);};};for(var _i=0,EAGER_METHODS_1=EAGER_METHODS;_i<EAGER_METHODS_1.length;_i++){var key=EAGER_METHODS_1[_i];_loop_1(key);}return eagerMethods;},[]);Object.assign(result,eagerMethods);var execute=useCallback(function(executeOptions){execOptionsRef.current=executeOptions?__assign(__assign({},executeOptions),{fetchPolicy:executeOptions.fetchPolicy||initialFetchPolicy}):{fetchPolicy:initialFetchPolicy};var promise=internalState.asyncUpdate().then(function(queryResult){return Object.assign(queryResult,eagerMethods);});promise.catch(function(){});return promise;},[]);return[execute,result];}","map":{"version":3,"mappings":"4BAEA,OAASA,WAAT,CAAsBC,OAAtB,CAA+BC,MAA/B,KAA6C,OAA7C,CAGA,OAASC,YAAT,KAA6B,0BAA7B,CAMA,OAASC,gBAAT,KAAiC,eAAjC,CACA,OAASC,eAAT,KAAgC,sBAAhC,CAIA,GAAMC,cAAa,CAAG,CACpB,SADoB,CAEpB,WAFoB,CAGpB,WAHoB,CAIpB,aAJoB,CAKpB,cALoB,CAMpB,iBANoB,CAAtB,CASA,MAAM,SAAUC,aAAV,CACJC,KADI,CAEJC,OAFI,CAE6C,CAEjD,GAAMC,cAAa,CAAGN,gBAAgB,CACpCC,eAAe,CAACI,OAAO,EAAIA,OAAO,CAACE,MAApB,CADqB,CAEpCH,KAFoC,CAAtC,CAKA,GAAMI,eAAc,CAAGV,MAAM,EAA7B,CACA,GAAMW,OAAM,CAAGD,cAAc,CAACE,OAAf,CACXX,YAAY,CAACM,OAAD,CAAUG,cAAc,CAACE,OAAzB,CADD,CAEXL,OAFJ,CAIA,GAAMM,eAAc,CAAGL,aAAa,CAACM,QAAd,CAAsBC,qBACxCJ,MADwC,EAClC,CACTK,IAAI,CAAE,CAACN,cAAc,CAACE,OADb,CADkC,CAAtB,CAAvB,CAKA,GAAMK,mBAAkB,CACtBJ,cAAc,CAACK,UAAf,CAA0BX,OAA1B,CAAkCU,kBAAlC,EACAT,aAAa,CAACW,qBAAd,EAFF,CAIA,GAAMC,OAAM,CACVC,MAAM,CAACC,MAAP,CAAcT,cAAd,CAA8B,CAC5BU,MAAM,CAAE,CAAC,CAACb,cAAc,CAACE,OADG,CAA9B,CADF,CAMA,GAAMY,aAAY,CAAGzB,OAAO,CAAC,WAC3B,GAAMyB,aAAY,CAAwB,EAA1C,8BACWC,IAAG,CACZ,GAAMC,OAAM,CAAGN,MAAM,CAACK,GAAD,CAArB,CACAD,YAAY,CAACC,GAAD,CAAZ,CAAoB,WAClB,GAAI,CAACf,cAAc,CAACE,OAApB,CAA6B,CAC3BF,cAAc,CAACE,OAAf,CAAyBS,MAAM,CAACM,MAAP,CAAc,IAAd,CAAzB,CAEAnB,aAAa,CAACoB,WAAd,GACD,CACD,MAAOF,OAAM,CAACG,KAAP,CAAa,IAAb,CAAmBC,SAAnB,CAAP,CACD,CAPD,GAFF,IAAkB,sCAAlB,CAAkBC,yBAAlB,CAAkBA,IAAlB,CAA+B,CAA1B,GAAMN,IAAG,oBAAT,SAAMA,KAUV,CAED,MAAOD,aAAP,CACD,CAf2B,CAezB,EAfyB,CAA5B,CAiBAH,MAAM,CAACC,MAAP,CAAcF,MAAd,CAAsBI,YAAtB,EAEA,GAAMQ,QAAO,CAAGlC,WAAW,CAEzB,wBAAc,CACdY,cAAc,CAACE,OAAf,CAAyBqB,cAAc,CAAElB,qBACpCkB,cADoC,EACtB,CACjBC,WAAW,CAAED,cAAc,CAACC,WAAf,EAA8BjB,kBAD1B,CADsB,CAAF,CAGnC,CACFiB,WAAW,CAAEjB,kBADX,CAHJ,CAOA,GAAMkB,QAAO,CAAG3B,aAAa,CAC1B4B,WADa,GAEbC,IAFa,CAER,qBAAW,CAAI,aAAM,CAACf,MAAP,CAAcgB,WAAd,CAA2Bd,YAA3B,EAAwC,CAF/C,CAAhB,CAMAW,OAAO,CAACI,KAAR,CAAc,WAAQ,CAAtB,EAEA,MAAOJ,QAAP,CACD,CAnB0B,CAmBxB,EAnBwB,CAA3B,CAqBA,MAAO,CAACH,OAAD,CAAUZ,MAAV,CAAP,CACD","names":["useCallback","useMemo","useRef","mergeOptions","useInternalState","useApolloClient","EAGER_METHODS","useLazyQuery","query","options","internalState","client","execOptionsRef","merged","current","useQueryResult","useQuery","__assign","skip","initialFetchPolicy","observable","getDefaultFetchPolicy","result","Object","assign","called","eagerMethods","key","method","create","forceUpdate","apply","arguments","_i","execute","executeOptions","fetchPolicy","promise","asyncUpdate","then","queryResult","catch"],"sourceRoot":"","sources":["../../../src/react/hooks/useLazyQuery.ts"],"sourcesContent":["import { DocumentNode } from 'graphql';\nimport { TypedDocumentNode } from '@graphql-typed-document-node/core';\nimport { useCallback, useMemo, useRef } from 'react';\n\nimport { OperationVariables } from '../../core';\nimport { mergeOptions } from '../../utilities';\nimport {\n  LazyQueryHookOptions,\n  LazyQueryResultTuple,\n  QueryResult,\n} from '../types/types';\nimport { useInternalState } from './useQuery';\nimport { useApolloClient } from './useApolloClient';\n\n// The following methods, when called will execute the query, regardless of\n// whether the useLazyQuery execute function was called before.\nconst EAGER_METHODS = [\n  'refetch',\n  'reobserve',\n  'fetchMore',\n  'updateQuery',\n  'startPolling',\n  'subscribeToMore',\n] as const;\n\nexport function useLazyQuery<TData = any, TVariables = OperationVariables>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options?: LazyQueryHookOptions<TData, TVariables>\n): LazyQueryResultTuple<TData, TVariables> {\n  const internalState = useInternalState(\n    useApolloClient(options && options.client),\n    query,\n  );\n\n  const execOptionsRef = useRef<Partial<LazyQueryHookOptions<TData, TVariables>>>();\n  const merged = execOptionsRef.current\n    ? mergeOptions(options, execOptionsRef.current)\n    : options;\n\n  const useQueryResult = internalState.useQuery({\n    ...merged,\n    skip: !execOptionsRef.current,\n  });\n\n  const initialFetchPolicy =\n    useQueryResult.observable.options.initialFetchPolicy ||\n    internalState.getDefaultFetchPolicy();\n\n  const result: QueryResult<TData, TVariables> =\n    Object.assign(useQueryResult, {\n      called: !!execOptionsRef.current,\n    });\n\n  // We use useMemo here to make sure the eager methods have a stable identity.\n  const eagerMethods = useMemo(() => {\n    const eagerMethods: Record<string, any> = {};\n    for (const key of EAGER_METHODS) {\n      const method = result[key];\n      eagerMethods[key] = function () {\n        if (!execOptionsRef.current) {\n          execOptionsRef.current = Object.create(null);\n          // Only the first time populating execOptionsRef.current matters here.\n          internalState.forceUpdate();\n        }\n        return method.apply(this, arguments);\n      };\n    }\n\n    return eagerMethods;\n  }, []);\n\n  Object.assign(result, eagerMethods);\n\n  const execute = useCallback<\n    LazyQueryResultTuple<TData, TVariables>[0]\n  >(executeOptions => {\n    execOptionsRef.current = executeOptions ? {\n      ...executeOptions,\n      fetchPolicy: executeOptions.fetchPolicy || initialFetchPolicy,\n    } : {\n      fetchPolicy: initialFetchPolicy,\n    };\n\n    const promise = internalState\n      .asyncUpdate() // Like internalState.forceUpdate, but returns a Promise.\n      .then(queryResult => Object.assign(queryResult, eagerMethods));\n\n    // Because the return value of `useLazyQuery` is usually floated, we need\n    // to catch the promise to prevent unhandled rejections.\n    promise.catch(() => {});\n\n    return promise;\n  }, []);\n\n  return [execute, result];\n}\n"]},"metadata":{},"sourceType":"module"}