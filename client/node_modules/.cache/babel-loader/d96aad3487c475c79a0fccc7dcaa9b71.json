{"ast":null,"code":"import{__assign}from\"tslib\";import{invariant,InvariantError}from\"../utilities/globals/index.js\";import{ApolloLink,execute}from\"../link/core/index.js\";import{version}from\"../version.js\";import{HttpLink}from\"../link/http/index.js\";import{QueryManager}from\"./QueryManager.js\";import{LocalState}from\"./LocalState.js\";var hasSuggestedDevtools=false;import{mergeOptions}from\"../utilities/index.js\";export{mergeOptions};var ApolloClient=function(){function ApolloClient(options){var _this=this;this.resetStoreCallbacks=[];this.clearStoreCallbacks=[];var uri=options.uri,credentials=options.credentials,headers=options.headers,cache=options.cache,_a=options.ssrMode,ssrMode=_a===void 0?false:_a,_b=options.ssrForceFetchDelay,ssrForceFetchDelay=_b===void 0?0:_b,_c=options.connectToDevTools,connectToDevTools=_c===void 0?typeof window==='object'&&!window.__APOLLO_CLIENT__&&__DEV__:_c,_d=options.queryDeduplication,queryDeduplication=_d===void 0?true:_d,defaultOptions=options.defaultOptions,_e=options.assumeImmutableResults,assumeImmutableResults=_e===void 0?false:_e,resolvers=options.resolvers,typeDefs=options.typeDefs,fragmentMatcher=options.fragmentMatcher,clientAwarenessName=options.name,clientAwarenessVersion=options.version;var link=options.link;if(!link){link=uri?new HttpLink({uri:uri,credentials:credentials,headers:headers}):ApolloLink.empty();}if(!cache){throw __DEV__?new InvariantError(\"To initialize Apollo Client, you must specify a 'cache' property \"+\"in the options object. \\n\"+\"For more information, please visit: https://go.apollo.dev/c/docs\"):new InvariantError(9);}this.link=link;this.cache=cache;this.disableNetworkFetches=ssrMode||ssrForceFetchDelay>0;this.queryDeduplication=queryDeduplication;this.defaultOptions=defaultOptions||Object.create(null);this.typeDefs=typeDefs;if(ssrForceFetchDelay){setTimeout(function(){return _this.disableNetworkFetches=false;},ssrForceFetchDelay);}this.watchQuery=this.watchQuery.bind(this);this.query=this.query.bind(this);this.mutate=this.mutate.bind(this);this.resetStore=this.resetStore.bind(this);this.reFetchObservableQueries=this.reFetchObservableQueries.bind(this);if(connectToDevTools&&typeof window==='object'){window.__APOLLO_CLIENT__=this;}if(!hasSuggestedDevtools&&__DEV__){hasSuggestedDevtools=true;if(typeof window!=='undefined'&&window.document&&window.top===window.self&&!window.__APOLLO_DEVTOOLS_GLOBAL_HOOK__){var nav=window.navigator;var ua=nav&&nav.userAgent;var url=void 0;if(typeof ua===\"string\"){if(ua.indexOf(\"Chrome/\")>-1){url=\"https://chrome.google.com/webstore/detail/\"+\"apollo-client-developer-t/jdkknkkbebbapilgoeccciglkfbmbnfm\";}else if(ua.indexOf(\"Firefox/\")>-1){url=\"https://addons.mozilla.org/en-US/firefox/addon/apollo-developer-tools/\";}}if(url){__DEV__&&invariant.log(\"Download the Apollo DevTools for a better development \"+\"experience: \"+url);}}}this.version=version;this.localState=new LocalState({cache:cache,client:this,resolvers:resolvers,fragmentMatcher:fragmentMatcher});this.queryManager=new QueryManager({cache:this.cache,link:this.link,defaultOptions:this.defaultOptions,queryDeduplication:queryDeduplication,ssrMode:ssrMode,clientAwareness:{name:clientAwarenessName,version:clientAwarenessVersion},localState:this.localState,assumeImmutableResults:assumeImmutableResults,onBroadcast:connectToDevTools?function(){if(_this.devToolsHookCb){_this.devToolsHookCb({action:{},state:{queries:_this.queryManager.getQueryStore(),mutations:_this.queryManager.mutationStore||{}},dataWithOptimisticResults:_this.cache.extract(true)});}}:void 0});}ApolloClient.prototype.stop=function(){this.queryManager.stop();};ApolloClient.prototype.watchQuery=function(options){if(this.defaultOptions.watchQuery){options=mergeOptions(this.defaultOptions.watchQuery,options);}if(this.disableNetworkFetches&&(options.fetchPolicy==='network-only'||options.fetchPolicy==='cache-and-network')){options=__assign(__assign({},options),{fetchPolicy:'cache-first'});}return this.queryManager.watchQuery(options);};ApolloClient.prototype.query=function(options){if(this.defaultOptions.query){options=mergeOptions(this.defaultOptions.query,options);}__DEV__?invariant(options.fetchPolicy!=='cache-and-network','The cache-and-network fetchPolicy does not work with client.query, because '+'client.query can only return a single result. Please use client.watchQuery '+'to receive multiple results from the cache and the network, or consider '+'using a different fetchPolicy, such as cache-first or network-only.'):invariant(options.fetchPolicy!=='cache-and-network',10);if(this.disableNetworkFetches&&options.fetchPolicy==='network-only'){options=__assign(__assign({},options),{fetchPolicy:'cache-first'});}return this.queryManager.query(options);};ApolloClient.prototype.mutate=function(options){if(this.defaultOptions.mutate){options=mergeOptions(this.defaultOptions.mutate,options);}return this.queryManager.mutate(options);};ApolloClient.prototype.subscribe=function(options){return this.queryManager.startGraphQLSubscription(options);};ApolloClient.prototype.readQuery=function(options,optimistic){if(optimistic===void 0){optimistic=false;}return this.cache.readQuery(options,optimistic);};ApolloClient.prototype.readFragment=function(options,optimistic){if(optimistic===void 0){optimistic=false;}return this.cache.readFragment(options,optimistic);};ApolloClient.prototype.writeQuery=function(options){this.cache.writeQuery(options);this.queryManager.broadcastQueries();};ApolloClient.prototype.writeFragment=function(options){this.cache.writeFragment(options);this.queryManager.broadcastQueries();};ApolloClient.prototype.__actionHookForDevTools=function(cb){this.devToolsHookCb=cb;};ApolloClient.prototype.__requestRaw=function(payload){return execute(this.link,payload);};ApolloClient.prototype.resetStore=function(){var _this=this;return Promise.resolve().then(function(){return _this.queryManager.clearStore({discardWatches:false});}).then(function(){return Promise.all(_this.resetStoreCallbacks.map(function(fn){return fn();}));}).then(function(){return _this.reFetchObservableQueries();});};ApolloClient.prototype.clearStore=function(){var _this=this;return Promise.resolve().then(function(){return _this.queryManager.clearStore({discardWatches:true});}).then(function(){return Promise.all(_this.clearStoreCallbacks.map(function(fn){return fn();}));});};ApolloClient.prototype.onResetStore=function(cb){var _this=this;this.resetStoreCallbacks.push(cb);return function(){_this.resetStoreCallbacks=_this.resetStoreCallbacks.filter(function(c){return c!==cb;});};};ApolloClient.prototype.onClearStore=function(cb){var _this=this;this.clearStoreCallbacks.push(cb);return function(){_this.clearStoreCallbacks=_this.clearStoreCallbacks.filter(function(c){return c!==cb;});};};ApolloClient.prototype.reFetchObservableQueries=function(includeStandby){return this.queryManager.reFetchObservableQueries(includeStandby);};ApolloClient.prototype.refetchQueries=function(options){var map=this.queryManager.refetchQueries(options);var queries=[];var results=[];map.forEach(function(result,obsQuery){queries.push(obsQuery);results.push(result);});var result=Promise.all(results);result.queries=queries;result.results=results;result.catch(function(error){__DEV__&&invariant.debug(\"In client.refetchQueries, Promise.all promise rejected with error \".concat(error));});return result;};ApolloClient.prototype.getObservableQueries=function(include){if(include===void 0){include=\"active\";}return this.queryManager.getObservableQueries(include);};ApolloClient.prototype.extract=function(optimistic){return this.cache.extract(optimistic);};ApolloClient.prototype.restore=function(serializedState){return this.cache.restore(serializedState);};ApolloClient.prototype.addResolvers=function(resolvers){this.localState.addResolvers(resolvers);};ApolloClient.prototype.setResolvers=function(resolvers){this.localState.setResolvers(resolvers);};ApolloClient.prototype.getResolvers=function(){return this.localState.getResolvers();};ApolloClient.prototype.setLocalStateFragmentMatcher=function(fragmentMatcher){this.localState.setFragmentMatcher(fragmentMatcher);};ApolloClient.prototype.setLink=function(newLink){this.link=this.queryManager.link=newLink;};return ApolloClient;}();export{ApolloClient};","map":{"version":3,"mappings":"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","names":["invariant","InvariantError","ApolloLink","execute","version","HttpLink","QueryManager","LocalState","hasSuggestedDevtools","mergeOptions","options","credentials","headers","cache","_a","ssrMode","_b","ssrForceFetchDelay","_c","connectToDevTools","window","__APOLLO_CLIENT__","__DEV__","_d","queryDeduplication","defaultOptions","_e","assumeImmutableResults","resolvers","typeDefs","fragmentMatcher","clientAwarenessName","clientAwarenessVersion","link","uri","empty","disableNetworkFetches","Object","create","setTimeout","_this","watchQuery","bind","query","mutate","resetStore","reFetchObservableQueries","document","top","self","__APOLLO_DEVTOOLS_GLOBAL_HOOK__","nav","navigator","ua","userAgent","url","indexOf","localState","client","queryManager","clientAwareness","name","onBroadcast","devToolsHookCb","action","state","queries","getQueryStore","mutations","mutationStore","dataWithOptimisticResults","extract","ApolloClient","stop","fetchPolicy","startGraphQLSubscription","optimistic","readQuery","readFragment","writeQuery","broadcastQueries","writeFragment","cb","payload","Promise","resolve","then","clearStore","discardWatches","all","resetStoreCallbacks","map","clearStoreCallbacks","push","filter","includeStandby","refetchQueries","results","forEach","result","obsQuery","catch","concat","error","include","getObservableQueries","serializedState","restore","addResolvers","setResolvers","getResolvers","setFragmentMatcher","newLink"],"sourceRoot":"","sources":["../../src/core/ApolloClient.ts"],"sourcesContent":["import { invariant, InvariantError } from '../utilities/globals';\n\nimport { ExecutionResult, DocumentNode } from 'graphql';\n\nimport { ApolloLink, FetchResult, GraphQLRequest, execute } from '../link/core';\nimport { ApolloCache, DataProxy } from '../cache';\nimport { Observable } from '../utilities';\nimport { version } from '../version';\nimport { HttpLink, UriFunction } from '../link/http';\n\nimport { QueryManager } from './QueryManager';\nimport { ObservableQuery } from './ObservableQuery';\n\nimport {\n  ApolloQueryResult,\n  DefaultContext,\n  OperationVariables,\n  Resolvers,\n  RefetchQueriesOptions,\n  RefetchQueriesResult,\n  InternalRefetchQueriesResult,\n  RefetchQueriesInclude,\n} from './types';\n\nimport {\n  QueryOptions,\n  WatchQueryOptions,\n  MutationOptions,\n  SubscriptionOptions,\n  WatchQueryFetchPolicy,\n} from './watchQueryOptions';\n\nimport {\n  LocalState,\n  FragmentMatcher,\n} from './LocalState';\n\nexport interface DefaultOptions {\n  watchQuery?: Partial<WatchQueryOptions<any, any>>;\n  query?: Partial<QueryOptions<any, any>>;\n  mutate?: Partial<MutationOptions<any, any, any>>;\n}\n\nlet hasSuggestedDevtools = false;\n\nexport type ApolloClientOptions<TCacheShape> = {\n  uri?: string | UriFunction;\n  credentials?: string;\n  headers?: Record<string, string>;\n  link?: ApolloLink;\n  cache: ApolloCache<TCacheShape>;\n  ssrForceFetchDelay?: number;\n  ssrMode?: boolean;\n  connectToDevTools?: boolean;\n  queryDeduplication?: boolean;\n  defaultOptions?: DefaultOptions;\n  assumeImmutableResults?: boolean;\n  resolvers?: Resolvers | Resolvers[];\n  typeDefs?: string | string[] | DocumentNode | DocumentNode[];\n  fragmentMatcher?: FragmentMatcher;\n  name?: string;\n  version?: string;\n};\n\n// Though mergeOptions now resides in @apollo/client/utilities, it was\n// previously declared and exported from this module, and then reexported from\n// @apollo/client/core. Since we need to preserve that API anyway, the easiest\n// solution is to reexport mergeOptions where it was previously declared (here).\nimport { mergeOptions } from \"../utilities\";\nexport { mergeOptions }\n\n/**\n * This is the primary Apollo Client class. It is used to send GraphQL documents (i.e. queries\n * and mutations) to a GraphQL spec-compliant server over a {@link NetworkInterface} instance,\n * receive results from the server and cache the results in a store. It also delivers updates\n * to GraphQL queries through {@link Observable} instances.\n */\nexport class ApolloClient<TCacheShape> implements DataProxy {\n  public link: ApolloLink;\n  public cache: ApolloCache<TCacheShape>;\n  public disableNetworkFetches: boolean;\n  public version: string;\n  public queryDeduplication: boolean;\n  public defaultOptions: DefaultOptions;\n  public readonly typeDefs: ApolloClientOptions<TCacheShape>['typeDefs'];\n\n  private queryManager: QueryManager<TCacheShape>;\n  private devToolsHookCb: Function;\n  private resetStoreCallbacks: Array<() => Promise<any>> = [];\n  private clearStoreCallbacks: Array<() => Promise<any>> = [];\n  private localState: LocalState<TCacheShape>;\n\n  /**\n   * Constructs an instance of {@link ApolloClient}.\n   *\n   * @param uri The GraphQL endpoint that Apollo Client will connect to. If\n   *            `link` is configured, this option is ignored.\n   * @param link The {@link ApolloLink} over which GraphQL documents will be resolved into a response.\n   *\n   * @param cache The initial cache to use in the data store.\n   *\n   * @param ssrMode Determines whether this is being run in Server Side Rendering (SSR) mode.\n   *\n   * @param ssrForceFetchDelay Determines the time interval before we force fetch queries for a\n   * server side render.\n   *\n   * @param queryDeduplication If set to false, a query will still be sent to the server even if a query\n   * with identical parameters (query, variables, operationName) is already in flight.\n   *\n   * @param defaultOptions Used to set application wide defaults for the\n   *                       options supplied to `watchQuery`, `query`, or\n   *                       `mutate`.\n   *\n   * @param assumeImmutableResults When this option is true, the client will assume results\n   *                               read from the cache are never mutated by application code,\n   *                               which enables substantial performance optimizations.\n   *\n   * @param name A custom name that can be used to identify this client, when\n   *             using Apollo client awareness features. E.g. \"iOS\".\n   *\n   * @param version A custom version that can be used to identify this client,\n   *                when using Apollo client awareness features. This is the\n   *                version of your client, which you may want to increment on\n   *                new builds. This is NOT the version of Apollo Client that\n   *                you are using.\n   */\n  constructor(options: ApolloClientOptions<TCacheShape>) {\n    const {\n      uri,\n      credentials,\n      headers,\n      cache,\n      ssrMode = false,\n      ssrForceFetchDelay = 0,\n      connectToDevTools =\n        // Expose the client instance as window.__APOLLO_CLIENT__ and call\n        // onBroadcast in queryManager.broadcastQueries to enable browser\n        // devtools, but disable them by default in production.\n        typeof window === 'object' &&\n        !(window as any).__APOLLO_CLIENT__ &&\n        __DEV__,\n      queryDeduplication = true,\n      defaultOptions,\n      assumeImmutableResults = false,\n      resolvers,\n      typeDefs,\n      fragmentMatcher,\n      name: clientAwarenessName,\n      version: clientAwarenessVersion,\n    } = options;\n\n    let { link } = options;\n\n    if (!link) {\n      link = uri\n        ? new HttpLink({ uri, credentials, headers })\n        : ApolloLink.empty();\n    }\n\n    if (!cache) {\n      throw new InvariantError(\n        \"To initialize Apollo Client, you must specify a 'cache' property \" +\n        \"in the options object. \\n\" +\n        \"For more information, please visit: https://go.apollo.dev/c/docs\"\n      );\n    }\n\n    this.link = link;\n    this.cache = cache;\n    this.disableNetworkFetches = ssrMode || ssrForceFetchDelay > 0;\n    this.queryDeduplication = queryDeduplication;\n    this.defaultOptions = defaultOptions || Object.create(null);\n    this.typeDefs = typeDefs;\n\n    if (ssrForceFetchDelay) {\n      setTimeout(\n        () => (this.disableNetworkFetches = false),\n        ssrForceFetchDelay,\n      );\n    }\n\n    this.watchQuery = this.watchQuery.bind(this);\n    this.query = this.query.bind(this);\n    this.mutate = this.mutate.bind(this);\n    this.resetStore = this.resetStore.bind(this);\n    this.reFetchObservableQueries = this.reFetchObservableQueries.bind(this);\n\n    if (connectToDevTools && typeof window === 'object') {\n      (window as any).__APOLLO_CLIENT__ = this;\n    }\n\n    /**\n     * Suggest installing the devtools for developers who don't have them\n     */\n    if (!hasSuggestedDevtools && __DEV__) {\n      hasSuggestedDevtools = true;\n      if (\n        typeof window !== 'undefined' &&\n        window.document &&\n        window.top === window.self &&\n        !(window as any).__APOLLO_DEVTOOLS_GLOBAL_HOOK__\n      ) {\n        const nav = window.navigator;\n        const ua = nav && nav.userAgent;\n        let url: string | undefined;\n        if (typeof ua === \"string\") {\n          if (ua.indexOf(\"Chrome/\") > -1) {\n            url = \"https://chrome.google.com/webstore/detail/\" +\n              \"apollo-client-developer-t/jdkknkkbebbapilgoeccciglkfbmbnfm\";\n          } else if (ua.indexOf(\"Firefox/\") > -1) {\n            url = \"https://addons.mozilla.org/en-US/firefox/addon/apollo-developer-tools/\";\n          }\n        }\n        if (url) {\n          invariant.log(\n            \"Download the Apollo DevTools for a better development \" +\n              \"experience: \" + url\n          );\n        }\n      }\n    }\n\n    this.version = version;\n\n    this.localState = new LocalState({\n      cache,\n      client: this,\n      resolvers,\n      fragmentMatcher,\n    });\n\n    this.queryManager = new QueryManager({\n      cache: this.cache,\n      link: this.link,\n      defaultOptions: this.defaultOptions,\n      queryDeduplication,\n      ssrMode,\n      clientAwareness: {\n        name: clientAwarenessName!,\n        version: clientAwarenessVersion!,\n      },\n      localState: this.localState,\n      assumeImmutableResults,\n      onBroadcast: connectToDevTools ? () => {\n        if (this.devToolsHookCb) {\n          this.devToolsHookCb({\n            action: {},\n            state: {\n              queries: this.queryManager.getQueryStore(),\n              mutations: this.queryManager.mutationStore || {},\n            },\n            dataWithOptimisticResults: this.cache.extract(true),\n          });\n        }\n      } : void 0,\n    });\n  }\n\n  /**\n   * Call this method to terminate any active client processes, making it safe\n   * to dispose of this `ApolloClient` instance.\n   */\n  public stop() {\n    this.queryManager.stop();\n  }\n\n  /**\n   * This watches the cache store of the query according to the options specified and\n   * returns an {@link ObservableQuery}. We can subscribe to this {@link ObservableQuery} and\n   * receive updated results through a GraphQL observer when the cache store changes.\n   *\n   * Note that this method is not an implementation of GraphQL subscriptions. Rather,\n   * it uses Apollo's store in order to reactively deliver updates to your query results.\n   *\n   * For example, suppose you call watchQuery on a GraphQL query that fetches a person's\n   * first and last name and this person has a particular object identifier, provided by\n   * dataIdFromObject. Later, a different query fetches that same person's\n   * first and last name and the first name has now changed. Then, any observers associated\n   * with the results of the first query will be updated with a new result object.\n   *\n   * Note that if the cache does not change, the subscriber will *not* be notified.\n   *\n   * See [here](https://medium.com/apollo-stack/the-concepts-of-graphql-bc68bd819be3#.3mb0cbcmc) for\n   * a description of store reactivity.\n   */\n  public watchQuery<T = any, TVariables = OperationVariables>(\n    options: WatchQueryOptions<TVariables, T>,\n  ): ObservableQuery<T, TVariables> {\n    if (this.defaultOptions.watchQuery) {\n      options = mergeOptions(this.defaultOptions.watchQuery, options);\n    }\n\n    // XXX Overwriting options is probably not the best way to do this long term...\n    if (\n      this.disableNetworkFetches &&\n      (options.fetchPolicy === 'network-only' ||\n        options.fetchPolicy === 'cache-and-network')\n    ) {\n      options = { ...options, fetchPolicy: 'cache-first' };\n    }\n\n    return this.queryManager.watchQuery<T, TVariables>(options);\n  }\n\n  /**\n   * This resolves a single query according to the options specified and\n   * returns a {@link Promise} which is either resolved with the resulting data\n   * or rejected with an error.\n   *\n   * @param options An object of type {@link QueryOptions} that allows us to\n   * describe how this query should be treated e.g. whether it should hit the\n   * server at all or just resolve from the cache, etc.\n   */\n  public query<T = any, TVariables = OperationVariables>(\n    options: QueryOptions<TVariables, T>,\n  ): Promise<ApolloQueryResult<T>> {\n    if (this.defaultOptions.query) {\n      options = mergeOptions(this.defaultOptions.query, options);\n    }\n\n    invariant(\n      (options.fetchPolicy as WatchQueryFetchPolicy) !== 'cache-and-network',\n      'The cache-and-network fetchPolicy does not work with client.query, because ' +\n      'client.query can only return a single result. Please use client.watchQuery ' +\n      'to receive multiple results from the cache and the network, or consider ' +\n      'using a different fetchPolicy, such as cache-first or network-only.'\n    );\n\n    if (this.disableNetworkFetches && options.fetchPolicy === 'network-only') {\n      options = { ...options, fetchPolicy: 'cache-first' };\n    }\n\n    return this.queryManager.query<T, TVariables>(options);\n  }\n\n  /**\n   * This resolves a single mutation according to the options specified and returns a\n   * {@link Promise} which is either resolved with the resulting data or rejected with an\n   * error.\n   *\n   * It takes options as an object with the following keys and values:\n   */\n  public mutate<\n    TData = any,\n    TVariables = OperationVariables,\n    TContext = DefaultContext,\n    TCache extends ApolloCache<any> = ApolloCache<any>\n  >(\n    options: MutationOptions<TData, TVariables, TContext>,\n  ): Promise<FetchResult<TData>> {\n    if (this.defaultOptions.mutate) {\n      options = mergeOptions(this.defaultOptions.mutate, options);\n    }\n    return this.queryManager.mutate<TData, TVariables, TContext, TCache>(options);\n  }\n\n  /**\n   * This subscribes to a graphql subscription according to the options specified and returns an\n   * {@link Observable} which either emits received data or an error.\n   */\n  public subscribe<T = any, TVariables = OperationVariables>(\n    options: SubscriptionOptions<TVariables, T>,\n  ): Observable<FetchResult<T>> {\n    return this.queryManager.startGraphQLSubscription<T>(options);\n  }\n\n  /**\n   * Tries to read some data from the store in the shape of the provided\n   * GraphQL query without making a network request. This method will start at\n   * the root query. To start at a specific id returned by `dataIdFromObject`\n   * use `readFragment`.\n   *\n   * @param optimistic Set to `true` to allow `readQuery` to return\n   * optimistic results. Is `false` by default.\n   */\n  public readQuery<T = any, TVariables = OperationVariables>(\n    options: DataProxy.Query<TVariables, T>,\n    optimistic: boolean = false,\n  ): T | null {\n    return this.cache.readQuery<T, TVariables>(options, optimistic);\n  }\n\n  /**\n   * Tries to read some data from the store in the shape of the provided\n   * GraphQL fragment without making a network request. This method will read a\n   * GraphQL fragment from any arbitrary id that is currently cached, unlike\n   * `readQuery` which will only read from the root query.\n   *\n   * You must pass in a GraphQL document with a single fragment or a document\n   * with multiple fragments that represent what you are reading. If you pass\n   * in a document with multiple fragments then you must also specify a\n   * `fragmentName`.\n   *\n   * @param optimistic Set to `true` to allow `readFragment` to return\n   * optimistic results. Is `false` by default.\n   */\n  public readFragment<T = any, TVariables = OperationVariables>(\n    options: DataProxy.Fragment<TVariables, T>,\n    optimistic: boolean = false,\n  ): T | null {\n    return this.cache.readFragment<T, TVariables>(options, optimistic);\n  }\n\n  /**\n   * Writes some data in the shape of the provided GraphQL query directly to\n   * the store. This method will start at the root query. To start at a\n   * specific id returned by `dataIdFromObject` then use `writeFragment`.\n   */\n  public writeQuery<TData = any, TVariables = OperationVariables>(\n    options: DataProxy.WriteQueryOptions<TData, TVariables>,\n  ): void {\n    this.cache.writeQuery<TData, TVariables>(options);\n    this.queryManager.broadcastQueries();\n  }\n\n  /**\n   * Writes some data in the shape of the provided GraphQL fragment directly to\n   * the store. This method will write to a GraphQL fragment from any arbitrary\n   * id that is currently cached, unlike `writeQuery` which will only write\n   * from the root query.\n   *\n   * You must pass in a GraphQL document with a single fragment or a document\n   * with multiple fragments that represent what you are writing. If you pass\n   * in a document with multiple fragments then you must also specify a\n   * `fragmentName`.\n   */\n  public writeFragment<TData = any, TVariables = OperationVariables>(\n    options: DataProxy.WriteFragmentOptions<TData, TVariables>,\n  ): void {\n    this.cache.writeFragment<TData, TVariables>(options);\n    this.queryManager.broadcastQueries();\n  }\n\n  public __actionHookForDevTools(cb: () => any) {\n    this.devToolsHookCb = cb;\n  }\n\n  public __requestRaw(payload: GraphQLRequest): Observable<ExecutionResult> {\n    return execute(this.link, payload);\n  }\n\n  /**\n   * Resets your entire store by clearing out your cache and then re-executing\n   * all of your active queries. This makes it so that you may guarantee that\n   * there is no data left in your store from a time before you called this\n   * method.\n   *\n   * `resetStore()` is useful when your user just logged out. You’ve removed the\n   * user session, and you now want to make sure that any references to data you\n   * might have fetched while the user session was active is gone.\n   *\n   * It is important to remember that `resetStore()` *will* refetch any active\n   * queries. This means that any components that might be mounted will execute\n   * their queries again using your network interface. If you do not want to\n   * re-execute any queries then you should make sure to stop watching any\n   * active queries.\n   */\n  public resetStore(): Promise<ApolloQueryResult<any>[] | null> {\n    return Promise.resolve()\n      .then(() => this.queryManager.clearStore({\n        discardWatches: false,\n      }))\n      .then(() => Promise.all(this.resetStoreCallbacks.map(fn => fn())))\n      .then(() => this.reFetchObservableQueries());\n  }\n\n  /**\n   * Remove all data from the store. Unlike `resetStore`, `clearStore` will\n   * not refetch any active queries.\n   */\n  public clearStore(): Promise<any[]> {\n    return Promise.resolve()\n      .then(() => this.queryManager.clearStore({\n        discardWatches: true,\n      }))\n      .then(() => Promise.all(this.clearStoreCallbacks.map(fn => fn())));\n  }\n\n  /**\n   * Allows callbacks to be registered that are executed when the store is\n   * reset. `onResetStore` returns an unsubscribe function that can be used\n   * to remove registered callbacks.\n   */\n  public onResetStore(cb: () => Promise<any>): () => void {\n    this.resetStoreCallbacks.push(cb);\n    return () => {\n      this.resetStoreCallbacks = this.resetStoreCallbacks.filter(c => c !== cb);\n    };\n  }\n\n  /**\n   * Allows callbacks to be registered that are executed when the store is\n   * cleared. `onClearStore` returns an unsubscribe function that can be used\n   * to remove registered callbacks.\n   */\n  public onClearStore(cb: () => Promise<any>): () => void {\n    this.clearStoreCallbacks.push(cb);\n    return () => {\n      this.clearStoreCallbacks = this.clearStoreCallbacks.filter(c => c !== cb);\n    };\n  }\n\n  /**\n   * Refetches all of your active queries.\n   *\n   * `reFetchObservableQueries()` is useful if you want to bring the client back to proper state in case of a network outage\n   *\n   * It is important to remember that `reFetchObservableQueries()` *will* refetch any active\n   * queries. This means that any components that might be mounted will execute\n   * their queries again using your network interface. If you do not want to\n   * re-execute any queries then you should make sure to stop watching any\n   * active queries.\n   * Takes optional parameter `includeStandby` which will include queries in standby-mode when refetching.\n   */\n  public reFetchObservableQueries(\n    includeStandby?: boolean,\n  ): Promise<ApolloQueryResult<any>[]> {\n    return this.queryManager.reFetchObservableQueries(includeStandby);\n  }\n\n  /**\n   * Refetches specified active queries. Similar to \"reFetchObservableQueries()\" but with a specific list of queries.\n   *\n   * `refetchQueries()` is useful for use cases to imperatively refresh a selection of queries.\n   *\n   * It is important to remember that `refetchQueries()` *will* refetch specified active\n   * queries. This means that any components that might be mounted will execute\n   * their queries again using your network interface. If you do not want to\n   * re-execute any queries then you should make sure to stop watching any\n   * active queries.\n   */\n  public refetchQueries<\n    TCache extends ApolloCache<any> = ApolloCache<TCacheShape>,\n    TResult = Promise<ApolloQueryResult<any>>,\n  >(\n    options: RefetchQueriesOptions<TCache, TResult>,\n  ): RefetchQueriesResult<TResult> {\n    const map = this.queryManager.refetchQueries(options);\n    const queries: ObservableQuery<any>[] = [];\n    const results: InternalRefetchQueriesResult<TResult>[] = [];\n\n    map.forEach((result, obsQuery) => {\n      queries.push(obsQuery);\n      results.push(result);\n    });\n\n    const result = Promise.all<TResult>(\n      results as TResult[]\n    ) as RefetchQueriesResult<TResult>;\n\n    // In case you need the raw results immediately, without awaiting\n    // Promise.all(results):\n    result.queries = queries;\n    result.results = results;\n\n    // If you decide to ignore the result Promise because you're using\n    // result.queries and result.results instead, you shouldn't have to worry\n    // about preventing uncaught rejections for the Promise.all result.\n    result.catch(error => {\n      invariant.debug(`In client.refetchQueries, Promise.all promise rejected with error ${error}`);\n    });\n\n    return result;\n  }\n\n  /**\n   * Get all currently active `ObservableQuery` objects, in a `Map` keyed by\n   * query ID strings. An \"active\" query is one that has observers and a\n   * `fetchPolicy` other than \"standby\" or \"cache-only\". You can include all\n   * `ObservableQuery` objects (including the inactive ones) by passing \"all\"\n   * instead of \"active\", or you can include just a subset of active queries by\n   * passing an array of query names or DocumentNode objects.\n   */\n  public getObservableQueries(\n    include: RefetchQueriesInclude = \"active\",\n  ): Map<string, ObservableQuery<any>> {\n    return this.queryManager.getObservableQueries(include);\n  }\n\n  /**\n   * Exposes the cache's complete state, in a serializable format for later restoration.\n   */\n  public extract(optimistic?: boolean): TCacheShape {\n    return this.cache.extract(optimistic);\n  }\n\n  /**\n   * Replaces existing state in the cache (if any) with the values expressed by\n   * `serializedState`.\n   *\n   * Called when hydrating a cache (server side rendering, or offline storage),\n   * and also (potentially) during hot reloads.\n   */\n  public restore(serializedState: TCacheShape): ApolloCache<TCacheShape> {\n    return this.cache.restore(serializedState);\n  }\n\n  /**\n   * Add additional local resolvers.\n   */\n  public addResolvers(resolvers: Resolvers | Resolvers[]) {\n    this.localState.addResolvers(resolvers);\n  }\n\n  /**\n   * Set (override existing) local resolvers.\n   */\n  public setResolvers(resolvers: Resolvers | Resolvers[]) {\n    this.localState.setResolvers(resolvers);\n  }\n\n  /**\n   * Get all registered local resolvers.\n   */\n  public getResolvers() {\n    return this.localState.getResolvers();\n  }\n\n  /**\n   * Set a custom local state fragment matcher.\n   */\n  public setLocalStateFragmentMatcher(fragmentMatcher: FragmentMatcher) {\n    this.localState.setFragmentMatcher(fragmentMatcher);\n  }\n\n  /**\n   * Define a new ApolloLink (or link chain) that Apollo Client will use.\n   */\n  public setLink(newLink: ApolloLink) {\n    this.link = this.queryManager.link = newLink;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}