{"ast":null,"code":"import find from\"../polyfills/find.mjs\";import{Kind}from\"../language/kinds.mjs\";import{isNode}from\"../language/ast.mjs\";import{getVisitFn}from\"../language/visitor.mjs\";import{isObjectType,isInterfaceType,isEnumType,isInputObjectType,isListType,isCompositeType,isInputType,isOutputType,getNullableType,getNamedType}from\"../type/definition.mjs\";import{SchemaMetaFieldDef,TypeMetaFieldDef,TypeNameMetaFieldDef}from\"../type/introspection.mjs\";import{typeFromAST}from\"./typeFromAST.mjs\";/**\n * TypeInfo is a utility class which, given a GraphQL schema, can keep track\n * of the current field and type definitions at any point in a GraphQL document\n * AST during a recursive descent by calling `enter(node)` and `leave(node)`.\n */export var TypeInfo=/*#__PURE__*/function(){function TypeInfo(schema,// NOTE: this experimental optional second parameter is only needed in order\n// to support non-spec-compliant code bases. You should never need to use it.\n// It may disappear in the future.\ngetFieldDefFn,// Initial type may be provided in rare cases to facilitate traversals\n// beginning somewhere other than documents.\ninitialType){this._schema=schema;this._typeStack=[];this._parentTypeStack=[];this._inputTypeStack=[];this._fieldDefStack=[];this._defaultValueStack=[];this._directive=null;this._argument=null;this._enumValue=null;this._getFieldDef=getFieldDefFn!==null&&getFieldDefFn!==void 0?getFieldDefFn:getFieldDef;if(initialType){if(isInputType(initialType)){this._inputTypeStack.push(initialType);}if(isCompositeType(initialType)){this._parentTypeStack.push(initialType);}if(isOutputType(initialType)){this._typeStack.push(initialType);}}}var _proto=TypeInfo.prototype;_proto.getType=function getType(){if(this._typeStack.length>0){return this._typeStack[this._typeStack.length-1];}};_proto.getParentType=function getParentType(){if(this._parentTypeStack.length>0){return this._parentTypeStack[this._parentTypeStack.length-1];}};_proto.getInputType=function getInputType(){if(this._inputTypeStack.length>0){return this._inputTypeStack[this._inputTypeStack.length-1];}};_proto.getParentInputType=function getParentInputType(){if(this._inputTypeStack.length>1){return this._inputTypeStack[this._inputTypeStack.length-2];}};_proto.getFieldDef=function getFieldDef(){if(this._fieldDefStack.length>0){return this._fieldDefStack[this._fieldDefStack.length-1];}};_proto.getDefaultValue=function getDefaultValue(){if(this._defaultValueStack.length>0){return this._defaultValueStack[this._defaultValueStack.length-1];}};_proto.getDirective=function getDirective(){return this._directive;};_proto.getArgument=function getArgument(){return this._argument;};_proto.getEnumValue=function getEnumValue(){return this._enumValue;};_proto.enter=function enter(node){var schema=this._schema;// Note: many of the types below are explicitly typed as \"mixed\" to drop\n// any assumptions of a valid schema to ensure runtime types are properly\n// checked before continuing since TypeInfo is used as part of validation\n// which occurs before guarantees of schema and document validity.\nswitch(node.kind){case Kind.SELECTION_SET:{var namedType=getNamedType(this.getType());this._parentTypeStack.push(isCompositeType(namedType)?namedType:undefined);break;}case Kind.FIELD:{var parentType=this.getParentType();var fieldDef;var fieldType;if(parentType){fieldDef=this._getFieldDef(schema,parentType,node);if(fieldDef){fieldType=fieldDef.type;}}this._fieldDefStack.push(fieldDef);this._typeStack.push(isOutputType(fieldType)?fieldType:undefined);break;}case Kind.DIRECTIVE:this._directive=schema.getDirective(node.name.value);break;case Kind.OPERATION_DEFINITION:{var type;switch(node.operation){case'query':type=schema.getQueryType();break;case'mutation':type=schema.getMutationType();break;case'subscription':type=schema.getSubscriptionType();break;}this._typeStack.push(isObjectType(type)?type:undefined);break;}case Kind.INLINE_FRAGMENT:case Kind.FRAGMENT_DEFINITION:{var typeConditionAST=node.typeCondition;var outputType=typeConditionAST?typeFromAST(schema,typeConditionAST):getNamedType(this.getType());this._typeStack.push(isOutputType(outputType)?outputType:undefined);break;}case Kind.VARIABLE_DEFINITION:{var inputType=typeFromAST(schema,node.type);this._inputTypeStack.push(isInputType(inputType)?inputType:undefined);break;}case Kind.ARGUMENT:{var _this$getDirective;var argDef;var argType;var fieldOrDirective=(_this$getDirective=this.getDirective())!==null&&_this$getDirective!==void 0?_this$getDirective:this.getFieldDef();if(fieldOrDirective){argDef=find(fieldOrDirective.args,function(arg){return arg.name===node.name.value;});if(argDef){argType=argDef.type;}}this._argument=argDef;this._defaultValueStack.push(argDef?argDef.defaultValue:undefined);this._inputTypeStack.push(isInputType(argType)?argType:undefined);break;}case Kind.LIST:{var listType=getNullableType(this.getInputType());var itemType=isListType(listType)?listType.ofType:listType;// List positions never have a default value.\nthis._defaultValueStack.push(undefined);this._inputTypeStack.push(isInputType(itemType)?itemType:undefined);break;}case Kind.OBJECT_FIELD:{var objectType=getNamedType(this.getInputType());var inputFieldType;var inputField;if(isInputObjectType(objectType)){inputField=objectType.getFields()[node.name.value];if(inputField){inputFieldType=inputField.type;}}this._defaultValueStack.push(inputField?inputField.defaultValue:undefined);this._inputTypeStack.push(isInputType(inputFieldType)?inputFieldType:undefined);break;}case Kind.ENUM:{var enumType=getNamedType(this.getInputType());var enumValue;if(isEnumType(enumType)){enumValue=enumType.getValue(node.value);}this._enumValue=enumValue;break;}}};_proto.leave=function leave(node){switch(node.kind){case Kind.SELECTION_SET:this._parentTypeStack.pop();break;case Kind.FIELD:this._fieldDefStack.pop();this._typeStack.pop();break;case Kind.DIRECTIVE:this._directive=null;break;case Kind.OPERATION_DEFINITION:case Kind.INLINE_FRAGMENT:case Kind.FRAGMENT_DEFINITION:this._typeStack.pop();break;case Kind.VARIABLE_DEFINITION:this._inputTypeStack.pop();break;case Kind.ARGUMENT:this._argument=null;this._defaultValueStack.pop();this._inputTypeStack.pop();break;case Kind.LIST:case Kind.OBJECT_FIELD:this._defaultValueStack.pop();this._inputTypeStack.pop();break;case Kind.ENUM:this._enumValue=null;break;}};return TypeInfo;}();/**\n * Not exactly the same as the executor's definition of getFieldDef, in this\n * statically evaluated environment we do not always have an Object type,\n * and need to handle Interface and Union types.\n */function getFieldDef(schema,parentType,fieldNode){var name=fieldNode.name.value;if(name===SchemaMetaFieldDef.name&&schema.getQueryType()===parentType){return SchemaMetaFieldDef;}if(name===TypeMetaFieldDef.name&&schema.getQueryType()===parentType){return TypeMetaFieldDef;}if(name===TypeNameMetaFieldDef.name&&isCompositeType(parentType)){return TypeNameMetaFieldDef;}if(isObjectType(parentType)||isInterfaceType(parentType)){return parentType.getFields()[name];}}/**\n * Creates a new visitor instance which maintains a provided TypeInfo instance\n * along with visiting visitor.\n */export function visitWithTypeInfo(typeInfo,visitor){return{enter:function enter(node){typeInfo.enter(node);var fn=getVisitFn(visitor,node.kind,/* isLeaving */false);if(fn){var result=fn.apply(visitor,arguments);if(result!==undefined){typeInfo.leave(node);if(isNode(result)){typeInfo.enter(result);}}return result;}},leave:function leave(node){var fn=getVisitFn(visitor,node.kind,/* isLeaving */true);var result;if(fn){result=fn.apply(visitor,arguments);}typeInfo.leave(node);return result;}};}","map":{"version":3,"names":["find","Kind","isNode","getVisitFn","isObjectType","isInterfaceType","isEnumType","isInputObjectType","isListType","isCompositeType","isInputType","isOutputType","getNullableType","getNamedType","SchemaMetaFieldDef","TypeMetaFieldDef","TypeNameMetaFieldDef","typeFromAST","TypeInfo","schema","getFieldDefFn","initialType","_schema","_typeStack","_parentTypeStack","_inputTypeStack","_fieldDefStack","_defaultValueStack","_directive","_argument","_enumValue","_getFieldDef","getFieldDef","push","_proto","prototype","getType","length","getParentType","getInputType","getParentInputType","getDefaultValue","getDirective","getArgument","getEnumValue","enter","node","kind","SELECTION_SET","namedType","undefined","FIELD","parentType","fieldDef","fieldType","type","DIRECTIVE","name","value","OPERATION_DEFINITION","operation","getQueryType","getMutationType","getSubscriptionType","INLINE_FRAGMENT","FRAGMENT_DEFINITION","typeConditionAST","typeCondition","outputType","VARIABLE_DEFINITION","inputType","ARGUMENT","_this$getDirective","argDef","argType","fieldOrDirective","args","arg","defaultValue","LIST","listType","itemType","ofType","OBJECT_FIELD","objectType","inputFieldType","inputField","getFields","ENUM","enumType","enumValue","getValue","leave","pop","fieldNode","visitWithTypeInfo","typeInfo","visitor","fn","result","apply","arguments"],"sources":["C:/Users/jarma/school/challenges/Project3_Final/client/src/node_modules/graphql/utilities/TypeInfo.mjs"],"sourcesContent":["import find from \"../polyfills/find.mjs\";\nimport { Kind } from \"../language/kinds.mjs\";\nimport { isNode } from \"../language/ast.mjs\";\nimport { getVisitFn } from \"../language/visitor.mjs\";\nimport { isObjectType, isInterfaceType, isEnumType, isInputObjectType, isListType, isCompositeType, isInputType, isOutputType, getNullableType, getNamedType } from \"../type/definition.mjs\";\nimport { SchemaMetaFieldDef, TypeMetaFieldDef, TypeNameMetaFieldDef } from \"../type/introspection.mjs\";\nimport { typeFromAST } from \"./typeFromAST.mjs\";\n/**\n * TypeInfo is a utility class which, given a GraphQL schema, can keep track\n * of the current field and type definitions at any point in a GraphQL document\n * AST during a recursive descent by calling `enter(node)` and `leave(node)`.\n */\n\nexport var TypeInfo = /*#__PURE__*/function () {\n  function TypeInfo(schema, // NOTE: this experimental optional second parameter is only needed in order\n  // to support non-spec-compliant code bases. You should never need to use it.\n  // It may disappear in the future.\n  getFieldDefFn, // Initial type may be provided in rare cases to facilitate traversals\n  // beginning somewhere other than documents.\n  initialType) {\n    this._schema = schema;\n    this._typeStack = [];\n    this._parentTypeStack = [];\n    this._inputTypeStack = [];\n    this._fieldDefStack = [];\n    this._defaultValueStack = [];\n    this._directive = null;\n    this._argument = null;\n    this._enumValue = null;\n    this._getFieldDef = getFieldDefFn !== null && getFieldDefFn !== void 0 ? getFieldDefFn : getFieldDef;\n\n    if (initialType) {\n      if (isInputType(initialType)) {\n        this._inputTypeStack.push(initialType);\n      }\n\n      if (isCompositeType(initialType)) {\n        this._parentTypeStack.push(initialType);\n      }\n\n      if (isOutputType(initialType)) {\n        this._typeStack.push(initialType);\n      }\n    }\n  }\n\n  var _proto = TypeInfo.prototype;\n\n  _proto.getType = function getType() {\n    if (this._typeStack.length > 0) {\n      return this._typeStack[this._typeStack.length - 1];\n    }\n  };\n\n  _proto.getParentType = function getParentType() {\n    if (this._parentTypeStack.length > 0) {\n      return this._parentTypeStack[this._parentTypeStack.length - 1];\n    }\n  };\n\n  _proto.getInputType = function getInputType() {\n    if (this._inputTypeStack.length > 0) {\n      return this._inputTypeStack[this._inputTypeStack.length - 1];\n    }\n  };\n\n  _proto.getParentInputType = function getParentInputType() {\n    if (this._inputTypeStack.length > 1) {\n      return this._inputTypeStack[this._inputTypeStack.length - 2];\n    }\n  };\n\n  _proto.getFieldDef = function getFieldDef() {\n    if (this._fieldDefStack.length > 0) {\n      return this._fieldDefStack[this._fieldDefStack.length - 1];\n    }\n  };\n\n  _proto.getDefaultValue = function getDefaultValue() {\n    if (this._defaultValueStack.length > 0) {\n      return this._defaultValueStack[this._defaultValueStack.length - 1];\n    }\n  };\n\n  _proto.getDirective = function getDirective() {\n    return this._directive;\n  };\n\n  _proto.getArgument = function getArgument() {\n    return this._argument;\n  };\n\n  _proto.getEnumValue = function getEnumValue() {\n    return this._enumValue;\n  };\n\n  _proto.enter = function enter(node) {\n    var schema = this._schema; // Note: many of the types below are explicitly typed as \"mixed\" to drop\n    // any assumptions of a valid schema to ensure runtime types are properly\n    // checked before continuing since TypeInfo is used as part of validation\n    // which occurs before guarantees of schema and document validity.\n\n    switch (node.kind) {\n      case Kind.SELECTION_SET:\n        {\n          var namedType = getNamedType(this.getType());\n\n          this._parentTypeStack.push(isCompositeType(namedType) ? namedType : undefined);\n\n          break;\n        }\n\n      case Kind.FIELD:\n        {\n          var parentType = this.getParentType();\n          var fieldDef;\n          var fieldType;\n\n          if (parentType) {\n            fieldDef = this._getFieldDef(schema, parentType, node);\n\n            if (fieldDef) {\n              fieldType = fieldDef.type;\n            }\n          }\n\n          this._fieldDefStack.push(fieldDef);\n\n          this._typeStack.push(isOutputType(fieldType) ? fieldType : undefined);\n\n          break;\n        }\n\n      case Kind.DIRECTIVE:\n        this._directive = schema.getDirective(node.name.value);\n        break;\n\n      case Kind.OPERATION_DEFINITION:\n        {\n          var type;\n\n          switch (node.operation) {\n            case 'query':\n              type = schema.getQueryType();\n              break;\n\n            case 'mutation':\n              type = schema.getMutationType();\n              break;\n\n            case 'subscription':\n              type = schema.getSubscriptionType();\n              break;\n          }\n\n          this._typeStack.push(isObjectType(type) ? type : undefined);\n\n          break;\n        }\n\n      case Kind.INLINE_FRAGMENT:\n      case Kind.FRAGMENT_DEFINITION:\n        {\n          var typeConditionAST = node.typeCondition;\n          var outputType = typeConditionAST ? typeFromAST(schema, typeConditionAST) : getNamedType(this.getType());\n\n          this._typeStack.push(isOutputType(outputType) ? outputType : undefined);\n\n          break;\n        }\n\n      case Kind.VARIABLE_DEFINITION:\n        {\n          var inputType = typeFromAST(schema, node.type);\n\n          this._inputTypeStack.push(isInputType(inputType) ? inputType : undefined);\n\n          break;\n        }\n\n      case Kind.ARGUMENT:\n        {\n          var _this$getDirective;\n\n          var argDef;\n          var argType;\n          var fieldOrDirective = (_this$getDirective = this.getDirective()) !== null && _this$getDirective !== void 0 ? _this$getDirective : this.getFieldDef();\n\n          if (fieldOrDirective) {\n            argDef = find(fieldOrDirective.args, function (arg) {\n              return arg.name === node.name.value;\n            });\n\n            if (argDef) {\n              argType = argDef.type;\n            }\n          }\n\n          this._argument = argDef;\n\n          this._defaultValueStack.push(argDef ? argDef.defaultValue : undefined);\n\n          this._inputTypeStack.push(isInputType(argType) ? argType : undefined);\n\n          break;\n        }\n\n      case Kind.LIST:\n        {\n          var listType = getNullableType(this.getInputType());\n          var itemType = isListType(listType) ? listType.ofType : listType; // List positions never have a default value.\n\n          this._defaultValueStack.push(undefined);\n\n          this._inputTypeStack.push(isInputType(itemType) ? itemType : undefined);\n\n          break;\n        }\n\n      case Kind.OBJECT_FIELD:\n        {\n          var objectType = getNamedType(this.getInputType());\n          var inputFieldType;\n          var inputField;\n\n          if (isInputObjectType(objectType)) {\n            inputField = objectType.getFields()[node.name.value];\n\n            if (inputField) {\n              inputFieldType = inputField.type;\n            }\n          }\n\n          this._defaultValueStack.push(inputField ? inputField.defaultValue : undefined);\n\n          this._inputTypeStack.push(isInputType(inputFieldType) ? inputFieldType : undefined);\n\n          break;\n        }\n\n      case Kind.ENUM:\n        {\n          var enumType = getNamedType(this.getInputType());\n          var enumValue;\n\n          if (isEnumType(enumType)) {\n            enumValue = enumType.getValue(node.value);\n          }\n\n          this._enumValue = enumValue;\n          break;\n        }\n    }\n  };\n\n  _proto.leave = function leave(node) {\n    switch (node.kind) {\n      case Kind.SELECTION_SET:\n        this._parentTypeStack.pop();\n\n        break;\n\n      case Kind.FIELD:\n        this._fieldDefStack.pop();\n\n        this._typeStack.pop();\n\n        break;\n\n      case Kind.DIRECTIVE:\n        this._directive = null;\n        break;\n\n      case Kind.OPERATION_DEFINITION:\n      case Kind.INLINE_FRAGMENT:\n      case Kind.FRAGMENT_DEFINITION:\n        this._typeStack.pop();\n\n        break;\n\n      case Kind.VARIABLE_DEFINITION:\n        this._inputTypeStack.pop();\n\n        break;\n\n      case Kind.ARGUMENT:\n        this._argument = null;\n\n        this._defaultValueStack.pop();\n\n        this._inputTypeStack.pop();\n\n        break;\n\n      case Kind.LIST:\n      case Kind.OBJECT_FIELD:\n        this._defaultValueStack.pop();\n\n        this._inputTypeStack.pop();\n\n        break;\n\n      case Kind.ENUM:\n        this._enumValue = null;\n        break;\n    }\n  };\n\n  return TypeInfo;\n}();\n/**\n * Not exactly the same as the executor's definition of getFieldDef, in this\n * statically evaluated environment we do not always have an Object type,\n * and need to handle Interface and Union types.\n */\n\nfunction getFieldDef(schema, parentType, fieldNode) {\n  var name = fieldNode.name.value;\n\n  if (name === SchemaMetaFieldDef.name && schema.getQueryType() === parentType) {\n    return SchemaMetaFieldDef;\n  }\n\n  if (name === TypeMetaFieldDef.name && schema.getQueryType() === parentType) {\n    return TypeMetaFieldDef;\n  }\n\n  if (name === TypeNameMetaFieldDef.name && isCompositeType(parentType)) {\n    return TypeNameMetaFieldDef;\n  }\n\n  if (isObjectType(parentType) || isInterfaceType(parentType)) {\n    return parentType.getFields()[name];\n  }\n}\n/**\n * Creates a new visitor instance which maintains a provided TypeInfo instance\n * along with visiting visitor.\n */\n\n\nexport function visitWithTypeInfo(typeInfo, visitor) {\n  return {\n    enter: function enter(node) {\n      typeInfo.enter(node);\n      var fn = getVisitFn(visitor, node.kind,\n      /* isLeaving */\n      false);\n\n      if (fn) {\n        var result = fn.apply(visitor, arguments);\n\n        if (result !== undefined) {\n          typeInfo.leave(node);\n\n          if (isNode(result)) {\n            typeInfo.enter(result);\n          }\n        }\n\n        return result;\n      }\n    },\n    leave: function leave(node) {\n      var fn = getVisitFn(visitor, node.kind,\n      /* isLeaving */\n      true);\n      var result;\n\n      if (fn) {\n        result = fn.apply(visitor, arguments);\n      }\n\n      typeInfo.leave(node);\n      return result;\n    }\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}