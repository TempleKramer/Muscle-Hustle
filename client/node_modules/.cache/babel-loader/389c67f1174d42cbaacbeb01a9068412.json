{"ast":null,"code":"import{__assign,__spreadArray}from\"tslib\";import{invariant,InvariantError}from\"../globals/index.js\";export function getFragmentQueryDocument(document,fragmentName){var actualFragmentName=fragmentName;var fragments=[];document.definitions.forEach(function(definition){if(definition.kind==='OperationDefinition'){throw __DEV__?new InvariantError(\"Found a \".concat(definition.operation,\" operation\").concat(definition.name?\" named '\".concat(definition.name.value,\"'\"):'',\". \")+'No operations are allowed when using a fragment as a query. Only fragments are allowed.'):new InvariantError(43);}if(definition.kind==='FragmentDefinition'){fragments.push(definition);}});if(typeof actualFragmentName==='undefined'){__DEV__?invariant(fragments.length===1,\"Found \".concat(fragments.length,\" fragments. `fragmentName` must be provided when there is not exactly 1 fragment.\")):invariant(fragments.length===1,44);actualFragmentName=fragments[0].name.value;}var query=__assign(__assign({},document),{definitions:__spreadArray([{kind:'OperationDefinition',operation:'query',selectionSet:{kind:'SelectionSet',selections:[{kind:'FragmentSpread',name:{kind:'Name',value:actualFragmentName}}]}}],document.definitions,true)});return query;}export function createFragmentMap(fragments){if(fragments===void 0){fragments=[];}var symTable={};fragments.forEach(function(fragment){symTable[fragment.name.value]=fragment;});return symTable;}export function getFragmentFromSelection(selection,fragmentMap){switch(selection.kind){case'InlineFragment':return selection;case'FragmentSpread':{var fragmentName=selection.name.value;if(typeof fragmentMap===\"function\"){return fragmentMap(fragmentName);}var fragment=fragmentMap&&fragmentMap[fragmentName];__DEV__?invariant(fragment,\"No fragment named \".concat(fragmentName)):invariant(fragment,45);return fragment||null;}default:return null;}}","map":{"version":3,"mappings":"0CAAA,OAASA,SAAT,CAAoBC,cAApB,KAA0C,qBAA1C,CAkCA,MAAM,SAAUC,yBAAV,CACJC,QADI,CAEJC,YAFI,CAEiB,CAErB,GAAIC,mBAAkB,CAAGD,YAAzB,CAKA,GAAME,UAAS,CAAkC,EAAjD,CACAH,QAAQ,CAACI,WAAT,CAAqBC,OAArB,CAA6B,oBAAU,CAGrC,GAAIC,UAAU,CAACC,IAAX,GAAoB,qBAAxB,CAA+C,CAC7C,KAAMC,QAAI,oBACR,WAAWC,MAAX,CAAqBH,UAAU,UAA/B,CAA+B,YAA/B,EACEG,MADF,CACYH,UAAQ,KAAR,CAAQ,WAAWG,MAAX,CAAqBH,UAAM,CAAKI,IAAX,CAAWC,KAAhC,CAAwC,GAAxC,CAAR,CACR,EAFJ,CAEI,IAFJ,EAGE,yFAJM,EAKR,sBALF,CAMD,CAGD,GAAIL,UAAU,CAACC,IAAX,GAAoB,oBAAxB,CAA8C,CAC5CJ,SAAS,CAACS,IAAV,CAAeN,UAAf,EACD,CACF,CAhBD,EAoBA,GAAI,MAAOJ,mBAAP,GAA8B,WAAlC,CAA+C,CAC7CM,QACEX,SAAS,CAACM,SAAM,OAAN,GACV,CADS,CACT,SACEM,MADF,CACYN,SAAM,OADlB,CACkB,mFADlB,CADS,CADX,CAKEN,kCALF,CAMAK,kBAAkB,CAAGC,SAAS,CAAC,CAAD,CAAT,CAAaO,IAAb,CAAkBC,KAAvC,CACD,CAID,GAAME,MAAK,sBACNb,QADM,EACE,CACXI,WAAW,gBACT,CACEG,IAAI,CAAE,qBADR,CAGEO,SAAS,CAAE,OAHb,CAIEC,YAAY,CAAE,CACZR,IAAI,CAAE,cADM,CAEZS,UAAU,CAAE,CACV,CACET,IAAI,CAAE,gBADR,CAEEG,IAAI,CAAE,CACJH,IAAI,CAAE,MADF,CAEJI,KAAK,CAAET,kBAFH,CAFR,CADU,CAFA,CAJhB,CADS,EAkBNF,QAAQ,CAACI,WAlBH,CAkBc,IAlBd,CADA,CADF,CAAX,CAwBA,MAAOS,MAAP,CACD,CAcD,MAAM,SAAUI,kBAAV,CACJd,SADI,CACoC,CAAxC,oCAAwC,CAExC,GAAMe,SAAQ,CAAgB,EAA9B,CACAf,SAAS,CAACE,OAAV,CAAkB,kBAAQ,CACxBa,QAAQ,CAACC,QAAQ,CAACT,IAAT,CAAcC,KAAf,CAAR,CAAgCQ,QAAhC,CACD,CAFD,EAGA,MAAOD,SAAP,CACD,CAED,MAAM,SAAUE,yBAAV,CACJC,SADI,CAEJC,WAFI,CAE2C,CAE/C,OAAQD,SAAS,CAACd,IAAlB,EACE,IAAK,gBAAL,CACE,MAAOc,UAAP,CACF,IAAK,gBAAL,CAAuB,CACrB,GAAMpB,aAAY,CAAGoB,SAAS,CAACX,IAAV,CAAeC,KAApC,CACA,GAAI,MAAOW,YAAP,GAAuB,UAA3B,CAAuC,CACrC,MAAOA,YAAW,CAACrB,YAAD,CAAlB,CACD,CACD,GAAMkB,SAAQ,CAAGG,WAAW,EAAIA,WAAW,CAACrB,YAAD,CAA3C,CACAO,QAAUX,SAAQ,CAAEsB,QAAF,CAAE,qBAAqBV,MAArB,CAAqBR,YAArB,CAAF,CAAlB,CAAyDJ,sBAAzD,CACA,MAAOsB,SAAQ,EAAI,IAAnB,CACD,CACD,QACE,MAAO,KAAP,CAbJ,CAeD","names":["invariant","InvariantError","getFragmentQueryDocument","document","fragmentName","actualFragmentName","fragments","definitions","forEach","definition","kind","__DEV__","concat","name","value","push","query","operation","selectionSet","selections","createFragmentMap","symTable","fragment","getFragmentFromSelection","selection","fragmentMap"],"sourceRoot":"","sources":["../../../src/utilities/graphql/fragments.ts"],"sourcesContent":["import { invariant, InvariantError } from '../globals';\n\nimport {\n  DocumentNode,\n  FragmentDefinitionNode,\n  InlineFragmentNode,\n  SelectionNode,\n} from 'graphql';\n\n// TODO(brian): A hack until this issue is resolved (https://github.com/graphql/graphql-js/issues/3356)\ntype Kind = any;\ntype OperationTypeNode = any;\n/**\n * Returns a query document which adds a single query operation that only\n * spreads the target fragment inside of it.\n *\n * So for example a document of:\n *\n * ```graphql\n * fragment foo on Foo { a b c }\n * ```\n *\n * Turns into:\n *\n * ```graphql\n * { ...foo }\n *\n * fragment foo on Foo { a b c }\n * ```\n *\n * The target fragment will either be the only fragment in the document, or a\n * fragment specified by the provided `fragmentName`. If there is more than one\n * fragment, but a `fragmentName` was not defined then an error will be thrown.\n */\nexport function getFragmentQueryDocument(\n  document: DocumentNode,\n  fragmentName?: string,\n): DocumentNode {\n  let actualFragmentName = fragmentName;\n\n  // Build an array of all our fragment definitions that will be used for\n  // validations. We also do some validations on the other definitions in the\n  // document while building this list.\n  const fragments: Array<FragmentDefinitionNode> = [];\n  document.definitions.forEach(definition => {\n    // Throw an error if we encounter an operation definition because we will\n    // define our own operation definition later on.\n    if (definition.kind === 'OperationDefinition') {\n      throw new InvariantError(\n        `Found a ${definition.operation} operation${\n          definition.name ? ` named '${definition.name.value}'` : ''\n        }. ` +\n          'No operations are allowed when using a fragment as a query. Only fragments are allowed.',\n      );\n    }\n    // Add our definition to the fragments array if it is a fragment\n    // definition.\n    if (definition.kind === 'FragmentDefinition') {\n      fragments.push(definition);\n    }\n  });\n\n  // If the user did not give us a fragment name then let us try to get a\n  // name from a single fragment in the definition.\n  if (typeof actualFragmentName === 'undefined') {\n    invariant(\n      fragments.length === 1,\n      `Found ${\n        fragments.length\n      } fragments. \\`fragmentName\\` must be provided when there is not exactly 1 fragment.`,\n    );\n    actualFragmentName = fragments[0].name.value;\n  }\n\n  // Generate a query document with an operation that simply spreads the\n  // fragment inside of it.\n  const query: DocumentNode = {\n    ...document,\n    definitions: [\n      {\n        kind: 'OperationDefinition' as Kind,\n        // OperationTypeNode is an enum\n        operation: 'query' as OperationTypeNode,\n        selectionSet: {\n          kind: 'SelectionSet' as Kind,\n          selections: [\n            {\n              kind: 'FragmentSpread' as Kind,\n              name: {\n                kind: 'Name' as Kind,\n                value: actualFragmentName,\n              },\n            },\n          ],\n        },\n      },\n      ...document.definitions,\n    ],\n  };\n\n  return query;\n}\n\n/**\n * This is an interface that describes a map from fragment names to fragment definitions.\n */\nexport interface FragmentMap {\n  [fragmentName: string]: FragmentDefinitionNode;\n}\n\nexport type FragmentMapFunction =\n  (fragmentName: string) => FragmentDefinitionNode | null;\n\n// Utility function that takes a list of fragment definitions and makes a hash out of them\n// that maps the name of the fragment to the fragment definition.\nexport function createFragmentMap(\n  fragments: FragmentDefinitionNode[] = [],\n): FragmentMap {\n  const symTable: FragmentMap = {};\n  fragments.forEach(fragment => {\n    symTable[fragment.name.value] = fragment;\n  });\n  return symTable;\n}\n\nexport function getFragmentFromSelection(\n  selection: SelectionNode,\n  fragmentMap?: FragmentMap | FragmentMapFunction,\n): InlineFragmentNode | FragmentDefinitionNode | null {\n  switch (selection.kind) {\n    case 'InlineFragment':\n      return selection;\n    case 'FragmentSpread': {\n      const fragmentName = selection.name.value;\n      if (typeof fragmentMap === \"function\") {\n        return fragmentMap(fragmentName);\n      }\n      const fragment = fragmentMap && fragmentMap[fragmentName];\n      invariant(fragment, `No fragment named ${fragmentName}`);\n      return fragment || null;\n    }\n    default:\n      return null;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}