{"ast":null,"code":"import{Kind}from\"../language/kinds.mjs\";import{visit}from\"../language/visitor.mjs\";/**\n * separateOperations accepts a single AST document which may contain many\n * operations and fragments and returns a collection of AST documents each of\n * which contains a single operation as well the fragment definitions it\n * refers to.\n */export function separateOperations(documentAST){var operations=[];var depGraph=Object.create(null);// Populate metadata and build a dependency graph.\nfor(var _i2=0,_documentAST$definiti2=documentAST.definitions;_i2<_documentAST$definiti2.length;_i2++){var definitionNode=_documentAST$definiti2[_i2];switch(definitionNode.kind){case Kind.OPERATION_DEFINITION:operations.push(definitionNode);break;case Kind.FRAGMENT_DEFINITION:depGraph[definitionNode.name.value]=collectDependencies(definitionNode.selectionSet);break;}}// For each operation, produce a new synthesized AST which includes only what\n// is necessary for completing that operation.\nvar separatedDocumentASTs=Object.create(null);var _loop=function _loop(_i4){var operation=operations[_i4];var dependencies=new Set();for(var _i6=0,_collectDependencies2=collectDependencies(operation.selectionSet);_i6<_collectDependencies2.length;_i6++){var fragmentName=_collectDependencies2[_i6];collectTransitiveDependencies(dependencies,depGraph,fragmentName);}// Provides the empty string for anonymous operations.\nvar operationName=operation.name?operation.name.value:'';// The list of definition nodes to be included for this operation, sorted\n// to retain the same order as the original document.\nseparatedDocumentASTs[operationName]={kind:Kind.DOCUMENT,definitions:documentAST.definitions.filter(function(node){return node===operation||node.kind===Kind.FRAGMENT_DEFINITION&&dependencies.has(node.name.value);})};};for(var _i4=0;_i4<operations.length;_i4++){_loop(_i4);}return separatedDocumentASTs;}// From a dependency graph, collects a list of transitive dependencies by\n// recursing through a dependency graph.\nfunction collectTransitiveDependencies(collected,depGraph,fromName){if(!collected.has(fromName)){collected.add(fromName);var immediateDeps=depGraph[fromName];if(immediateDeps!==undefined){for(var _i8=0;_i8<immediateDeps.length;_i8++){var toName=immediateDeps[_i8];collectTransitiveDependencies(collected,depGraph,toName);}}}}function collectDependencies(selectionSet){var dependencies=[];visit(selectionSet,{FragmentSpread:function FragmentSpread(node){dependencies.push(node.name.value);}});return dependencies;}","map":{"version":3,"names":["Kind","visit","separateOperations","documentAST","operations","depGraph","Object","create","_i2","_documentAST$definiti2","definitions","length","definitionNode","kind","OPERATION_DEFINITION","push","FRAGMENT_DEFINITION","name","value","collectDependencies","selectionSet","separatedDocumentASTs","_loop","_i4","operation","dependencies","Set","_i6","_collectDependencies2","fragmentName","collectTransitiveDependencies","operationName","DOCUMENT","filter","node","has","collected","fromName","add","immediateDeps","undefined","_i8","toName","FragmentSpread"],"sources":["C:/Users/jarma/school/challenges/Project3_Final/client/src/node_modules/graphql/utilities/separateOperations.mjs"],"sourcesContent":["import { Kind } from \"../language/kinds.mjs\";\nimport { visit } from \"../language/visitor.mjs\";\n/**\n * separateOperations accepts a single AST document which may contain many\n * operations and fragments and returns a collection of AST documents each of\n * which contains a single operation as well the fragment definitions it\n * refers to.\n */\n\nexport function separateOperations(documentAST) {\n  var operations = [];\n  var depGraph = Object.create(null); // Populate metadata and build a dependency graph.\n\n  for (var _i2 = 0, _documentAST$definiti2 = documentAST.definitions; _i2 < _documentAST$definiti2.length; _i2++) {\n    var definitionNode = _documentAST$definiti2[_i2];\n\n    switch (definitionNode.kind) {\n      case Kind.OPERATION_DEFINITION:\n        operations.push(definitionNode);\n        break;\n\n      case Kind.FRAGMENT_DEFINITION:\n        depGraph[definitionNode.name.value] = collectDependencies(definitionNode.selectionSet);\n        break;\n    }\n  } // For each operation, produce a new synthesized AST which includes only what\n  // is necessary for completing that operation.\n\n\n  var separatedDocumentASTs = Object.create(null);\n\n  var _loop = function _loop(_i4) {\n    var operation = operations[_i4];\n    var dependencies = new Set();\n\n    for (var _i6 = 0, _collectDependencies2 = collectDependencies(operation.selectionSet); _i6 < _collectDependencies2.length; _i6++) {\n      var fragmentName = _collectDependencies2[_i6];\n      collectTransitiveDependencies(dependencies, depGraph, fragmentName);\n    } // Provides the empty string for anonymous operations.\n\n\n    var operationName = operation.name ? operation.name.value : ''; // The list of definition nodes to be included for this operation, sorted\n    // to retain the same order as the original document.\n\n    separatedDocumentASTs[operationName] = {\n      kind: Kind.DOCUMENT,\n      definitions: documentAST.definitions.filter(function (node) {\n        return node === operation || node.kind === Kind.FRAGMENT_DEFINITION && dependencies.has(node.name.value);\n      })\n    };\n  };\n\n  for (var _i4 = 0; _i4 < operations.length; _i4++) {\n    _loop(_i4);\n  }\n\n  return separatedDocumentASTs;\n}\n\n// From a dependency graph, collects a list of transitive dependencies by\n// recursing through a dependency graph.\nfunction collectTransitiveDependencies(collected, depGraph, fromName) {\n  if (!collected.has(fromName)) {\n    collected.add(fromName);\n    var immediateDeps = depGraph[fromName];\n\n    if (immediateDeps !== undefined) {\n      for (var _i8 = 0; _i8 < immediateDeps.length; _i8++) {\n        var toName = immediateDeps[_i8];\n        collectTransitiveDependencies(collected, depGraph, toName);\n      }\n    }\n  }\n}\n\nfunction collectDependencies(selectionSet) {\n  var dependencies = [];\n  visit(selectionSet, {\n    FragmentSpread: function FragmentSpread(node) {\n      dependencies.push(node.name.value);\n    }\n  });\n  return dependencies;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}