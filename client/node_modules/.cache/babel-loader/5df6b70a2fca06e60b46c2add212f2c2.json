{"ast":null,"code":"import{serializeFetchParameter}from\"./serializeFetchParameter.js\";export function rewriteURIForGET(chosenURI,body){var queryParams=[];var addQueryParam=function addQueryParam(key,value){queryParams.push(\"\".concat(key,\"=\").concat(encodeURIComponent(value)));};if('query'in body){addQueryParam('query',body.query);}if(body.operationName){addQueryParam('operationName',body.operationName);}if(body.variables){var serializedVariables=void 0;try{serializedVariables=serializeFetchParameter(body.variables,'Variables map');}catch(parseError){return{parseError:parseError};}addQueryParam('variables',serializedVariables);}if(body.extensions){var serializedExtensions=void 0;try{serializedExtensions=serializeFetchParameter(body.extensions,'Extensions map');}catch(parseError){return{parseError:parseError};}addQueryParam('extensions',serializedExtensions);}var fragment='',preFragment=chosenURI;var fragmentStart=chosenURI.indexOf('#');if(fragmentStart!==-1){fragment=chosenURI.substr(fragmentStart);preFragment=chosenURI.substr(0,fragmentStart);}var queryParamsPrefix=preFragment.indexOf('?')===-1?'?':'&';var newURI=preFragment+queryParamsPrefix+queryParams.join('&')+fragment;return{newURI:newURI};}","map":{"version":3,"mappings":"AAAA,OAASA,uBAAT,KAAwC,8BAAxC,CAKA,MAAM,SAAUC,iBAAV,CAA2BC,SAA3B,CAA8CC,IAA9C,CAAwD,CAG5D,GAAMC,YAAW,CAAa,EAA9B,CACA,GAAMC,cAAa,CAAG,QAAhBA,cAAgB,CAACC,GAAD,CAAcC,KAAd,CAA2B,CAC/CH,WAAW,CAACI,IAAZ,CAAiB,UAAGF,GAAH,CAAM,GAAN,EAAMG,MAAN,CAAUC,kBAAkB,CAACH,KAAD,CAA5B,CAAjB,EACD,CAFD,CAIA,GAAI,SAAWJ,KAAf,CAAqB,CACnBE,aAAa,CAAC,OAAD,CAAUF,IAAI,CAACQ,KAAf,CAAb,CACD,CACD,GAAIR,IAAI,CAACS,aAAT,CAAwB,CACtBP,aAAa,CAAC,eAAD,CAAkBF,IAAI,CAACS,aAAvB,CAAb,CACD,CACD,GAAIT,IAAI,CAACU,SAAT,CAAoB,CAClB,GAAIC,oBAAmB,OAAvB,CACA,GAAI,CACFA,mBAAmB,CAAGd,uBAAuB,CAC3CG,IAAI,CAACU,SADsC,CAE3C,eAF2C,CAA7C,CAID,CAAC,MAAOE,UAAP,CAAmB,CACnB,MAAO,CAAEA,UAAU,WAAZ,CAAP,CACD,CACDV,aAAa,CAAC,WAAD,CAAcS,mBAAd,CAAb,CACD,CACD,GAAIX,IAAI,CAACa,UAAT,CAAqB,CACnB,GAAIC,qBAAoB,OAAxB,CACA,GAAI,CACFA,oBAAoB,CAAGjB,uBAAuB,CAC5CG,IAAI,CAACa,UADuC,CAE5C,gBAF4C,CAA9C,CAID,CAAC,MAAOD,UAAP,CAAmB,CACnB,MAAO,CAAEA,UAAU,WAAZ,CAAP,CACD,CACDV,aAAa,CAAC,YAAD,CAAeY,oBAAf,CAAb,CACD,CAQD,GAAIC,SAAQ,CAAG,EAAf,CACEC,WAAW,CAAGjB,SADhB,CAEA,GAAMkB,cAAa,CAAGlB,SAAS,CAACmB,OAAV,CAAkB,GAAlB,CAAtB,CACA,GAAID,aAAa,GAAK,CAAC,CAAvB,CAA0B,CACxBF,QAAQ,CAAGhB,SAAS,CAACoB,MAAV,CAAiBF,aAAjB,CAAX,CACAD,WAAW,CAAGjB,SAAS,CAACoB,MAAV,CAAiB,CAAjB,CAAoBF,aAApB,CAAd,CACD,CACD,GAAMG,kBAAiB,CAAGJ,WAAW,CAACE,OAAZ,CAAoB,GAApB,IAA6B,CAAC,CAA9B,CAAkC,GAAlC,CAAwC,GAAlE,CACA,GAAMG,OAAM,CACVL,WAAW,CAAGI,iBAAd,CAAkCnB,WAAW,CAACqB,IAAZ,CAAiB,GAAjB,CAAlC,CAA0DP,QAD5D,CAEA,MAAO,CAAEM,MAAM,OAAR,CAAP,CACD","names":["serializeFetchParameter","rewriteURIForGET","chosenURI","body","queryParams","addQueryParam","key","value","push","concat","encodeURIComponent","query","operationName","variables","serializedVariables","parseError","extensions","serializedExtensions","fragment","preFragment","fragmentStart","indexOf","substr","queryParamsPrefix","newURI","join"],"sourceRoot":"","sources":["../../../src/link/http/rewriteURIForGET.ts"],"sourcesContent":["import { serializeFetchParameter } from './serializeFetchParameter';\nimport { Body } from './selectHttpOptionsAndBody';\n\n// For GET operations, returns the given URI rewritten with parameters, or a\n// parse error.\nexport function rewriteURIForGET(chosenURI: string, body: Body) {\n  // Implement the standard HTTP GET serialization, plus 'extensions'. Note\n  // the extra level of JSON serialization!\n  const queryParams: string[] = [];\n  const addQueryParam = (key: string, value: string) => {\n    queryParams.push(`${key}=${encodeURIComponent(value)}`);\n  };\n\n  if ('query' in body) {\n    addQueryParam('query', body.query!);\n  }\n  if (body.operationName) {\n    addQueryParam('operationName', body.operationName);\n  }\n  if (body.variables) {\n    let serializedVariables;\n    try {\n      serializedVariables = serializeFetchParameter(\n        body.variables,\n        'Variables map',\n      );\n    } catch (parseError) {\n      return { parseError };\n    }\n    addQueryParam('variables', serializedVariables);\n  }\n  if (body.extensions) {\n    let serializedExtensions;\n    try {\n      serializedExtensions = serializeFetchParameter(\n        body.extensions,\n        'Extensions map',\n      );\n    } catch (parseError) {\n      return { parseError };\n    }\n    addQueryParam('extensions', serializedExtensions);\n  }\n\n  // Reconstruct the URI with added query params.\n  // XXX This assumes that the URI is well-formed and that it doesn't\n  //     already contain any of these query params. We could instead use the\n  //     URL API and take a polyfill (whatwg-url@6) for older browsers that\n  //     don't support URLSearchParams. Note that some browsers (and\n  //     versions of whatwg-url) support URL but not URLSearchParams!\n  let fragment = '',\n    preFragment = chosenURI;\n  const fragmentStart = chosenURI.indexOf('#');\n  if (fragmentStart !== -1) {\n    fragment = chosenURI.substr(fragmentStart);\n    preFragment = chosenURI.substr(0, fragmentStart);\n  }\n  const queryParamsPrefix = preFragment.indexOf('?') === -1 ? '?' : '&';\n  const newURI =\n    preFragment + queryParamsPrefix + queryParams.join('&') + fragment;\n  return { newURI };\n}\n"]},"metadata":{},"sourceType":"module"}