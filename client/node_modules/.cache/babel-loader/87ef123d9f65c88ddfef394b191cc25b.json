{"ast":null,"code":"import{invariant}from\"../../utilities/globals/index.js\";import{argumentsObjectFromField,DeepMerger,isNonEmptyArray,isNonNullObject}from\"../../utilities/index.js\";import{hasOwn,isArray}from\"./helpers.js\";var specifierInfoCache=Object.create(null);function lookupSpecifierInfo(spec){var cacheKey=JSON.stringify(spec);return specifierInfoCache[cacheKey]||(specifierInfoCache[cacheKey]=Object.create(null));}export function keyFieldsFnFromSpecifier(specifier){var info=lookupSpecifierInfo(specifier);return info.keyFieldsFn||(info.keyFieldsFn=function(object,context){var extract=function extract(from,key){return context.readField(key,from);};var keyObject=context.keyObject=collectSpecifierPaths(specifier,function(schemaKeyPath){var extracted=extractKeyPath(context.storeObject,schemaKeyPath,extract);if(extracted===void 0&&object!==context.storeObject&&hasOwn.call(object,schemaKeyPath[0])){extracted=extractKeyPath(object,schemaKeyPath,extractKey);}__DEV__?invariant(extracted!==void 0,\"Missing field '\".concat(schemaKeyPath.join('.'),\"' while extracting keyFields from \").concat(JSON.stringify(object))):invariant(extracted!==void 0,2);return extracted;});return\"\".concat(context.typename,\":\").concat(JSON.stringify(keyObject));});}export function keyArgsFnFromSpecifier(specifier){var info=lookupSpecifierInfo(specifier);return info.keyArgsFn||(info.keyArgsFn=function(args,_a){var field=_a.field,variables=_a.variables,fieldName=_a.fieldName;var collected=collectSpecifierPaths(specifier,function(keyPath){var firstKey=keyPath[0];var firstChar=firstKey.charAt(0);if(firstChar===\"@\"){if(field&&isNonEmptyArray(field.directives)){var directiveName_1=firstKey.slice(1);var d=field.directives.find(function(d){return d.name.value===directiveName_1;});var directiveArgs=d&&argumentsObjectFromField(d,variables);return directiveArgs&&extractKeyPath(directiveArgs,keyPath.slice(1));}return;}if(firstChar===\"$\"){var variableName=firstKey.slice(1);if(variables&&hasOwn.call(variables,variableName)){var varKeyPath=keyPath.slice(0);varKeyPath[0]=variableName;return extractKeyPath(variables,varKeyPath);}return;}if(args){return extractKeyPath(args,keyPath);}});var suffix=JSON.stringify(collected);if(args||suffix!==\"{}\"){fieldName+=\":\"+suffix;}return fieldName;});}export function collectSpecifierPaths(specifier,extractor){var merger=new DeepMerger();return getSpecifierPaths(specifier).reduce(function(collected,path){var _a;var toMerge=extractor(path);if(toMerge!==void 0){for(var i=path.length-1;i>=0;--i){toMerge=(_a={},_a[path[i]]=toMerge,_a);}collected=merger.merge(collected,toMerge);}return collected;},Object.create(null));}export function getSpecifierPaths(spec){var info=lookupSpecifierInfo(spec);if(!info.paths){var paths_1=info.paths=[];var currentPath_1=[];spec.forEach(function(s,i){if(isArray(s)){getSpecifierPaths(s).forEach(function(p){return paths_1.push(currentPath_1.concat(p));});currentPath_1.length=0;}else{currentPath_1.push(s);if(!isArray(spec[i+1])){paths_1.push(currentPath_1.slice(0));currentPath_1.length=0;}}});}return info.paths;}function extractKey(object,key){return object[key];}export function extractKeyPath(object,path,extract){extract=extract||extractKey;return normalize(path.reduce(function reducer(obj,key){return isArray(obj)?obj.map(function(child){return reducer(child,key);}):obj&&extract(obj,key);},object));}function normalize(value){if(isNonNullObject(value)){if(isArray(value)){return value.map(normalize);}return collectSpecifierPaths(Object.keys(value).sort(),function(path){return extractKeyPath(value,path);});}return value;}","map":{"version":3,"mappings":"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","names":["invariant","argumentsObjectFromField","DeepMerger","isNonEmptyArray","isNonNullObject","hasOwn","isArray","specifierInfoCache","Object","create","lookupSpecifierInfo","spec","cacheKey","JSON","stringify","keyFieldsFnFromSpecifier","specifier","info","keyFieldsFn","object","context","extract","from","key","readField","keyObject","collectSpecifierPaths","extracted","extractKeyPath","storeObject","schemaKeyPath","call","extractKey","__DEV__","concat","typename","keyArgsFnFromSpecifier","keyArgsFn","args","_a","field","variables","fieldName","collected","firstKey","keyPath","firstChar","charAt","directives","directiveName_1","slice","d","find","name","value","directiveArgs","variableName","varKeyPath","suffix","extractor","merger","getSpecifierPaths","reduce","path","toMerge","i","length","merge","paths","paths_1","currentPath_1","forEach","s","push","p","normalize","reducer","obj","map","child","keys","sort"],"sourceRoot":"","sources":["../../../src/cache/inmemory/key-extractor.ts"],"sourcesContent":["import { invariant } from \"../../utilities/globals\";\n\nimport {\n  argumentsObjectFromField,\n  DeepMerger,\n  isNonEmptyArray,\n  isNonNullObject,\n} from \"../../utilities\";\n\nimport { hasOwn, isArray } from \"./helpers\";\nimport {\n  KeySpecifier,\n  KeyFieldsFunction,\n  KeyArgsFunction,\n} from \"./policies\";\n\n// Mapping from JSON-encoded KeySpecifier strings to associated information.\nconst specifierInfoCache: Record<string, {\n  paths?: string[][];\n  keyFieldsFn?: KeyFieldsFunction;\n  keyArgsFn?: KeyArgsFunction;\n}> = Object.create(null);\n\nfunction lookupSpecifierInfo(spec: KeySpecifier) {\n  // It's safe to encode KeySpecifier arrays with JSON.stringify, since they're\n  // just arrays of strings or nested KeySpecifier arrays, and the order of the\n  // array elements is important (and suitably preserved by JSON.stringify).\n  const cacheKey = JSON.stringify(spec);\n  return specifierInfoCache[cacheKey] ||\n    (specifierInfoCache[cacheKey] = Object.create(null));\n}\n\nexport function keyFieldsFnFromSpecifier(\n  specifier: KeySpecifier,\n): KeyFieldsFunction {\n  const info = lookupSpecifierInfo(specifier);\n\n  return info.keyFieldsFn || (info.keyFieldsFn = (\n    object,\n    context,\n  ) => {\n    const extract: typeof extractKey =\n      (from, key) => context.readField(key, from);\n\n    const keyObject = context.keyObject = collectSpecifierPaths(\n      specifier,\n      schemaKeyPath => {\n        let extracted = extractKeyPath(\n          context.storeObject,\n          schemaKeyPath,\n          // Using context.readField to extract paths from context.storeObject\n          // allows the extraction to see through Reference objects and respect\n          // custom read functions.\n          extract,\n        );\n\n        if (\n          extracted === void 0 &&\n          object !== context.storeObject &&\n          hasOwn.call(object, schemaKeyPath[0])\n        ) {\n          // If context.storeObject fails to provide a value for the requested\n          // path, fall back to the raw result object, if it has a top-level key\n          // matching the first key in the path (schemaKeyPath[0]). This allows\n          // key fields included in the written data to be saved in the cache\n          // even if they are not selected explicitly in context.selectionSet.\n          // Not being mentioned by context.selectionSet is convenient here,\n          // since it means these extra fields cannot be affected by field\n          // aliasing, which is why we can use extractKey instead of\n          // context.readField for this extraction.\n          extracted = extractKeyPath(object, schemaKeyPath, extractKey);\n        }\n\n        invariant(\n          extracted !== void 0,\n          `Missing field '${schemaKeyPath.join('.')}' while extracting keyFields from ${\n            JSON.stringify(object)\n          }`,\n        );\n\n        return extracted;\n      },\n    );\n\n    return `${context.typename}:${JSON.stringify(keyObject)}`;\n  });\n}\n\n// The keyArgs extraction process is roughly analogous to keyFields extraction,\n// but there are no aliases involved, missing fields are tolerated (by merely\n// omitting them from the key), and drawing from field.directives or variables\n// is allowed (in addition to drawing from the field's arguments object).\n// Concretely, these differences mean passing a different key path extractor\n// function to collectSpecifierPaths, reusing the shared extractKeyPath helper\n// wherever possible.\nexport function keyArgsFnFromSpecifier(specifier: KeySpecifier): KeyArgsFunction {\n  const info = lookupSpecifierInfo(specifier);\n\n  return info.keyArgsFn || (info.keyArgsFn = (args, {\n    field,\n    variables,\n    fieldName,\n  }) => {\n    const collected = collectSpecifierPaths(specifier, keyPath => {\n      const firstKey = keyPath[0];\n      const firstChar = firstKey.charAt(0);\n\n      if (firstChar === \"@\") {\n        if (field && isNonEmptyArray(field.directives)) {\n          const directiveName = firstKey.slice(1);\n          // If the directive appears multiple times, only the first\n          // occurrence's arguments will be used. TODO Allow repetition?\n          // TODO Cache this work somehow, a la aliasMap?\n          const d = field.directives.find(d => d.name.value === directiveName);\n          // Fortunately argumentsObjectFromField works for DirectiveNode!\n          const directiveArgs = d && argumentsObjectFromField(d, variables);\n          // For directives without arguments (d defined, but directiveArgs ===\n          // null), the presence or absence of the directive still counts as\n          // part of the field key, so we return null in those cases. If no\n          // directive with this name was found for this field (d undefined and\n          // thus directiveArgs undefined), we return undefined, which causes\n          // this value to be omitted from the key object returned by\n          // collectSpecifierPaths.\n          return directiveArgs && extractKeyPath(\n            directiveArgs,\n            // If keyPath.length === 1, this code calls extractKeyPath with an\n            // empty path, which works because it uses directiveArgs as the\n            // extracted value.\n            keyPath.slice(1),\n          );\n        }\n        // If the key started with @ but there was no corresponding directive,\n        // we want to omit this value from the key object, not fall through to\n        // treating @whatever as a normal argument name.\n        return;\n      }\n\n      if (firstChar === \"$\") {\n        const variableName = firstKey.slice(1);\n        if (variables && hasOwn.call(variables, variableName)) {\n          const varKeyPath = keyPath.slice(0);\n          varKeyPath[0] = variableName;\n          return extractKeyPath(variables, varKeyPath);\n        }\n        // If the key started with $ but there was no corresponding variable, we\n        // want to omit this value from the key object, not fall through to\n        // treating $whatever as a normal argument name.\n        return;\n      }\n\n      if (args) {\n        return extractKeyPath(args, keyPath);\n      }\n    });\n\n    const suffix = JSON.stringify(collected);\n\n    // If no arguments were passed to this field, and it didn't have any other\n    // field key contributions from directives or variables, hide the empty\n    // :{} suffix from the field key. However, a field passed no arguments can\n    // still end up with a non-empty :{...} suffix if its key configuration\n    // refers to directives or variables.\n    if (args || suffix !== \"{}\") {\n      fieldName += \":\" + suffix;\n    }\n\n    return fieldName;\n  });\n}\n\nexport function collectSpecifierPaths(\n  specifier: KeySpecifier,\n  extractor: (path: string[]) => any,\n): Record<string, any> {\n  // For each path specified by specifier, invoke the extractor, and repeatedly\n  // merge the results together, with appropriate ancestor context.\n  const merger = new DeepMerger;\n  return getSpecifierPaths(specifier).reduce((collected, path) => {\n    let toMerge = extractor(path);\n    if (toMerge !== void 0) {\n      // This path is not expected to contain array indexes, so the toMerge\n      // reconstruction will not contain arrays. TODO Fix this?\n      for (let i = path.length - 1; i >= 0; --i) {\n        toMerge = { [path[i]]: toMerge };\n      }\n      collected = merger.merge(collected, toMerge);\n    }\n    return collected;\n  }, Object.create(null));\n}\n\nexport function getSpecifierPaths(spec: KeySpecifier): string[][] {\n  const info = lookupSpecifierInfo(spec);\n\n  if (!info.paths) {\n    const paths: string[][] = info.paths = [];\n    const currentPath: string[] = [];\n\n    spec.forEach((s, i) => {\n      if (isArray(s)) {\n        getSpecifierPaths(s).forEach(p => paths.push(currentPath.concat(p)));\n        currentPath.length = 0;\n      } else {\n        currentPath.push(s);\n        if (!isArray(spec[i + 1])) {\n          paths.push(currentPath.slice(0));\n          currentPath.length = 0;\n        }\n      }\n    });\n  }\n\n  return info.paths!;\n}\n\nfunction extractKey<\n  TObj extends Record<string, any>,\n  TKey extends string,\n>(object: TObj, key: TKey): TObj[TKey] | undefined {\n  return object[key];\n}\n\nexport function extractKeyPath(\n  object: Record<string, any>,\n  path: string[],\n  extract?: typeof extractKey,\n): any {\n  // For each key in path, extract the corresponding child property from obj,\n  // flattening arrays if encountered (uncommon for keyFields and keyArgs, but\n  // possible). The final result of path.reduce is normalized so unexpected leaf\n  // objects have their keys safely sorted. That final result is difficult to\n  // type as anything other than any. You're welcome to try to improve the\n  // return type, but keep in mind extractKeyPath is not a public function\n  // (exported only for testing), so the effort may not be worthwhile unless the\n  // limited set of actual callers (see above) pass arguments that TypeScript\n  // can statically type. If we know only that path is some array of strings\n  // (and not, say, a specific tuple of statically known strings), any (or\n  // possibly unknown) is the honest answer.\n  extract = extract || extractKey;\n  return normalize(path.reduce(function reducer(obj, key): any {\n    return isArray(obj)\n      ? obj.map(child => reducer(child, key))\n      : obj && extract!(obj, key);\n  }, object));\n}\n\nfunction normalize<T>(value: T): T {\n  // Usually the extracted value will be a scalar value, since most primary\n  // key fields are scalar, but just in case we get an object or an array, we\n  // need to do some normalization of the order of (nested) keys.\n  if (isNonNullObject(value)) {\n    if (isArray(value)) {\n      return value.map(normalize) as any;\n    }\n    return collectSpecifierPaths(\n      Object.keys(value).sort(),\n      path => extractKeyPath(value, path),\n    ) as T;\n  }\n  return value;\n}\n"]},"metadata":{},"sourceType":"module"}