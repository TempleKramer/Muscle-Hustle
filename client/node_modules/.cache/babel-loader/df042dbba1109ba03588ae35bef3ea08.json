{"ast":null,"code":"import{GraphQLError}from\"../../error/GraphQLError.mjs\";import{Kind}from\"../../language/kinds.mjs\";import{isTypeDefinitionNode,isTypeExtensionNode}from\"../../language/predicates.mjs\";import{specifiedDirectives}from\"../../type/directives.mjs\";/**\n * Unique directive names per location\n *\n * A GraphQL document is only valid if all non-repeatable directives at\n * a given location are uniquely named.\n */export function UniqueDirectivesPerLocationRule(context){var uniqueDirectiveMap=Object.create(null);var schema=context.getSchema();var definedDirectives=schema?schema.getDirectives():specifiedDirectives;for(var _i2=0;_i2<definedDirectives.length;_i2++){var directive=definedDirectives[_i2];uniqueDirectiveMap[directive.name]=!directive.isRepeatable;}var astDefinitions=context.getDocument().definitions;for(var _i4=0;_i4<astDefinitions.length;_i4++){var def=astDefinitions[_i4];if(def.kind===Kind.DIRECTIVE_DEFINITION){uniqueDirectiveMap[def.name.value]=!def.repeatable;}}var schemaDirectives=Object.create(null);var typeDirectivesMap=Object.create(null);return{// Many different AST nodes may contain directives. Rather than listing\n// them all, just listen for entering any node, and check to see if it\n// defines any directives.\nenter:function enter(node){if(node.directives==null){return;}var seenDirectives;if(node.kind===Kind.SCHEMA_DEFINITION||node.kind===Kind.SCHEMA_EXTENSION){seenDirectives=schemaDirectives;}else if(isTypeDefinitionNode(node)||isTypeExtensionNode(node)){var typeName=node.name.value;seenDirectives=typeDirectivesMap[typeName];if(seenDirectives===undefined){typeDirectivesMap[typeName]=seenDirectives=Object.create(null);}}else{seenDirectives=Object.create(null);}for(var _i6=0,_node$directives2=node.directives;_i6<_node$directives2.length;_i6++){var _directive=_node$directives2[_i6];var directiveName=_directive.name.value;if(uniqueDirectiveMap[directiveName]){if(seenDirectives[directiveName]){context.reportError(new GraphQLError(\"The directive \\\"@\".concat(directiveName,\"\\\" can only be used once at this location.\"),[seenDirectives[directiveName],_directive]));}else{seenDirectives[directiveName]=_directive;}}}}};}","map":{"version":3,"names":["GraphQLError","Kind","isTypeDefinitionNode","isTypeExtensionNode","specifiedDirectives","UniqueDirectivesPerLocationRule","context","uniqueDirectiveMap","Object","create","schema","getSchema","definedDirectives","getDirectives","_i2","length","directive","name","isRepeatable","astDefinitions","getDocument","definitions","_i4","def","kind","DIRECTIVE_DEFINITION","value","repeatable","schemaDirectives","typeDirectivesMap","enter","node","directives","seenDirectives","SCHEMA_DEFINITION","SCHEMA_EXTENSION","typeName","undefined","_i6","_node$directives2","_directive","directiveName","reportError","concat"],"sources":["C:/Users/jarma/school/challenges/Project3_Final/client/src/node_modules/graphql/validation/rules/UniqueDirectivesPerLocationRule.mjs"],"sourcesContent":["import { GraphQLError } from \"../../error/GraphQLError.mjs\";\nimport { Kind } from \"../../language/kinds.mjs\";\nimport { isTypeDefinitionNode, isTypeExtensionNode } from \"../../language/predicates.mjs\";\nimport { specifiedDirectives } from \"../../type/directives.mjs\";\n\n/**\n * Unique directive names per location\n *\n * A GraphQL document is only valid if all non-repeatable directives at\n * a given location are uniquely named.\n */\nexport function UniqueDirectivesPerLocationRule(context) {\n  var uniqueDirectiveMap = Object.create(null);\n  var schema = context.getSchema();\n  var definedDirectives = schema ? schema.getDirectives() : specifiedDirectives;\n\n  for (var _i2 = 0; _i2 < definedDirectives.length; _i2++) {\n    var directive = definedDirectives[_i2];\n    uniqueDirectiveMap[directive.name] = !directive.isRepeatable;\n  }\n\n  var astDefinitions = context.getDocument().definitions;\n\n  for (var _i4 = 0; _i4 < astDefinitions.length; _i4++) {\n    var def = astDefinitions[_i4];\n\n    if (def.kind === Kind.DIRECTIVE_DEFINITION) {\n      uniqueDirectiveMap[def.name.value] = !def.repeatable;\n    }\n  }\n\n  var schemaDirectives = Object.create(null);\n  var typeDirectivesMap = Object.create(null);\n  return {\n    // Many different AST nodes may contain directives. Rather than listing\n    // them all, just listen for entering any node, and check to see if it\n    // defines any directives.\n    enter: function enter(node) {\n      if (node.directives == null) {\n        return;\n      }\n\n      var seenDirectives;\n\n      if (node.kind === Kind.SCHEMA_DEFINITION || node.kind === Kind.SCHEMA_EXTENSION) {\n        seenDirectives = schemaDirectives;\n      } else if (isTypeDefinitionNode(node) || isTypeExtensionNode(node)) {\n        var typeName = node.name.value;\n        seenDirectives = typeDirectivesMap[typeName];\n\n        if (seenDirectives === undefined) {\n          typeDirectivesMap[typeName] = seenDirectives = Object.create(null);\n        }\n      } else {\n        seenDirectives = Object.create(null);\n      }\n\n      for (var _i6 = 0, _node$directives2 = node.directives; _i6 < _node$directives2.length; _i6++) {\n        var _directive = _node$directives2[_i6];\n        var directiveName = _directive.name.value;\n\n        if (uniqueDirectiveMap[directiveName]) {\n          if (seenDirectives[directiveName]) {\n            context.reportError(new GraphQLError(\"The directive \\\"@\".concat(directiveName, \"\\\" can only be used once at this location.\"), [seenDirectives[directiveName], _directive]));\n          } else {\n            seenDirectives[directiveName] = _directive;\n          }\n        }\n      }\n    }\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}