{"ast":null,"code":"import find from\"../../polyfills/find.mjs\";import objectEntries from\"../../polyfills/objectEntries.mjs\";import inspect from\"../../jsutils/inspect.mjs\";import{GraphQLError}from\"../../error/GraphQLError.mjs\";import{Kind}from\"../../language/kinds.mjs\";import{print}from\"../../language/printer.mjs\";import{getNamedType,isNonNullType,isLeafType,isObjectType,isListType,isInterfaceType}from\"../../type/definition.mjs\";import{typeFromAST}from\"../../utilities/typeFromAST.mjs\";function reasonMessage(reason){if(Array.isArray(reason)){return reason.map(function(_ref){var responseName=_ref[0],subReason=_ref[1];return\"subfields \\\"\".concat(responseName,\"\\\" conflict because \")+reasonMessage(subReason);}).join(' and ');}return reason;}/**\n * Overlapping fields can be merged\n *\n * A selection set is only valid if all fields (including spreading any\n * fragments) either correspond to distinct response names or can be merged\n * without ambiguity.\n */export function OverlappingFieldsCanBeMergedRule(context){// A memoization for when two fragments are compared \"between\" each other for\n// conflicts. Two fragments may be compared many times, so memoizing this can\n// dramatically improve the performance of this validator.\nvar comparedFragmentPairs=new PairSet();// A cache for the \"field map\" and list of fragment names found in any given\n// selection set. Selection sets may be asked for this information multiple\n// times, so this improves the performance of this validator.\nvar cachedFieldsAndFragmentNames=new Map();return{SelectionSet:function SelectionSet(selectionSet){var conflicts=findConflictsWithinSelectionSet(context,cachedFieldsAndFragmentNames,comparedFragmentPairs,context.getParentType(),selectionSet);for(var _i2=0;_i2<conflicts.length;_i2++){var _ref3=conflicts[_i2];var _ref2$=_ref3[0];var responseName=_ref2$[0];var reason=_ref2$[1];var fields1=_ref3[1];var fields2=_ref3[2];var reasonMsg=reasonMessage(reason);context.reportError(new GraphQLError(\"Fields \\\"\".concat(responseName,\"\\\" conflict because \").concat(reasonMsg,\". Use different aliases on the fields to fetch both if this was intentional.\"),fields1.concat(fields2)));}}};}/**\n * Algorithm:\n *\n * Conflicts occur when two fields exist in a query which will produce the same\n * response name, but represent differing values, thus creating a conflict.\n * The algorithm below finds all conflicts via making a series of comparisons\n * between fields. In order to compare as few fields as possible, this makes\n * a series of comparisons \"within\" sets of fields and \"between\" sets of fields.\n *\n * Given any selection set, a collection produces both a set of fields by\n * also including all inline fragments, as well as a list of fragments\n * referenced by fragment spreads.\n *\n * A) Each selection set represented in the document first compares \"within\" its\n * collected set of fields, finding any conflicts between every pair of\n * overlapping fields.\n * Note: This is the *only time* that a the fields \"within\" a set are compared\n * to each other. After this only fields \"between\" sets are compared.\n *\n * B) Also, if any fragment is referenced in a selection set, then a\n * comparison is made \"between\" the original set of fields and the\n * referenced fragment.\n *\n * C) Also, if multiple fragments are referenced, then comparisons\n * are made \"between\" each referenced fragment.\n *\n * D) When comparing \"between\" a set of fields and a referenced fragment, first\n * a comparison is made between each field in the original set of fields and\n * each field in the the referenced set of fields.\n *\n * E) Also, if any fragment is referenced in the referenced selection set,\n * then a comparison is made \"between\" the original set of fields and the\n * referenced fragment (recursively referring to step D).\n *\n * F) When comparing \"between\" two fragments, first a comparison is made between\n * each field in the first referenced set of fields and each field in the the\n * second referenced set of fields.\n *\n * G) Also, any fragments referenced by the first must be compared to the\n * second, and any fragments referenced by the second must be compared to the\n * first (recursively referring to step F).\n *\n * H) When comparing two fields, if both have selection sets, then a comparison\n * is made \"between\" both selection sets, first comparing the set of fields in\n * the first selection set with the set of fields in the second.\n *\n * I) Also, if any fragment is referenced in either selection set, then a\n * comparison is made \"between\" the other set of fields and the\n * referenced fragment.\n *\n * J) Also, if two fragments are referenced in both selection sets, then a\n * comparison is made \"between\" the two fragments.\n *\n */ // Find all conflicts found \"within\" a selection set, including those found\n// via spreading in fragments. Called when visiting each SelectionSet in the\n// GraphQL Document.\nfunction findConflictsWithinSelectionSet(context,cachedFieldsAndFragmentNames,comparedFragmentPairs,parentType,selectionSet){var conflicts=[];var _getFieldsAndFragment=getFieldsAndFragmentNames(context,cachedFieldsAndFragmentNames,parentType,selectionSet),fieldMap=_getFieldsAndFragment[0],fragmentNames=_getFieldsAndFragment[1];// (A) Find find all conflicts \"within\" the fields of this selection set.\n// Note: this is the *only place* `collectConflictsWithin` is called.\ncollectConflictsWithin(context,conflicts,cachedFieldsAndFragmentNames,comparedFragmentPairs,fieldMap);if(fragmentNames.length!==0){// (B) Then collect conflicts between these fields and those represented by\n// each spread fragment name found.\nfor(var i=0;i<fragmentNames.length;i++){collectConflictsBetweenFieldsAndFragment(context,conflicts,cachedFieldsAndFragmentNames,comparedFragmentPairs,false,fieldMap,fragmentNames[i]);// (C) Then compare this fragment with all other fragments found in this\n// selection set to collect conflicts between fragments spread together.\n// This compares each item in the list of fragment names to every other\n// item in that same list (except for itself).\nfor(var j=i+1;j<fragmentNames.length;j++){collectConflictsBetweenFragments(context,conflicts,cachedFieldsAndFragmentNames,comparedFragmentPairs,false,fragmentNames[i],fragmentNames[j]);}}}return conflicts;}// Collect all conflicts found between a set of fields and a fragment reference\n// including via spreading in any nested fragments.\nfunction collectConflictsBetweenFieldsAndFragment(context,conflicts,cachedFieldsAndFragmentNames,comparedFragmentPairs,areMutuallyExclusive,fieldMap,fragmentName){var fragment=context.getFragment(fragmentName);if(!fragment){return;}var _getReferencedFieldsA=getReferencedFieldsAndFragmentNames(context,cachedFieldsAndFragmentNames,fragment),fieldMap2=_getReferencedFieldsA[0],fragmentNames2=_getReferencedFieldsA[1];// Do not compare a fragment's fieldMap to itself.\nif(fieldMap===fieldMap2){return;}// (D) First collect any conflicts between the provided collection of fields\n// and the collection of fields represented by the given fragment.\ncollectConflictsBetween(context,conflicts,cachedFieldsAndFragmentNames,comparedFragmentPairs,areMutuallyExclusive,fieldMap,fieldMap2);// (E) Then collect any conflicts between the provided collection of fields\n// and any fragment names found in the given fragment.\nfor(var i=0;i<fragmentNames2.length;i++){collectConflictsBetweenFieldsAndFragment(context,conflicts,cachedFieldsAndFragmentNames,comparedFragmentPairs,areMutuallyExclusive,fieldMap,fragmentNames2[i]);}}// Collect all conflicts found between two fragments, including via spreading in\n// any nested fragments.\nfunction collectConflictsBetweenFragments(context,conflicts,cachedFieldsAndFragmentNames,comparedFragmentPairs,areMutuallyExclusive,fragmentName1,fragmentName2){// No need to compare a fragment to itself.\nif(fragmentName1===fragmentName2){return;}// Memoize so two fragments are not compared for conflicts more than once.\nif(comparedFragmentPairs.has(fragmentName1,fragmentName2,areMutuallyExclusive)){return;}comparedFragmentPairs.add(fragmentName1,fragmentName2,areMutuallyExclusive);var fragment1=context.getFragment(fragmentName1);var fragment2=context.getFragment(fragmentName2);if(!fragment1||!fragment2){return;}var _getReferencedFieldsA2=getReferencedFieldsAndFragmentNames(context,cachedFieldsAndFragmentNames,fragment1),fieldMap1=_getReferencedFieldsA2[0],fragmentNames1=_getReferencedFieldsA2[1];var _getReferencedFieldsA3=getReferencedFieldsAndFragmentNames(context,cachedFieldsAndFragmentNames,fragment2),fieldMap2=_getReferencedFieldsA3[0],fragmentNames2=_getReferencedFieldsA3[1];// (F) First, collect all conflicts between these two collections of fields\n// (not including any nested fragments).\ncollectConflictsBetween(context,conflicts,cachedFieldsAndFragmentNames,comparedFragmentPairs,areMutuallyExclusive,fieldMap1,fieldMap2);// (G) Then collect conflicts between the first fragment and any nested\n// fragments spread in the second fragment.\nfor(var j=0;j<fragmentNames2.length;j++){collectConflictsBetweenFragments(context,conflicts,cachedFieldsAndFragmentNames,comparedFragmentPairs,areMutuallyExclusive,fragmentName1,fragmentNames2[j]);}// (G) Then collect conflicts between the second fragment and any nested\n// fragments spread in the first fragment.\nfor(var i=0;i<fragmentNames1.length;i++){collectConflictsBetweenFragments(context,conflicts,cachedFieldsAndFragmentNames,comparedFragmentPairs,areMutuallyExclusive,fragmentNames1[i],fragmentName2);}}// Find all conflicts found between two selection sets, including those found\n// via spreading in fragments. Called when determining if conflicts exist\n// between the sub-fields of two overlapping fields.\nfunction findConflictsBetweenSubSelectionSets(context,cachedFieldsAndFragmentNames,comparedFragmentPairs,areMutuallyExclusive,parentType1,selectionSet1,parentType2,selectionSet2){var conflicts=[];var _getFieldsAndFragment2=getFieldsAndFragmentNames(context,cachedFieldsAndFragmentNames,parentType1,selectionSet1),fieldMap1=_getFieldsAndFragment2[0],fragmentNames1=_getFieldsAndFragment2[1];var _getFieldsAndFragment3=getFieldsAndFragmentNames(context,cachedFieldsAndFragmentNames,parentType2,selectionSet2),fieldMap2=_getFieldsAndFragment3[0],fragmentNames2=_getFieldsAndFragment3[1];// (H) First, collect all conflicts between these two collections of field.\ncollectConflictsBetween(context,conflicts,cachedFieldsAndFragmentNames,comparedFragmentPairs,areMutuallyExclusive,fieldMap1,fieldMap2);// (I) Then collect conflicts between the first collection of fields and\n// those referenced by each fragment name associated with the second.\nif(fragmentNames2.length!==0){for(var j=0;j<fragmentNames2.length;j++){collectConflictsBetweenFieldsAndFragment(context,conflicts,cachedFieldsAndFragmentNames,comparedFragmentPairs,areMutuallyExclusive,fieldMap1,fragmentNames2[j]);}}// (I) Then collect conflicts between the second collection of fields and\n// those referenced by each fragment name associated with the first.\nif(fragmentNames1.length!==0){for(var i=0;i<fragmentNames1.length;i++){collectConflictsBetweenFieldsAndFragment(context,conflicts,cachedFieldsAndFragmentNames,comparedFragmentPairs,areMutuallyExclusive,fieldMap2,fragmentNames1[i]);}}// (J) Also collect conflicts between any fragment names by the first and\n// fragment names by the second. This compares each item in the first set of\n// names to each item in the second set of names.\nfor(var _i3=0;_i3<fragmentNames1.length;_i3++){for(var _j=0;_j<fragmentNames2.length;_j++){collectConflictsBetweenFragments(context,conflicts,cachedFieldsAndFragmentNames,comparedFragmentPairs,areMutuallyExclusive,fragmentNames1[_i3],fragmentNames2[_j]);}}return conflicts;}// Collect all Conflicts \"within\" one collection of fields.\nfunction collectConflictsWithin(context,conflicts,cachedFieldsAndFragmentNames,comparedFragmentPairs,fieldMap){// A field map is a keyed collection, where each key represents a response\n// name and the value at that key is a list of all fields which provide that\n// response name. For every response name, if there are multiple fields, they\n// must be compared to find a potential conflict.\nfor(var _i5=0,_objectEntries2=objectEntries(fieldMap);_i5<_objectEntries2.length;_i5++){var _ref5=_objectEntries2[_i5];var responseName=_ref5[0];var fields=_ref5[1];// This compares every field in the list to every other field in this list\n// (except to itself). If the list only has one item, nothing needs to\n// be compared.\nif(fields.length>1){for(var i=0;i<fields.length;i++){for(var j=i+1;j<fields.length;j++){var conflict=findConflict(context,cachedFieldsAndFragmentNames,comparedFragmentPairs,false,// within one collection is never mutually exclusive\nresponseName,fields[i],fields[j]);if(conflict){conflicts.push(conflict);}}}}}}// Collect all Conflicts between two collections of fields. This is similar to,\n// but different from the `collectConflictsWithin` function above. This check\n// assumes that `collectConflictsWithin` has already been called on each\n// provided collection of fields. This is true because this validator traverses\n// each individual selection set.\nfunction collectConflictsBetween(context,conflicts,cachedFieldsAndFragmentNames,comparedFragmentPairs,parentFieldsAreMutuallyExclusive,fieldMap1,fieldMap2){// A field map is a keyed collection, where each key represents a response\n// name and the value at that key is a list of all fields which provide that\n// response name. For any response name which appears in both provided field\n// maps, each field from the first field map must be compared to every field\n// in the second field map to find potential conflicts.\nfor(var _i7=0,_Object$keys2=Object.keys(fieldMap1);_i7<_Object$keys2.length;_i7++){var responseName=_Object$keys2[_i7];var fields2=fieldMap2[responseName];if(fields2){var fields1=fieldMap1[responseName];for(var i=0;i<fields1.length;i++){for(var j=0;j<fields2.length;j++){var conflict=findConflict(context,cachedFieldsAndFragmentNames,comparedFragmentPairs,parentFieldsAreMutuallyExclusive,responseName,fields1[i],fields2[j]);if(conflict){conflicts.push(conflict);}}}}}}// Determines if there is a conflict between two particular fields, including\n// comparing their sub-fields.\nfunction findConflict(context,cachedFieldsAndFragmentNames,comparedFragmentPairs,parentFieldsAreMutuallyExclusive,responseName,field1,field2){var parentType1=field1[0],node1=field1[1],def1=field1[2];var parentType2=field2[0],node2=field2[1],def2=field2[2];// If it is known that two fields could not possibly apply at the same\n// time, due to the parent types, then it is safe to permit them to diverge\n// in aliased field or arguments used as they will not present any ambiguity\n// by differing.\n// It is known that two parent types could never overlap if they are\n// different Object types. Interface or Union types might overlap - if not\n// in the current state of the schema, then perhaps in some future version,\n// thus may not safely diverge.\nvar areMutuallyExclusive=parentFieldsAreMutuallyExclusive||parentType1!==parentType2&&isObjectType(parentType1)&&isObjectType(parentType2);if(!areMutuallyExclusive){var _node1$arguments,_node2$arguments;// Two aliases must refer to the same field.\nvar name1=node1.name.value;var name2=node2.name.value;if(name1!==name2){return[[responseName,\"\\\"\".concat(name1,\"\\\" and \\\"\").concat(name2,\"\\\" are different fields\")],[node1],[node2]];}// istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\nvar args1=(_node1$arguments=node1.arguments)!==null&&_node1$arguments!==void 0?_node1$arguments:[];// istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\nvar args2=(_node2$arguments=node2.arguments)!==null&&_node2$arguments!==void 0?_node2$arguments:[];// Two field calls must have the same arguments.\nif(!sameArguments(args1,args2)){return[[responseName,'they have differing arguments'],[node1],[node2]];}}// The return type for each field.\nvar type1=def1===null||def1===void 0?void 0:def1.type;var type2=def2===null||def2===void 0?void 0:def2.type;if(type1&&type2&&doTypesConflict(type1,type2)){return[[responseName,\"they return conflicting types \\\"\".concat(inspect(type1),\"\\\" and \\\"\").concat(inspect(type2),\"\\\"\")],[node1],[node2]];}// Collect and compare sub-fields. Use the same \"visited fragment names\" list\n// for both collections so fields in a fragment reference are never\n// compared to themselves.\nvar selectionSet1=node1.selectionSet;var selectionSet2=node2.selectionSet;if(selectionSet1&&selectionSet2){var conflicts=findConflictsBetweenSubSelectionSets(context,cachedFieldsAndFragmentNames,comparedFragmentPairs,areMutuallyExclusive,getNamedType(type1),selectionSet1,getNamedType(type2),selectionSet2);return subfieldConflicts(conflicts,responseName,node1,node2);}}function sameArguments(arguments1,arguments2){if(arguments1.length!==arguments2.length){return false;}return arguments1.every(function(argument1){var argument2=find(arguments2,function(argument){return argument.name.value===argument1.name.value;});if(!argument2){return false;}return sameValue(argument1.value,argument2.value);});}function sameValue(value1,value2){return print(value1)===print(value2);}// Two types conflict if both types could not apply to a value simultaneously.\n// Composite types are ignored as their individual field types will be compared\n// later recursively. However List and Non-Null types must match.\nfunction doTypesConflict(type1,type2){if(isListType(type1)){return isListType(type2)?doTypesConflict(type1.ofType,type2.ofType):true;}if(isListType(type2)){return true;}if(isNonNullType(type1)){return isNonNullType(type2)?doTypesConflict(type1.ofType,type2.ofType):true;}if(isNonNullType(type2)){return true;}if(isLeafType(type1)||isLeafType(type2)){return type1!==type2;}return false;}// Given a selection set, return the collection of fields (a mapping of response\n// name to field nodes and definitions) as well as a list of fragment names\n// referenced via fragment spreads.\nfunction getFieldsAndFragmentNames(context,cachedFieldsAndFragmentNames,parentType,selectionSet){var cached=cachedFieldsAndFragmentNames.get(selectionSet);if(!cached){var nodeAndDefs=Object.create(null);var fragmentNames=Object.create(null);_collectFieldsAndFragmentNames(context,parentType,selectionSet,nodeAndDefs,fragmentNames);cached=[nodeAndDefs,Object.keys(fragmentNames)];cachedFieldsAndFragmentNames.set(selectionSet,cached);}return cached;}// Given a reference to a fragment, return the represented collection of fields\n// as well as a list of nested fragment names referenced via fragment spreads.\nfunction getReferencedFieldsAndFragmentNames(context,cachedFieldsAndFragmentNames,fragment){// Short-circuit building a type from the node if possible.\nvar cached=cachedFieldsAndFragmentNames.get(fragment.selectionSet);if(cached){return cached;}var fragmentType=typeFromAST(context.getSchema(),fragment.typeCondition);return getFieldsAndFragmentNames(context,cachedFieldsAndFragmentNames,fragmentType,fragment.selectionSet);}function _collectFieldsAndFragmentNames(context,parentType,selectionSet,nodeAndDefs,fragmentNames){for(var _i9=0,_selectionSet$selecti2=selectionSet.selections;_i9<_selectionSet$selecti2.length;_i9++){var selection=_selectionSet$selecti2[_i9];switch(selection.kind){case Kind.FIELD:{var fieldName=selection.name.value;var fieldDef=void 0;if(isObjectType(parentType)||isInterfaceType(parentType)){fieldDef=parentType.getFields()[fieldName];}var responseName=selection.alias?selection.alias.value:fieldName;if(!nodeAndDefs[responseName]){nodeAndDefs[responseName]=[];}nodeAndDefs[responseName].push([parentType,selection,fieldDef]);break;}case Kind.FRAGMENT_SPREAD:fragmentNames[selection.name.value]=true;break;case Kind.INLINE_FRAGMENT:{var typeCondition=selection.typeCondition;var inlineFragmentType=typeCondition?typeFromAST(context.getSchema(),typeCondition):parentType;_collectFieldsAndFragmentNames(context,inlineFragmentType,selection.selectionSet,nodeAndDefs,fragmentNames);break;}}}}// Given a series of Conflicts which occurred between two sub-fields, generate\n// a single Conflict.\nfunction subfieldConflicts(conflicts,responseName,node1,node2){if(conflicts.length>0){return[[responseName,conflicts.map(function(_ref6){var reason=_ref6[0];return reason;})],conflicts.reduce(function(allFields,_ref7){var fields1=_ref7[1];return allFields.concat(fields1);},[node1]),conflicts.reduce(function(allFields,_ref8){var fields2=_ref8[2];return allFields.concat(fields2);},[node2])];}}/**\n * A way to keep track of pairs of things when the ordering of the pair does\n * not matter. We do this by maintaining a sort of double adjacency sets.\n */var PairSet=/*#__PURE__*/function(){function PairSet(){this._data=Object.create(null);}var _proto=PairSet.prototype;_proto.has=function has(a,b,areMutuallyExclusive){var first=this._data[a];var result=first&&first[b];if(result===undefined){return false;}// areMutuallyExclusive being false is a superset of being true,\n// hence if we want to know if this PairSet \"has\" these two with no\n// exclusivity, we have to ensure it was added as such.\nif(areMutuallyExclusive===false){return result===false;}return true;};_proto.add=function add(a,b,areMutuallyExclusive){this._pairSetAdd(a,b,areMutuallyExclusive);this._pairSetAdd(b,a,areMutuallyExclusive);};_proto._pairSetAdd=function _pairSetAdd(a,b,areMutuallyExclusive){var map=this._data[a];if(!map){map=Object.create(null);this._data[a]=map;}map[b]=areMutuallyExclusive;};return PairSet;}();","map":{"version":3,"names":["find","objectEntries","inspect","GraphQLError","Kind","print","getNamedType","isNonNullType","isLeafType","isObjectType","isListType","isInterfaceType","typeFromAST","reasonMessage","reason","Array","isArray","map","_ref","responseName","subReason","concat","join","OverlappingFieldsCanBeMergedRule","context","comparedFragmentPairs","PairSet","cachedFieldsAndFragmentNames","Map","SelectionSet","selectionSet","conflicts","findConflictsWithinSelectionSet","getParentType","_i2","length","_ref3","_ref2$","fields1","fields2","reasonMsg","reportError","parentType","_getFieldsAndFragment","getFieldsAndFragmentNames","fieldMap","fragmentNames","collectConflictsWithin","i","collectConflictsBetweenFieldsAndFragment","j","collectConflictsBetweenFragments","areMutuallyExclusive","fragmentName","fragment","getFragment","_getReferencedFieldsA","getReferencedFieldsAndFragmentNames","fieldMap2","fragmentNames2","collectConflictsBetween","fragmentName1","fragmentName2","has","add","fragment1","fragment2","_getReferencedFieldsA2","fieldMap1","fragmentNames1","_getReferencedFieldsA3","findConflictsBetweenSubSelectionSets","parentType1","selectionSet1","parentType2","selectionSet2","_getFieldsAndFragment2","_getFieldsAndFragment3","_i3","_j","_i5","_objectEntries2","_ref5","fields","conflict","findConflict","push","parentFieldsAreMutuallyExclusive","_i7","_Object$keys2","Object","keys","field1","field2","node1","def1","node2","def2","_node1$arguments","_node2$arguments","name1","name","value","name2","args1","arguments","args2","sameArguments","type1","type","type2","doTypesConflict","subfieldConflicts","arguments1","arguments2","every","argument1","argument2","argument","sameValue","value1","value2","ofType","cached","get","nodeAndDefs","create","_collectFieldsAndFragmentNames","set","fragmentType","getSchema","typeCondition","_i9","_selectionSet$selecti2","selections","selection","kind","FIELD","fieldName","fieldDef","getFields","alias","FRAGMENT_SPREAD","INLINE_FRAGMENT","inlineFragmentType","_ref6","reduce","allFields","_ref7","_ref8","_data","_proto","prototype","a","b","first","result","undefined","_pairSetAdd"],"sources":["C:/Users/jarma/school/challenges/Project3_Final/client/src/node_modules/graphql/validation/rules/OverlappingFieldsCanBeMergedRule.mjs"],"sourcesContent":["import find from \"../../polyfills/find.mjs\";\nimport objectEntries from \"../../polyfills/objectEntries.mjs\";\nimport inspect from \"../../jsutils/inspect.mjs\";\nimport { GraphQLError } from \"../../error/GraphQLError.mjs\";\nimport { Kind } from \"../../language/kinds.mjs\";\nimport { print } from \"../../language/printer.mjs\";\nimport { getNamedType, isNonNullType, isLeafType, isObjectType, isListType, isInterfaceType } from \"../../type/definition.mjs\";\nimport { typeFromAST } from \"../../utilities/typeFromAST.mjs\";\n\nfunction reasonMessage(reason) {\n  if (Array.isArray(reason)) {\n    return reason.map(function (_ref) {\n      var responseName = _ref[0],\n          subReason = _ref[1];\n      return \"subfields \\\"\".concat(responseName, \"\\\" conflict because \") + reasonMessage(subReason);\n    }).join(' and ');\n  }\n\n  return reason;\n}\n/**\n * Overlapping fields can be merged\n *\n * A selection set is only valid if all fields (including spreading any\n * fragments) either correspond to distinct response names or can be merged\n * without ambiguity.\n */\n\n\nexport function OverlappingFieldsCanBeMergedRule(context) {\n  // A memoization for when two fragments are compared \"between\" each other for\n  // conflicts. Two fragments may be compared many times, so memoizing this can\n  // dramatically improve the performance of this validator.\n  var comparedFragmentPairs = new PairSet(); // A cache for the \"field map\" and list of fragment names found in any given\n  // selection set. Selection sets may be asked for this information multiple\n  // times, so this improves the performance of this validator.\n\n  var cachedFieldsAndFragmentNames = new Map();\n  return {\n    SelectionSet: function SelectionSet(selectionSet) {\n      var conflicts = findConflictsWithinSelectionSet(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, context.getParentType(), selectionSet);\n\n      for (var _i2 = 0; _i2 < conflicts.length; _i2++) {\n        var _ref3 = conflicts[_i2];\n        var _ref2$ = _ref3[0];\n        var responseName = _ref2$[0];\n        var reason = _ref2$[1];\n        var fields1 = _ref3[1];\n        var fields2 = _ref3[2];\n        var reasonMsg = reasonMessage(reason);\n        context.reportError(new GraphQLError(\"Fields \\\"\".concat(responseName, \"\\\" conflict because \").concat(reasonMsg, \". Use different aliases on the fields to fetch both if this was intentional.\"), fields1.concat(fields2)));\n      }\n    }\n  };\n}\n\n/**\n * Algorithm:\n *\n * Conflicts occur when two fields exist in a query which will produce the same\n * response name, but represent differing values, thus creating a conflict.\n * The algorithm below finds all conflicts via making a series of comparisons\n * between fields. In order to compare as few fields as possible, this makes\n * a series of comparisons \"within\" sets of fields and \"between\" sets of fields.\n *\n * Given any selection set, a collection produces both a set of fields by\n * also including all inline fragments, as well as a list of fragments\n * referenced by fragment spreads.\n *\n * A) Each selection set represented in the document first compares \"within\" its\n * collected set of fields, finding any conflicts between every pair of\n * overlapping fields.\n * Note: This is the *only time* that a the fields \"within\" a set are compared\n * to each other. After this only fields \"between\" sets are compared.\n *\n * B) Also, if any fragment is referenced in a selection set, then a\n * comparison is made \"between\" the original set of fields and the\n * referenced fragment.\n *\n * C) Also, if multiple fragments are referenced, then comparisons\n * are made \"between\" each referenced fragment.\n *\n * D) When comparing \"between\" a set of fields and a referenced fragment, first\n * a comparison is made between each field in the original set of fields and\n * each field in the the referenced set of fields.\n *\n * E) Also, if any fragment is referenced in the referenced selection set,\n * then a comparison is made \"between\" the original set of fields and the\n * referenced fragment (recursively referring to step D).\n *\n * F) When comparing \"between\" two fragments, first a comparison is made between\n * each field in the first referenced set of fields and each field in the the\n * second referenced set of fields.\n *\n * G) Also, any fragments referenced by the first must be compared to the\n * second, and any fragments referenced by the second must be compared to the\n * first (recursively referring to step F).\n *\n * H) When comparing two fields, if both have selection sets, then a comparison\n * is made \"between\" both selection sets, first comparing the set of fields in\n * the first selection set with the set of fields in the second.\n *\n * I) Also, if any fragment is referenced in either selection set, then a\n * comparison is made \"between\" the other set of fields and the\n * referenced fragment.\n *\n * J) Also, if two fragments are referenced in both selection sets, then a\n * comparison is made \"between\" the two fragments.\n *\n */\n// Find all conflicts found \"within\" a selection set, including those found\n// via spreading in fragments. Called when visiting each SelectionSet in the\n// GraphQL Document.\nfunction findConflictsWithinSelectionSet(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentType, selectionSet) {\n  var conflicts = [];\n\n  var _getFieldsAndFragment = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType, selectionSet),\n      fieldMap = _getFieldsAndFragment[0],\n      fragmentNames = _getFieldsAndFragment[1]; // (A) Find find all conflicts \"within\" the fields of this selection set.\n  // Note: this is the *only place* `collectConflictsWithin` is called.\n\n\n  collectConflictsWithin(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, fieldMap);\n\n  if (fragmentNames.length !== 0) {\n    // (B) Then collect conflicts between these fields and those represented by\n    // each spread fragment name found.\n    for (var i = 0; i < fragmentNames.length; i++) {\n      collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, false, fieldMap, fragmentNames[i]); // (C) Then compare this fragment with all other fragments found in this\n      // selection set to collect conflicts between fragments spread together.\n      // This compares each item in the list of fragment names to every other\n      // item in that same list (except for itself).\n\n      for (var j = i + 1; j < fragmentNames.length; j++) {\n        collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, false, fragmentNames[i], fragmentNames[j]);\n      }\n    }\n  }\n\n  return conflicts;\n} // Collect all conflicts found between a set of fields and a fragment reference\n// including via spreading in any nested fragments.\n\n\nfunction collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fragmentName) {\n  var fragment = context.getFragment(fragmentName);\n\n  if (!fragment) {\n    return;\n  }\n\n  var _getReferencedFieldsA = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment),\n      fieldMap2 = _getReferencedFieldsA[0],\n      fragmentNames2 = _getReferencedFieldsA[1]; // Do not compare a fragment's fieldMap to itself.\n\n\n  if (fieldMap === fieldMap2) {\n    return;\n  } // (D) First collect any conflicts between the provided collection of fields\n  // and the collection of fields represented by the given fragment.\n\n\n  collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fieldMap2); // (E) Then collect any conflicts between the provided collection of fields\n  // and any fragment names found in the given fragment.\n\n  for (var i = 0; i < fragmentNames2.length; i++) {\n    collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fragmentNames2[i]);\n  }\n} // Collect all conflicts found between two fragments, including via spreading in\n// any nested fragments.\n\n\nfunction collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, fragmentName2) {\n  // No need to compare a fragment to itself.\n  if (fragmentName1 === fragmentName2) {\n    return;\n  } // Memoize so two fragments are not compared for conflicts more than once.\n\n\n  if (comparedFragmentPairs.has(fragmentName1, fragmentName2, areMutuallyExclusive)) {\n    return;\n  }\n\n  comparedFragmentPairs.add(fragmentName1, fragmentName2, areMutuallyExclusive);\n  var fragment1 = context.getFragment(fragmentName1);\n  var fragment2 = context.getFragment(fragmentName2);\n\n  if (!fragment1 || !fragment2) {\n    return;\n  }\n\n  var _getReferencedFieldsA2 = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment1),\n      fieldMap1 = _getReferencedFieldsA2[0],\n      fragmentNames1 = _getReferencedFieldsA2[1];\n\n  var _getReferencedFieldsA3 = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment2),\n      fieldMap2 = _getReferencedFieldsA3[0],\n      fragmentNames2 = _getReferencedFieldsA3[1]; // (F) First, collect all conflicts between these two collections of fields\n  // (not including any nested fragments).\n\n\n  collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fieldMap2); // (G) Then collect conflicts between the first fragment and any nested\n  // fragments spread in the second fragment.\n\n  for (var j = 0; j < fragmentNames2.length; j++) {\n    collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, fragmentNames2[j]);\n  } // (G) Then collect conflicts between the second fragment and any nested\n  // fragments spread in the first fragment.\n\n\n  for (var i = 0; i < fragmentNames1.length; i++) {\n    collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentNames1[i], fragmentName2);\n  }\n} // Find all conflicts found between two selection sets, including those found\n// via spreading in fragments. Called when determining if conflicts exist\n// between the sub-fields of two overlapping fields.\n\n\nfunction findConflictsBetweenSubSelectionSets(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, parentType1, selectionSet1, parentType2, selectionSet2) {\n  var conflicts = [];\n\n  var _getFieldsAndFragment2 = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType1, selectionSet1),\n      fieldMap1 = _getFieldsAndFragment2[0],\n      fragmentNames1 = _getFieldsAndFragment2[1];\n\n  var _getFieldsAndFragment3 = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType2, selectionSet2),\n      fieldMap2 = _getFieldsAndFragment3[0],\n      fragmentNames2 = _getFieldsAndFragment3[1]; // (H) First, collect all conflicts between these two collections of field.\n\n\n  collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fieldMap2); // (I) Then collect conflicts between the first collection of fields and\n  // those referenced by each fragment name associated with the second.\n\n  if (fragmentNames2.length !== 0) {\n    for (var j = 0; j < fragmentNames2.length; j++) {\n      collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fragmentNames2[j]);\n    }\n  } // (I) Then collect conflicts between the second collection of fields and\n  // those referenced by each fragment name associated with the first.\n\n\n  if (fragmentNames1.length !== 0) {\n    for (var i = 0; i < fragmentNames1.length; i++) {\n      collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap2, fragmentNames1[i]);\n    }\n  } // (J) Also collect conflicts between any fragment names by the first and\n  // fragment names by the second. This compares each item in the first set of\n  // names to each item in the second set of names.\n\n\n  for (var _i3 = 0; _i3 < fragmentNames1.length; _i3++) {\n    for (var _j = 0; _j < fragmentNames2.length; _j++) {\n      collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentNames1[_i3], fragmentNames2[_j]);\n    }\n  }\n\n  return conflicts;\n} // Collect all Conflicts \"within\" one collection of fields.\n\n\nfunction collectConflictsWithin(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, fieldMap) {\n  // A field map is a keyed collection, where each key represents a response\n  // name and the value at that key is a list of all fields which provide that\n  // response name. For every response name, if there are multiple fields, they\n  // must be compared to find a potential conflict.\n  for (var _i5 = 0, _objectEntries2 = objectEntries(fieldMap); _i5 < _objectEntries2.length; _i5++) {\n    var _ref5 = _objectEntries2[_i5];\n    var responseName = _ref5[0];\n    var fields = _ref5[1];\n\n    // This compares every field in the list to every other field in this list\n    // (except to itself). If the list only has one item, nothing needs to\n    // be compared.\n    if (fields.length > 1) {\n      for (var i = 0; i < fields.length; i++) {\n        for (var j = i + 1; j < fields.length; j++) {\n          var conflict = findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, false, // within one collection is never mutually exclusive\n          responseName, fields[i], fields[j]);\n\n          if (conflict) {\n            conflicts.push(conflict);\n          }\n        }\n      }\n    }\n  }\n} // Collect all Conflicts between two collections of fields. This is similar to,\n// but different from the `collectConflictsWithin` function above. This check\n// assumes that `collectConflictsWithin` has already been called on each\n// provided collection of fields. This is true because this validator traverses\n// each individual selection set.\n\n\nfunction collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, fieldMap1, fieldMap2) {\n  // A field map is a keyed collection, where each key represents a response\n  // name and the value at that key is a list of all fields which provide that\n  // response name. For any response name which appears in both provided field\n  // maps, each field from the first field map must be compared to every field\n  // in the second field map to find potential conflicts.\n  for (var _i7 = 0, _Object$keys2 = Object.keys(fieldMap1); _i7 < _Object$keys2.length; _i7++) {\n    var responseName = _Object$keys2[_i7];\n    var fields2 = fieldMap2[responseName];\n\n    if (fields2) {\n      var fields1 = fieldMap1[responseName];\n\n      for (var i = 0; i < fields1.length; i++) {\n        for (var j = 0; j < fields2.length; j++) {\n          var conflict = findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, responseName, fields1[i], fields2[j]);\n\n          if (conflict) {\n            conflicts.push(conflict);\n          }\n        }\n      }\n    }\n  }\n} // Determines if there is a conflict between two particular fields, including\n// comparing their sub-fields.\n\n\nfunction findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, responseName, field1, field2) {\n  var parentType1 = field1[0],\n      node1 = field1[1],\n      def1 = field1[2];\n  var parentType2 = field2[0],\n      node2 = field2[1],\n      def2 = field2[2]; // If it is known that two fields could not possibly apply at the same\n  // time, due to the parent types, then it is safe to permit them to diverge\n  // in aliased field or arguments used as they will not present any ambiguity\n  // by differing.\n  // It is known that two parent types could never overlap if they are\n  // different Object types. Interface or Union types might overlap - if not\n  // in the current state of the schema, then perhaps in some future version,\n  // thus may not safely diverge.\n\n  var areMutuallyExclusive = parentFieldsAreMutuallyExclusive || parentType1 !== parentType2 && isObjectType(parentType1) && isObjectType(parentType2);\n\n  if (!areMutuallyExclusive) {\n    var _node1$arguments, _node2$arguments;\n\n    // Two aliases must refer to the same field.\n    var name1 = node1.name.value;\n    var name2 = node2.name.value;\n\n    if (name1 !== name2) {\n      return [[responseName, \"\\\"\".concat(name1, \"\\\" and \\\"\").concat(name2, \"\\\" are different fields\")], [node1], [node2]];\n    } // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n\n\n    var args1 = (_node1$arguments = node1.arguments) !== null && _node1$arguments !== void 0 ? _node1$arguments : []; // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n\n    var args2 = (_node2$arguments = node2.arguments) !== null && _node2$arguments !== void 0 ? _node2$arguments : []; // Two field calls must have the same arguments.\n\n    if (!sameArguments(args1, args2)) {\n      return [[responseName, 'they have differing arguments'], [node1], [node2]];\n    }\n  } // The return type for each field.\n\n\n  var type1 = def1 === null || def1 === void 0 ? void 0 : def1.type;\n  var type2 = def2 === null || def2 === void 0 ? void 0 : def2.type;\n\n  if (type1 && type2 && doTypesConflict(type1, type2)) {\n    return [[responseName, \"they return conflicting types \\\"\".concat(inspect(type1), \"\\\" and \\\"\").concat(inspect(type2), \"\\\"\")], [node1], [node2]];\n  } // Collect and compare sub-fields. Use the same \"visited fragment names\" list\n  // for both collections so fields in a fragment reference are never\n  // compared to themselves.\n\n\n  var selectionSet1 = node1.selectionSet;\n  var selectionSet2 = node2.selectionSet;\n\n  if (selectionSet1 && selectionSet2) {\n    var conflicts = findConflictsBetweenSubSelectionSets(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, getNamedType(type1), selectionSet1, getNamedType(type2), selectionSet2);\n    return subfieldConflicts(conflicts, responseName, node1, node2);\n  }\n}\n\nfunction sameArguments(arguments1, arguments2) {\n  if (arguments1.length !== arguments2.length) {\n    return false;\n  }\n\n  return arguments1.every(function (argument1) {\n    var argument2 = find(arguments2, function (argument) {\n      return argument.name.value === argument1.name.value;\n    });\n\n    if (!argument2) {\n      return false;\n    }\n\n    return sameValue(argument1.value, argument2.value);\n  });\n}\n\nfunction sameValue(value1, value2) {\n  return print(value1) === print(value2);\n} // Two types conflict if both types could not apply to a value simultaneously.\n// Composite types are ignored as their individual field types will be compared\n// later recursively. However List and Non-Null types must match.\n\n\nfunction doTypesConflict(type1, type2) {\n  if (isListType(type1)) {\n    return isListType(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;\n  }\n\n  if (isListType(type2)) {\n    return true;\n  }\n\n  if (isNonNullType(type1)) {\n    return isNonNullType(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;\n  }\n\n  if (isNonNullType(type2)) {\n    return true;\n  }\n\n  if (isLeafType(type1) || isLeafType(type2)) {\n    return type1 !== type2;\n  }\n\n  return false;\n} // Given a selection set, return the collection of fields (a mapping of response\n// name to field nodes and definitions) as well as a list of fragment names\n// referenced via fragment spreads.\n\n\nfunction getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType, selectionSet) {\n  var cached = cachedFieldsAndFragmentNames.get(selectionSet);\n\n  if (!cached) {\n    var nodeAndDefs = Object.create(null);\n    var fragmentNames = Object.create(null);\n\n    _collectFieldsAndFragmentNames(context, parentType, selectionSet, nodeAndDefs, fragmentNames);\n\n    cached = [nodeAndDefs, Object.keys(fragmentNames)];\n    cachedFieldsAndFragmentNames.set(selectionSet, cached);\n  }\n\n  return cached;\n} // Given a reference to a fragment, return the represented collection of fields\n// as well as a list of nested fragment names referenced via fragment spreads.\n\n\nfunction getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment) {\n  // Short-circuit building a type from the node if possible.\n  var cached = cachedFieldsAndFragmentNames.get(fragment.selectionSet);\n\n  if (cached) {\n    return cached;\n  }\n\n  var fragmentType = typeFromAST(context.getSchema(), fragment.typeCondition);\n  return getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragmentType, fragment.selectionSet);\n}\n\nfunction _collectFieldsAndFragmentNames(context, parentType, selectionSet, nodeAndDefs, fragmentNames) {\n  for (var _i9 = 0, _selectionSet$selecti2 = selectionSet.selections; _i9 < _selectionSet$selecti2.length; _i9++) {\n    var selection = _selectionSet$selecti2[_i9];\n\n    switch (selection.kind) {\n      case Kind.FIELD:\n        {\n          var fieldName = selection.name.value;\n          var fieldDef = void 0;\n\n          if (isObjectType(parentType) || isInterfaceType(parentType)) {\n            fieldDef = parentType.getFields()[fieldName];\n          }\n\n          var responseName = selection.alias ? selection.alias.value : fieldName;\n\n          if (!nodeAndDefs[responseName]) {\n            nodeAndDefs[responseName] = [];\n          }\n\n          nodeAndDefs[responseName].push([parentType, selection, fieldDef]);\n          break;\n        }\n\n      case Kind.FRAGMENT_SPREAD:\n        fragmentNames[selection.name.value] = true;\n        break;\n\n      case Kind.INLINE_FRAGMENT:\n        {\n          var typeCondition = selection.typeCondition;\n          var inlineFragmentType = typeCondition ? typeFromAST(context.getSchema(), typeCondition) : parentType;\n\n          _collectFieldsAndFragmentNames(context, inlineFragmentType, selection.selectionSet, nodeAndDefs, fragmentNames);\n\n          break;\n        }\n    }\n  }\n} // Given a series of Conflicts which occurred between two sub-fields, generate\n// a single Conflict.\n\n\nfunction subfieldConflicts(conflicts, responseName, node1, node2) {\n  if (conflicts.length > 0) {\n    return [[responseName, conflicts.map(function (_ref6) {\n      var reason = _ref6[0];\n      return reason;\n    })], conflicts.reduce(function (allFields, _ref7) {\n      var fields1 = _ref7[1];\n      return allFields.concat(fields1);\n    }, [node1]), conflicts.reduce(function (allFields, _ref8) {\n      var fields2 = _ref8[2];\n      return allFields.concat(fields2);\n    }, [node2])];\n  }\n}\n/**\n * A way to keep track of pairs of things when the ordering of the pair does\n * not matter. We do this by maintaining a sort of double adjacency sets.\n */\n\n\nvar PairSet = /*#__PURE__*/function () {\n  function PairSet() {\n    this._data = Object.create(null);\n  }\n\n  var _proto = PairSet.prototype;\n\n  _proto.has = function has(a, b, areMutuallyExclusive) {\n    var first = this._data[a];\n    var result = first && first[b];\n\n    if (result === undefined) {\n      return false;\n    } // areMutuallyExclusive being false is a superset of being true,\n    // hence if we want to know if this PairSet \"has\" these two with no\n    // exclusivity, we have to ensure it was added as such.\n\n\n    if (areMutuallyExclusive === false) {\n      return result === false;\n    }\n\n    return true;\n  };\n\n  _proto.add = function add(a, b, areMutuallyExclusive) {\n    this._pairSetAdd(a, b, areMutuallyExclusive);\n\n    this._pairSetAdd(b, a, areMutuallyExclusive);\n  };\n\n  _proto._pairSetAdd = function _pairSetAdd(a, b, areMutuallyExclusive) {\n    var map = this._data[a];\n\n    if (!map) {\n      map = Object.create(null);\n      this._data[a] = map;\n    }\n\n    map[b] = areMutuallyExclusive;\n  };\n\n  return PairSet;\n}();\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}