{"ast":null,"code":"import{__awaiter,__generator}from\"tslib\";import{responseIterator}from\"./responseIterator.js\";import{throwServerError}from\"../utils/index.js\";var hasOwnProperty=Object.prototype.hasOwnProperty;export function readMultipartBody(response,observer){var _a,_b,_c;return __awaiter(this,void 0,void 0,function(){var decoder,contentType,delimiter,boundaryVal,boundary,buffer,iterator,running,_d,value,done,chunk,bi,message,i,headers,contentType_1,body,result;var _e;return __generator(this,function(_f){switch(_f.label){case 0:if(TextDecoder===undefined){throw new Error(\"TextDecoder must be defined in the environment: please import a polyfill.\");}decoder=new TextDecoder(\"utf-8\");contentType=(_a=response.headers)===null||_a===void 0?void 0:_a.get('content-type');delimiter=\"boundary=\";boundaryVal=(contentType===null||contentType===void 0?void 0:contentType.includes(delimiter))?contentType===null||contentType===void 0?void 0:contentType.substring((contentType===null||contentType===void 0?void 0:contentType.indexOf(delimiter))+delimiter.length).replace(/['\"]/g,\"\").replace(/\\;(.*)/gm,\"\").trim():\"-\";boundary=\"--\".concat(boundaryVal);buffer=\"\";iterator=responseIterator(response);running=true;_f.label=1;case 1:if(!running)return[3,3];return[4,iterator.next()];case 2:_d=_f.sent(),value=_d.value,done=_d.done;chunk=typeof value===\"string\"?value:decoder.decode(value);running=!done;buffer+=chunk;bi=buffer.indexOf(boundary);while(bi>-1){message=void 0;_e=[buffer.slice(0,bi),buffer.slice(bi+boundary.length)],message=_e[0],buffer=_e[1];if(message.trim()){i=message.indexOf(\"\\r\\n\\r\\n\");headers=parseHeaders(message.slice(0,i));contentType_1=headers[\"content-type\"];if(contentType_1&&contentType_1.toLowerCase().indexOf(\"application/json\")===-1){throw new Error(\"Unsupported patch content type: application/json is required.\");}body=message.slice(i);try{result=parseJsonBody(response,body.replace(\"\\r\\n\",\"\"));if(Object.keys(result).length>1||\"data\"in result||\"incremental\"in result||\"errors\"in result){(_b=observer.next)===null||_b===void 0?void 0:_b.call(observer,result);}}catch(err){handleError(err,observer);}}bi=buffer.indexOf(boundary);}return[3,1];case 3:(_c=observer.complete)===null||_c===void 0?void 0:_c.call(observer);return[2];}});});}export function parseHeaders(headerText){var headersInit={};headerText.split(\"\\n\").forEach(function(line){var i=line.indexOf(\":\");if(i>-1){var name_1=line.slice(0,i).trim().toLowerCase();var value=line.slice(i+1).trim();headersInit[name_1]=value;}});return headersInit;}export function parseJsonBody(response,bodyText){if(response.status>=300){var getResult=function getResult(){try{return JSON.parse(bodyText);}catch(err){return bodyText;}};throwServerError(response,getResult(),\"Response not successful: Received status code \".concat(response.status));}try{return JSON.parse(bodyText);}catch(err){var parseError=err;parseError.name=\"ServerParseError\";parseError.response=response;parseError.statusCode=response.status;parseError.bodyText=bodyText;throw parseError;}}export function handleError(err,observer){var _a,_b;if(err.name===\"AbortError\")return;if(err.result&&err.result.errors&&err.result.data){(_a=observer.next)===null||_a===void 0?void 0:_a.call(observer,err.result);}(_b=observer.error)===null||_b===void 0?void 0:_b.call(observer,err);}export function readJsonBody(response,operation,observer){parseAndCheckHttpResponse(operation)(response).then(function(result){var _a,_b;(_a=observer.next)===null||_a===void 0?void 0:_a.call(observer,result);(_b=observer.complete)===null||_b===void 0?void 0:_b.call(observer);}).catch(function(err){return handleError(err,observer);});}export function parseAndCheckHttpResponse(operations){return function(response){return response.text().then(function(bodyText){return parseJsonBody(response,bodyText);}).then(function(result){if(response.status>=300){throwServerError(response,result,\"Response not successful: Received status code \".concat(response.status));}if(!Array.isArray(result)&&!hasOwnProperty.call(result,\"data\")&&!hasOwnProperty.call(result,\"errors\")){throwServerError(response,result,\"Server response was missing for query '\".concat(Array.isArray(operations)?operations.map(function(op){return op.operationName;}):operations.operationName,\"'.\"));}return result;});};}","map":{"version":3,"mappings":"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","names":["responseIterator","throwServerError","Object","prototype","hasOwnProperty","readMultipartBody","response","observer","TextDecoder","undefined","Error","decoder","contentType","headers","_a","get","delimiter","boundaryVal","includes","substring","indexOf","length","replace","trim","boundary","buffer","iterator","running","next","_d","_f","value","done","chunk","decode","bi","message","_e","slice","i","parseHeaders","contentType_1","toLowerCase","body","result","parseJsonBody","keys","_b","err","handleError","complete","_c","headerText","headersInit","split","forEach","line","name_1","bodyText","status","getResult","JSON","parse","parseError","name","statusCode","errors","data","error","readJsonBody","operation","parseAndCheckHttpResponse","then","catch","operations","text","Array","isArray","call","map","op","operationName"],"sourceRoot":"","sources":["../../../src/link/http/parseAndCheckHttpResponse.ts"],"sourcesContent":["import { responseIterator } from \"./responseIterator\";\nimport { Operation } from \"../core\";\nimport { throwServerError } from \"../utils\";\nimport { Observer } from \"../../utilities\";\n\nconst { hasOwnProperty } = Object.prototype;\n\nexport type ServerParseError = Error & {\n  response: Response;\n  statusCode: number;\n  bodyText: string;\n};\n\nexport async function readMultipartBody<T = Record<string, unknown>>(\n  response: Response,\n  observer: Observer<T>\n) {\n  if (TextDecoder === undefined) {\n    throw new Error(\n      \"TextDecoder must be defined in the environment: please import a polyfill.\"\n    );\n  }\n  const decoder = new TextDecoder(\"utf-8\");\n  const contentType = response.headers?.get('content-type');\n  const delimiter = \"boundary=\";\n\n  // parse boundary value and ignore any subsequent name/value pairs after ;\n  // https://www.rfc-editor.org/rfc/rfc9110.html#name-parameters\n  // e.g. multipart/mixed;boundary=\"graphql\";deferSpec=20220824\n  // if no boundary is specified, default to -\n  const boundaryVal = contentType?.includes(delimiter)\n    ? contentType\n        ?.substring(contentType?.indexOf(delimiter) + delimiter.length)\n        .replace(/['\"]/g, \"\")\n        .replace(/\\;(.*)/gm, \"\")\n        .trim()\n    : \"-\";\n\n  let boundary = `--${boundaryVal}`;\n  let buffer = \"\";\n  const iterator = responseIterator(response);\n  let running = true;\n\n  while (running) {\n    const { value, done } = await iterator.next();\n    const chunk = typeof value === \"string\" ? value : decoder.decode(value);\n    running = !done;\n    buffer += chunk;\n    let bi = buffer.indexOf(boundary);\n\n    while (bi > -1) {\n      let message: string;\n      [message, buffer] = [\n        buffer.slice(0, bi),\n        buffer.slice(bi + boundary.length),\n      ];\n      if (message.trim()) {\n        const i = message.indexOf(\"\\r\\n\\r\\n\");\n        const headers = parseHeaders(message.slice(0, i));\n        const contentType = headers[\"content-type\"];\n        if (\n          contentType &&\n          contentType.toLowerCase().indexOf(\"application/json\") === -1\n        ) {\n          throw new Error(\"Unsupported patch content type: application/json is required.\");\n        }\n        const body = message.slice(i);\n\n        try {\n          const result = parseJsonBody<T>(response, body.replace(\"\\r\\n\", \"\"));\n          if (\n            Object.keys(result).length > 1 ||\n            \"data\" in result ||\n            \"incremental\" in result ||\n            \"errors\" in result\n          ) {\n            // for the last chunk with only `hasNext: false`,\n            // we don't need to call observer.next as there is no data/errors\n            observer.next?.(result);\n          }\n        } catch (err) {\n          handleError(err, observer);\n        }\n      }\n      bi = buffer.indexOf(boundary);\n    }\n  }\n  observer.complete?.();\n}\n\nexport function parseHeaders(headerText: string): Record<string, string> {\n  const headersInit: Record<string, string> = {};\n  headerText.split(\"\\n\").forEach((line) => {\n    const i = line.indexOf(\":\");\n    if (i > -1) {\n      // normalize headers to lowercase\n      const name = line.slice(0, i).trim().toLowerCase();\n      const value = line.slice(i + 1).trim();\n      headersInit[name] = value;\n    }\n  });\n  return headersInit;\n}\n\nexport function parseJsonBody<T>(response: Response, bodyText: string): T {\n  if (response.status >= 300) {\n    // Network error\n    const getResult = () => {\n      try {\n        return JSON.parse(bodyText);\n      } catch (err) {\n        return bodyText\n      }\n    }\n    throwServerError(\n      response,\n      getResult(),\n      `Response not successful: Received status code ${response.status}`,\n    );\n  }\n\n  try {\n    return JSON.parse(bodyText) as T;\n  } catch (err) {\n    const parseError = err as ServerParseError;\n    parseError.name = \"ServerParseError\";\n    parseError.response = response;\n    parseError.statusCode = response.status;\n    parseError.bodyText = bodyText;\n    throw parseError;\n  }\n}\n\nexport function handleError(err: any, observer: Observer<any>) {\n  if (err.name === \"AbortError\") return;\n  // if it is a network error, BUT there is graphql result info fire\n  // the next observer before calling error this gives apollo-client\n  // (and react-apollo) the `graphqlErrors` and `networErrors` to\n  // pass to UI this should only happen if we *also* have data as\n  // part of the response key per the spec\n  if (err.result && err.result.errors && err.result.data) {\n    // if we don't call next, the UI can only show networkError\n    // because AC didn't get any graphqlErrors this is graphql\n    // execution result info (i.e errors and possibly data) this is\n    // because there is no formal spec how errors should translate to\n    // http status codes. So an auth error (401) could have both data\n    // from a public field, errors from a private field, and a status\n    // of 401\n    // {\n    //  user { // this will have errors\n    //    firstName\n    //  }\n    //  products { // this is public so will have data\n    //    cost\n    //  }\n    // }\n    //\n    // the result of above *could* look like this:\n    // {\n    //   data: { products: [{ cost: \"$10\" }] },\n    //   errors: [{\n    //      message: 'your session has timed out',\n    //      path: []\n    //   }]\n    // }\n    // status code of above would be a 401\n    // in the UI you want to show data where you can, errors as data where you can\n    // and use correct http status codes\n    observer.next?.(err.result);\n  }\n\n  observer.error?.(err);\n}\n\nexport function readJsonBody<T = Record<string, unknown>>(\n  response: Response,\n  operation: Operation,\n  observer: Observer<T>\n) {\n  parseAndCheckHttpResponse(operation)(response)\n    .then((result) => {\n      observer.next?.(result);\n      observer.complete?.();\n    })\n    .catch((err) => handleError(err, observer));\n}\n\nexport function parseAndCheckHttpResponse(operations: Operation | Operation[]) {\n  return (response: Response) =>\n    response\n      .text()\n      .then((bodyText) => parseJsonBody(response, bodyText))\n      .then((result: any) => {\n        if (response.status >= 300) {\n          // Network error\n          throwServerError(\n            response,\n            result,\n            `Response not successful: Received status code ${response.status}`\n          );\n        }\n        if (\n          !Array.isArray(result) &&\n          !hasOwnProperty.call(result, \"data\") &&\n          !hasOwnProperty.call(result, \"errors\")\n        ) {\n          // Data error\n          throwServerError(\n            response,\n            result,\n            `Server response was missing for query '${\n              Array.isArray(operations)\n                ? operations.map((op) => op.operationName)\n                : operations.operationName\n            }'.`\n          );\n        }\n        return result;\n      });\n}\n"]},"metadata":{},"sourceType":"module"}