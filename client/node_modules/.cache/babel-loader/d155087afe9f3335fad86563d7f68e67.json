{"ast":null,"code":"import{isReference,isField,DeepMerger,resultKeyNameFromField,shouldInclude,isNonNullObject,compact,createFragmentMap,getFragmentDefinitions}from\"../../utilities/index.js\";export var hasOwn=Object.prototype.hasOwnProperty;export function isNullish(value){return value===null||value===void 0;}export var isArray=Array.isArray;export function defaultDataIdFromObject(_a,context){var __typename=_a.__typename,id=_a.id,_id=_a._id;if(typeof __typename===\"string\"){if(context){context.keyObject=!isNullish(id)?{id:id}:!isNullish(_id)?{_id:_id}:void 0;}if(isNullish(id)&&!isNullish(_id)){id=_id;}if(!isNullish(id)){return\"\".concat(__typename,\":\").concat(typeof id===\"number\"||typeof id===\"string\"?id:JSON.stringify(id));}}}var defaultConfig={dataIdFromObject:defaultDataIdFromObject,addTypename:true,resultCaching:true,canonizeResults:false};export function normalizeConfig(config){return compact(defaultConfig,config);}export function shouldCanonizeResults(config){var value=config.canonizeResults;return value===void 0?defaultConfig.canonizeResults:value;}export function getTypenameFromStoreObject(store,objectOrReference){return isReference(objectOrReference)?store.get(objectOrReference.__ref,\"__typename\"):objectOrReference&&objectOrReference.__typename;}export var TypeOrFieldNameRegExp=/^[_a-z][_0-9a-z]*/i;export function fieldNameFromStoreName(storeFieldName){var match=storeFieldName.match(TypeOrFieldNameRegExp);return match?match[0]:storeFieldName;}export function selectionSetMatchesResult(selectionSet,result,variables){if(isNonNullObject(result)){return isArray(result)?result.every(function(item){return selectionSetMatchesResult(selectionSet,item,variables);}):selectionSet.selections.every(function(field){if(isField(field)&&shouldInclude(field,variables)){var key=resultKeyNameFromField(field);return hasOwn.call(result,key)&&(!field.selectionSet||selectionSetMatchesResult(field.selectionSet,result[key],variables));}return true;});}return false;}export function storeValueIsStoreObject(value){return isNonNullObject(value)&&!isReference(value)&&!isArray(value);}export function makeProcessedFieldsMerger(){return new DeepMerger();}export function extractFragmentContext(document,fragments){var fragmentMap=createFragmentMap(getFragmentDefinitions(document));return{fragmentMap:fragmentMap,lookupFragment:function lookupFragment(name){var def=fragmentMap[name];if(!def&&fragments){def=fragments.lookup(name);}return def||null;}};}","map":{"version":3,"mappings":"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","names":["isReference","isField","DeepMerger","resultKeyNameFromField","shouldInclude","isNonNullObject","compact","createFragmentMap","getFragmentDefinitions","hasOwn","Object","prototype","hasOwnProperty","isNullish","value","isArray","Array","defaultDataIdFromObject","_a","context","__typename","id","_id","keyObject","concat","JSON","stringify","defaultConfig","dataIdFromObject","addTypename","resultCaching","canonizeResults","normalizeConfig","config","shouldCanonizeResults","getTypenameFromStoreObject","store","objectOrReference","get","__ref","TypeOrFieldNameRegExp","fieldNameFromStoreName","storeFieldName","match","selectionSetMatchesResult","selectionSet","result","variables","every","item","selections","field","key","call","storeValueIsStoreObject","makeProcessedFieldsMerger","extractFragmentContext","document","fragments","fragmentMap","lookupFragment","name","def","lookup"],"sourceRoot":"","sources":["../../../src/cache/inmemory/helpers.ts"],"sourcesContent":["import { DocumentNode, FragmentDefinitionNode, SelectionSetNode } from 'graphql';\n\nimport {\n  NormalizedCache,\n  InMemoryCacheConfig,\n} from './types';\n\nimport { KeyFieldsContext } from './policies';\nimport { FragmentRegistryAPI } from './fragmentRegistry';\n\nimport {\n  Reference,\n  isReference,\n  StoreValue,\n  StoreObject,\n  isField,\n  DeepMerger,\n  resultKeyNameFromField,\n  shouldInclude,\n  isNonNullObject,\n  compact,\n  FragmentMap,\n  FragmentMapFunction,\n  createFragmentMap,\n  getFragmentDefinitions,\n} from '../../utilities';\n\nexport const {\n  hasOwnProperty: hasOwn,\n} = Object.prototype;\n\nexport function isNullish(value: any): value is null | undefined {\n  return value === null || value === void 0;\n}\n\nexport const isArray: (a: any) => a is any[] | readonly any[] = Array.isArray;\n\nexport function defaultDataIdFromObject(\n  { __typename, id, _id }: Readonly<StoreObject>,\n  context?: KeyFieldsContext,\n): string | undefined {\n  if (typeof __typename === \"string\") {\n    if (context) {\n      context.keyObject =\n        !isNullish(id) ? { id } :\n        !isNullish(_id) ? { _id } :\n        void 0;\n    }\n\n    // If there is no object.id, fall back to object._id.\n    if (isNullish(id) && !isNullish(_id)) {\n      id = _id;\n    }\n\n    if (!isNullish(id)) {\n      return `${__typename}:${(\n        typeof id === \"number\" ||\n        typeof id === \"string\"\n      ) ? id : JSON.stringify(id)}`;\n    }\n  }\n}\n\nconst defaultConfig = {\n  dataIdFromObject: defaultDataIdFromObject,\n  addTypename: true,\n  resultCaching: true,\n  // Thanks to the shouldCanonizeResults helper, this should be the only line\n  // you have to change to reenable canonization by default in the future.\n  canonizeResults: false,\n};\n\nexport function normalizeConfig(config: InMemoryCacheConfig) {\n  return compact(defaultConfig, config);\n}\n\nexport function shouldCanonizeResults(\n  config: Pick<InMemoryCacheConfig, \"canonizeResults\">,\n): boolean {\n  const value = config.canonizeResults;\n  return value === void 0 ? defaultConfig.canonizeResults : value;\n}\n\nexport function getTypenameFromStoreObject(\n  store: NormalizedCache,\n  objectOrReference: StoreObject | Reference,\n): string | undefined {\n  return isReference(objectOrReference)\n    ? store.get(objectOrReference.__ref, \"__typename\") as string\n    : objectOrReference && objectOrReference.__typename;\n}\n\nexport const TypeOrFieldNameRegExp = /^[_a-z][_0-9a-z]*/i;\n\nexport function fieldNameFromStoreName(storeFieldName: string): string {\n  const match = storeFieldName.match(TypeOrFieldNameRegExp);\n  return match ? match[0] : storeFieldName;\n}\n\nexport function selectionSetMatchesResult(\n  selectionSet: SelectionSetNode,\n  result: Record<string, any>,\n  variables?: Record<string, any>,\n): boolean {\n  if (isNonNullObject(result)) {\n    return isArray(result)\n      ? result.every(item => selectionSetMatchesResult(selectionSet, item, variables))\n      : selectionSet.selections.every(field => {\n        if (isField(field) && shouldInclude(field, variables)) {\n          const key = resultKeyNameFromField(field);\n          return hasOwn.call(result, key) &&\n            (!field.selectionSet ||\n             selectionSetMatchesResult(field.selectionSet, result[key], variables));\n        }\n        // If the selection has been skipped with @skip(true) or\n        // @include(false), it should not count against the matching. If\n        // the selection is not a field, it must be a fragment (inline or\n        // named). We will determine if selectionSetMatchesResult for that\n        // fragment when we get to it, so for now we return true.\n        return true;\n      });\n  }\n  return false;\n}\n\nexport function storeValueIsStoreObject(\n  value: StoreValue,\n): value is StoreObject {\n  return isNonNullObject(value) &&\n    !isReference(value) &&\n    !isArray(value);\n}\n\nexport function makeProcessedFieldsMerger() {\n  return new DeepMerger;\n}\n\nexport function extractFragmentContext(\n  document: DocumentNode,\n  fragments?: FragmentRegistryAPI,\n): {\n  fragmentMap: FragmentMap;\n  lookupFragment: FragmentMapFunction;\n} {\n  // FragmentMap consisting only of fragments defined directly in document, not\n  // including other fragments registered in the FragmentRegistry.\n  const fragmentMap = createFragmentMap(getFragmentDefinitions(document));\n  return {\n    fragmentMap,\n    lookupFragment(name) {\n      let def: FragmentDefinitionNode | null = fragmentMap[name];\n      if (!def && fragments) {\n        def = fragments.lookup(name);\n      }\n      return def || null;\n    },\n  };\n}\n"]},"metadata":{},"sourceType":"module"}