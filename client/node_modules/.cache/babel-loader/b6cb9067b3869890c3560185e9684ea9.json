{"ast":null,"code":"import{isInterfaceType,isObjectType,isListType,isNonNullType,isAbstractType}from\"../type/definition.mjs\";/**\n * Provided two types, return true if the types are equal (invariant).\n */export function isEqualType(typeA,typeB){// Equivalent types are equal.\nif(typeA===typeB){return true;}// If either type is non-null, the other must also be non-null.\nif(isNonNullType(typeA)&&isNonNullType(typeB)){return isEqualType(typeA.ofType,typeB.ofType);}// If either type is a list, the other must also be a list.\nif(isListType(typeA)&&isListType(typeB)){return isEqualType(typeA.ofType,typeB.ofType);}// Otherwise the types are not equal.\nreturn false;}/**\n * Provided a type and a super type, return true if the first type is either\n * equal or a subset of the second super type (covariant).\n */export function isTypeSubTypeOf(schema,maybeSubType,superType){// Equivalent type is a valid subtype\nif(maybeSubType===superType){return true;}// If superType is non-null, maybeSubType must also be non-null.\nif(isNonNullType(superType)){if(isNonNullType(maybeSubType)){return isTypeSubTypeOf(schema,maybeSubType.ofType,superType.ofType);}return false;}if(isNonNullType(maybeSubType)){// If superType is nullable, maybeSubType may be non-null or nullable.\nreturn isTypeSubTypeOf(schema,maybeSubType.ofType,superType);}// If superType type is a list, maybeSubType type must also be a list.\nif(isListType(superType)){if(isListType(maybeSubType)){return isTypeSubTypeOf(schema,maybeSubType.ofType,superType.ofType);}return false;}if(isListType(maybeSubType)){// If superType is not a list, maybeSubType must also be not a list.\nreturn false;}// If superType type is an abstract type, check if it is super type of maybeSubType.\n// Otherwise, the child type is not a valid subtype of the parent type.\nreturn isAbstractType(superType)&&(isInterfaceType(maybeSubType)||isObjectType(maybeSubType))&&schema.isSubType(superType,maybeSubType);}/**\n * Provided two composite types, determine if they \"overlap\". Two composite\n * types overlap when the Sets of possible concrete types for each intersect.\n *\n * This is often used to determine if a fragment of a given type could possibly\n * be visited in a context of another type.\n *\n * This function is commutative.\n */export function doTypesOverlap(schema,typeA,typeB){// Equivalent types overlap\nif(typeA===typeB){return true;}if(isAbstractType(typeA)){if(isAbstractType(typeB)){// If both types are abstract, then determine if there is any intersection\n// between possible concrete types of each.\nreturn schema.getPossibleTypes(typeA).some(function(type){return schema.isSubType(typeB,type);});}// Determine if the latter type is a possible concrete type of the former.\nreturn schema.isSubType(typeA,typeB);}if(isAbstractType(typeB)){// Determine if the former type is a possible concrete type of the latter.\nreturn schema.isSubType(typeB,typeA);}// Otherwise the types do not overlap.\nreturn false;}","map":{"version":3,"names":["isInterfaceType","isObjectType","isListType","isNonNullType","isAbstractType","isEqualType","typeA","typeB","ofType","isTypeSubTypeOf","schema","maybeSubType","superType","isSubType","doTypesOverlap","getPossibleTypes","some","type"],"sources":["C:/Users/jarma/school/challenges/Project3_Final/client/src/node_modules/graphql/utilities/typeComparators.mjs"],"sourcesContent":["import { isInterfaceType, isObjectType, isListType, isNonNullType, isAbstractType } from \"../type/definition.mjs\";\n/**\n * Provided two types, return true if the types are equal (invariant).\n */\n\nexport function isEqualType(typeA, typeB) {\n  // Equivalent types are equal.\n  if (typeA === typeB) {\n    return true;\n  } // If either type is non-null, the other must also be non-null.\n\n\n  if (isNonNullType(typeA) && isNonNullType(typeB)) {\n    return isEqualType(typeA.ofType, typeB.ofType);\n  } // If either type is a list, the other must also be a list.\n\n\n  if (isListType(typeA) && isListType(typeB)) {\n    return isEqualType(typeA.ofType, typeB.ofType);\n  } // Otherwise the types are not equal.\n\n\n  return false;\n}\n/**\n * Provided a type and a super type, return true if the first type is either\n * equal or a subset of the second super type (covariant).\n */\n\nexport function isTypeSubTypeOf(schema, maybeSubType, superType) {\n  // Equivalent type is a valid subtype\n  if (maybeSubType === superType) {\n    return true;\n  } // If superType is non-null, maybeSubType must also be non-null.\n\n\n  if (isNonNullType(superType)) {\n    if (isNonNullType(maybeSubType)) {\n      return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);\n    }\n\n    return false;\n  }\n\n  if (isNonNullType(maybeSubType)) {\n    // If superType is nullable, maybeSubType may be non-null or nullable.\n    return isTypeSubTypeOf(schema, maybeSubType.ofType, superType);\n  } // If superType type is a list, maybeSubType type must also be a list.\n\n\n  if (isListType(superType)) {\n    if (isListType(maybeSubType)) {\n      return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);\n    }\n\n    return false;\n  }\n\n  if (isListType(maybeSubType)) {\n    // If superType is not a list, maybeSubType must also be not a list.\n    return false;\n  } // If superType type is an abstract type, check if it is super type of maybeSubType.\n  // Otherwise, the child type is not a valid subtype of the parent type.\n\n\n  return isAbstractType(superType) && (isInterfaceType(maybeSubType) || isObjectType(maybeSubType)) && schema.isSubType(superType, maybeSubType);\n}\n/**\n * Provided two composite types, determine if they \"overlap\". Two composite\n * types overlap when the Sets of possible concrete types for each intersect.\n *\n * This is often used to determine if a fragment of a given type could possibly\n * be visited in a context of another type.\n *\n * This function is commutative.\n */\n\nexport function doTypesOverlap(schema, typeA, typeB) {\n  // Equivalent types overlap\n  if (typeA === typeB) {\n    return true;\n  }\n\n  if (isAbstractType(typeA)) {\n    if (isAbstractType(typeB)) {\n      // If both types are abstract, then determine if there is any intersection\n      // between possible concrete types of each.\n      return schema.getPossibleTypes(typeA).some(function (type) {\n        return schema.isSubType(typeB, type);\n      });\n    } // Determine if the latter type is a possible concrete type of the former.\n\n\n    return schema.isSubType(typeA, typeB);\n  }\n\n  if (isAbstractType(typeB)) {\n    // Determine if the former type is a possible concrete type of the latter.\n    return schema.isSubType(typeB, typeA);\n  } // Otherwise the types do not overlap.\n\n\n  return false;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}