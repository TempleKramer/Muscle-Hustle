{"ast":null,"code":"import{__assign,__extends}from\"tslib\";import{invariant}from\"../../utilities/globals/index.js\";import\"./fixPolyfills.js\";import{wrap}from'optimism';import{equal}from'@wry/equality';import{ApolloCache}from\"../core/cache.js\";import{MissingFieldError}from\"../core/types/common.js\";import{addTypenameToDocument,isReference}from\"../../utilities/index.js\";import{StoreReader}from\"./readFromStore.js\";import{StoreWriter}from\"./writeToStore.js\";import{EntityStore,supportsResultCaching}from\"./entityStore.js\";import{makeVar,forgetCache,recallCache}from\"./reactiveVars.js\";import{Policies}from\"./policies.js\";import{hasOwn,normalizeConfig,shouldCanonizeResults}from\"./helpers.js\";import{canonicalStringify}from\"./object-canon.js\";var InMemoryCache=function(_super){__extends(InMemoryCache,_super);function InMemoryCache(config){if(config===void 0){config={};}var _this=_super.call(this)||this;_this.watches=new Set();_this.typenameDocumentCache=new Map();_this.makeVar=makeVar;_this.txCount=0;_this.config=normalizeConfig(config);_this.addTypename=!!_this.config.addTypename;_this.policies=new Policies({cache:_this,dataIdFromObject:_this.config.dataIdFromObject,possibleTypes:_this.config.possibleTypes,typePolicies:_this.config.typePolicies});_this.init();return _this;}InMemoryCache.prototype.init=function(){var rootStore=this.data=new EntityStore.Root({policies:this.policies,resultCaching:this.config.resultCaching});this.optimisticData=rootStore.stump;this.resetResultCache();};InMemoryCache.prototype.resetResultCache=function(resetResultIdentities){var _this=this;var previousReader=this.storeReader;var fragments=this.config.fragments;this.storeWriter=new StoreWriter(this,this.storeReader=new StoreReader({cache:this,addTypename:this.addTypename,resultCacheMaxSize:this.config.resultCacheMaxSize,canonizeResults:shouldCanonizeResults(this.config),canon:resetResultIdentities?void 0:previousReader&&previousReader.canon,fragments:fragments}),fragments);this.maybeBroadcastWatch=wrap(function(c,options){return _this.broadcastWatch(c,options);},{max:this.config.resultCacheMaxSize,makeCacheKey:function makeCacheKey(c){var store=c.optimistic?_this.optimisticData:_this.data;if(supportsResultCaching(store)){var optimistic=c.optimistic,id=c.id,variables=c.variables;return store.makeCacheKey(c.query,c.callback,canonicalStringify({optimistic:optimistic,id:id,variables:variables}));}}});new Set([this.data.group,this.optimisticData.group]).forEach(function(group){return group.resetCaching();});};InMemoryCache.prototype.restore=function(data){this.init();if(data)this.data.replace(data);return this;};InMemoryCache.prototype.extract=function(optimistic){if(optimistic===void 0){optimistic=false;}return(optimistic?this.optimisticData:this.data).extract();};InMemoryCache.prototype.read=function(options){var _a=options.returnPartialData,returnPartialData=_a===void 0?false:_a;try{return this.storeReader.diffQueryAgainstStore(__assign(__assign({},options),{store:options.optimistic?this.optimisticData:this.data,config:this.config,returnPartialData:returnPartialData})).result||null;}catch(e){if(e instanceof MissingFieldError){return null;}throw e;}};InMemoryCache.prototype.write=function(options){try{++this.txCount;return this.storeWriter.writeToStore(this.data,options);}finally{if(! --this.txCount&&options.broadcast!==false){this.broadcastWatches();}}};InMemoryCache.prototype.modify=function(options){if(hasOwn.call(options,\"id\")&&!options.id){return false;}var store=options.optimistic?this.optimisticData:this.data;try{++this.txCount;return store.modify(options.id||\"ROOT_QUERY\",options.fields);}finally{if(! --this.txCount&&options.broadcast!==false){this.broadcastWatches();}}};InMemoryCache.prototype.diff=function(options){return this.storeReader.diffQueryAgainstStore(__assign(__assign({},options),{store:options.optimistic?this.optimisticData:this.data,rootId:options.id||\"ROOT_QUERY\",config:this.config}));};InMemoryCache.prototype.watch=function(watch){var _this=this;if(!this.watches.size){recallCache(this);}this.watches.add(watch);if(watch.immediate){this.maybeBroadcastWatch(watch);}return function(){if(_this.watches.delete(watch)&&!_this.watches.size){forgetCache(_this);}_this.maybeBroadcastWatch.forget(watch);};};InMemoryCache.prototype.gc=function(options){canonicalStringify.reset();var ids=this.optimisticData.gc();if(options&&!this.txCount){if(options.resetResultCache){this.resetResultCache(options.resetResultIdentities);}else if(options.resetResultIdentities){this.storeReader.resetCanon();}}return ids;};InMemoryCache.prototype.retain=function(rootId,optimistic){return(optimistic?this.optimisticData:this.data).retain(rootId);};InMemoryCache.prototype.release=function(rootId,optimistic){return(optimistic?this.optimisticData:this.data).release(rootId);};InMemoryCache.prototype.identify=function(object){if(isReference(object))return object.__ref;try{return this.policies.identify(object)[0];}catch(e){__DEV__&&invariant.warn(e);}};InMemoryCache.prototype.evict=function(options){if(!options.id){if(hasOwn.call(options,\"id\")){return false;}options=__assign(__assign({},options),{id:\"ROOT_QUERY\"});}try{++this.txCount;return this.optimisticData.evict(options,this.data);}finally{if(! --this.txCount&&options.broadcast!==false){this.broadcastWatches();}}};InMemoryCache.prototype.reset=function(options){var _this=this;this.init();canonicalStringify.reset();if(options&&options.discardWatches){this.watches.forEach(function(watch){return _this.maybeBroadcastWatch.forget(watch);});this.watches.clear();forgetCache(this);}else{this.broadcastWatches();}return Promise.resolve();};InMemoryCache.prototype.removeOptimistic=function(idToRemove){var newOptimisticData=this.optimisticData.removeLayer(idToRemove);if(newOptimisticData!==this.optimisticData){this.optimisticData=newOptimisticData;this.broadcastWatches();}};InMemoryCache.prototype.batch=function(options){var _this=this;var update=options.update,_a=options.optimistic,optimistic=_a===void 0?true:_a,removeOptimistic=options.removeOptimistic,_onWatchUpdated=options.onWatchUpdated;var updateResult;var perform=function perform(layer){var _a=_this,data=_a.data,optimisticData=_a.optimisticData;++_this.txCount;if(layer){_this.data=_this.optimisticData=layer;}try{return updateResult=update(_this);}finally{--_this.txCount;_this.data=data;_this.optimisticData=optimisticData;}};var alreadyDirty=new Set();if(_onWatchUpdated&&!this.txCount){this.broadcastWatches(__assign(__assign({},options),{onWatchUpdated:function onWatchUpdated(watch){alreadyDirty.add(watch);return false;}}));}if(typeof optimistic==='string'){this.optimisticData=this.optimisticData.addLayer(optimistic,perform);}else if(optimistic===false){perform(this.data);}else{perform();}if(typeof removeOptimistic===\"string\"){this.optimisticData=this.optimisticData.removeLayer(removeOptimistic);}if(_onWatchUpdated&&alreadyDirty.size){this.broadcastWatches(__assign(__assign({},options),{onWatchUpdated:function onWatchUpdated(watch,diff){var result=_onWatchUpdated.call(this,watch,diff);if(result!==false){alreadyDirty.delete(watch);}return result;}}));if(alreadyDirty.size){alreadyDirty.forEach(function(watch){return _this.maybeBroadcastWatch.dirty(watch);});}}else{this.broadcastWatches(options);}return updateResult;};InMemoryCache.prototype.performTransaction=function(update,optimisticId){return this.batch({update:update,optimistic:optimisticId||optimisticId!==null});};InMemoryCache.prototype.transformDocument=function(document){if(this.addTypename){var result=this.typenameDocumentCache.get(document);if(!result){result=addTypenameToDocument(document);this.typenameDocumentCache.set(document,result);this.typenameDocumentCache.set(result,result);}return result;}return document;};InMemoryCache.prototype.transformForLink=function(document){var fragments=this.config.fragments;return fragments?fragments.transform(document):document;};InMemoryCache.prototype.broadcastWatches=function(options){var _this=this;if(!this.txCount){this.watches.forEach(function(c){return _this.maybeBroadcastWatch(c,options);});}};InMemoryCache.prototype.broadcastWatch=function(c,options){var lastDiff=c.lastDiff;var diff=this.diff(c);if(options){if(c.optimistic&&typeof options.optimistic===\"string\"){diff.fromOptimisticTransaction=true;}if(options.onWatchUpdated&&options.onWatchUpdated.call(this,c,diff,lastDiff)===false){return;}}if(!lastDiff||!equal(lastDiff.result,diff.result)){c.callback(c.lastDiff=diff,lastDiff);}};return InMemoryCache;}(ApolloCache);export{InMemoryCache};","map":{"version":3,"mappings":"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","names":["invariant","wrap","equal","ApolloCache","MissingFieldError","addTypenameToDocument","isReference","StoreReader","StoreWriter","EntityStore","supportsResultCaching","makeVar","forgetCache","recallCache","Policies","hasOwn","normalizeConfig","shouldCanonizeResults","canonicalStringify","__extends","config","_super","_this","Set","Map","addTypename","policies","cache","dataIdFromObject","possibleTypes","typePolicies","init","InMemoryCache","rootStore","data","Root","resultCaching","optimisticData","stump","resetResultCache","resetResultIdentities","previousReader","storeReader","fragments","storeWriter","resultCacheMaxSize","canonizeResults","canon","maybeBroadcastWatch","c","options","broadcastWatch","max","makeCacheKey","store","optimistic","id","variables","query","callback","group","forEach","resetCaching","replace","extract","_a","diffQueryAgainstStore","__assign","returnPartialData","result","e","txCount","writeToStore","broadcast","broadcastWatches","call","modify","fields","rootId","watch","watches","size","add","immediate","delete","forget","reset","ids","gc","resetCanon","retain","release","object","__ref","identify","__DEV__","evict","discardWatches","clear","Promise","resolve","idToRemove","newOptimisticData","removeLayer","removeOptimistic","onWatchUpdated","updateResult","perform","layer","update","alreadyDirty","addLayer","diff","dirty","optimisticId","batch","document","typenameDocumentCache","get","set","transform","fromOptimisticTransaction","lastDiff"],"sourceRoot":"","sources":["../../../src/cache/inmemory/inMemoryCache.ts"],"sourcesContent":["import { invariant } from '../../utilities/globals';\n\n// Make builtins like Map and Set safe to use with non-extensible objects.\nimport './fixPolyfills';\n\nimport { DocumentNode } from 'graphql';\nimport { OptimisticWrapperFunction, wrap } from 'optimism';\nimport { equal } from '@wry/equality';\n\nimport { ApolloCache } from '../core/cache';\nimport { Cache } from '../core/types/Cache';\nimport { MissingFieldError } from '../core/types/common';\nimport {\n  addTypenameToDocument,\n  StoreObject,\n  Reference,\n  isReference,\n} from '../../utilities';\nimport { InMemoryCacheConfig, NormalizedCacheObject } from './types';\nimport { StoreReader } from './readFromStore';\nimport { StoreWriter } from './writeToStore';\nimport { EntityStore, supportsResultCaching } from './entityStore';\nimport { makeVar, forgetCache, recallCache } from './reactiveVars';\nimport { Policies } from './policies';\nimport { hasOwn, normalizeConfig, shouldCanonizeResults } from './helpers';\nimport { canonicalStringify } from './object-canon';\n\ntype BroadcastOptions = Pick<\n  Cache.BatchOptions<InMemoryCache>,\n  | \"optimistic\"\n  | \"onWatchUpdated\"\n>\n\nexport class InMemoryCache extends ApolloCache<NormalizedCacheObject> {\n  private data: EntityStore;\n  private optimisticData: EntityStore;\n\n  protected config: InMemoryCacheConfig;\n  private watches = new Set<Cache.WatchOptions>();\n  private addTypename: boolean;\n\n  private typenameDocumentCache = new Map<DocumentNode, DocumentNode>();\n  private storeReader: StoreReader;\n  private storeWriter: StoreWriter;\n\n  private maybeBroadcastWatch: OptimisticWrapperFunction<\n    [Cache.WatchOptions, BroadcastOptions?],\n    any,\n    [Cache.WatchOptions]>;\n\n  // Dynamically imported code can augment existing typePolicies or\n  // possibleTypes by calling cache.policies.addTypePolicies or\n  // cache.policies.addPossibletypes.\n  public readonly policies: Policies;\n\n  public readonly makeVar = makeVar;\n\n  constructor(config: InMemoryCacheConfig = {}) {\n    super();\n    this.config = normalizeConfig(config);\n    this.addTypename = !!this.config.addTypename;\n\n    this.policies = new Policies({\n      cache: this,\n      dataIdFromObject: this.config.dataIdFromObject,\n      possibleTypes: this.config.possibleTypes,\n      typePolicies: this.config.typePolicies,\n    });\n\n    this.init();\n  }\n\n  private init() {\n    // Passing { resultCaching: false } in the InMemoryCache constructor options\n    // will completely disable dependency tracking, which will improve memory\n    // usage but worsen the performance of repeated reads.\n    const rootStore = this.data = new EntityStore.Root({\n      policies: this.policies,\n      resultCaching: this.config.resultCaching,\n    });\n\n    // When no optimistic writes are currently active, cache.optimisticData ===\n    // cache.data, so there are no additional layers on top of the actual data.\n    // When an optimistic update happens, this.optimisticData will become a\n    // linked list of EntityStore Layer objects that terminates with the\n    // original this.data cache object.\n    this.optimisticData = rootStore.stump;\n\n    this.resetResultCache();\n  }\n\n  private resetResultCache(resetResultIdentities?: boolean) {\n    const previousReader = this.storeReader;\n    const { fragments } = this.config;\n\n    // The StoreWriter is mostly stateless and so doesn't really need to be\n    // reset, but it does need to have its writer.storeReader reference updated,\n    // so it's simpler to update this.storeWriter as well.\n    this.storeWriter = new StoreWriter(\n      this,\n      this.storeReader = new StoreReader({\n        cache: this,\n        addTypename: this.addTypename,\n        resultCacheMaxSize: this.config.resultCacheMaxSize,\n        canonizeResults: shouldCanonizeResults(this.config),\n        canon: resetResultIdentities\n          ? void 0\n          : previousReader && previousReader.canon,\n        fragments,\n      }),\n      fragments,\n    );\n\n    this.maybeBroadcastWatch = wrap((\n      c: Cache.WatchOptions,\n      options?: BroadcastOptions,\n    ) => {\n      return this.broadcastWatch(c, options);\n    }, {\n      max: this.config.resultCacheMaxSize,\n      makeCacheKey: (c: Cache.WatchOptions) => {\n        // Return a cache key (thus enabling result caching) only if we're\n        // currently using a data store that can track cache dependencies.\n        const store = c.optimistic ? this.optimisticData : this.data;\n        if (supportsResultCaching(store)) {\n          const { optimistic, id, variables } = c;\n          return store.makeCacheKey(\n            c.query,\n            // Different watches can have the same query, optimistic\n            // status, rootId, and variables, but if their callbacks are\n            // different, the (identical) result needs to be delivered to\n            // each distinct callback. The easiest way to achieve that\n            // separation is to include c.callback in the cache key for\n            // maybeBroadcastWatch calls. See issue #5733.\n            c.callback,\n            canonicalStringify({ optimistic, id, variables }),\n          );\n        }\n      }\n    });\n\n    // Since we have thrown away all the cached functions that depend on the\n    // CacheGroup dependencies maintained by EntityStore, we should also reset\n    // all CacheGroup dependency information.\n    new Set([\n      this.data.group,\n      this.optimisticData.group,\n    ]).forEach(group => group.resetCaching());\n  }\n\n  public restore(data: NormalizedCacheObject): this {\n    this.init();\n    // Since calling this.init() discards/replaces the entire StoreReader, along\n    // with the result caches it maintains, this.data.replace(data) won't have\n    // to bother deleting the old data.\n    if (data) this.data.replace(data);\n    return this;\n  }\n\n  public extract(optimistic: boolean = false): NormalizedCacheObject {\n    return (optimistic ? this.optimisticData : this.data).extract();\n  }\n\n  public read<T>(options: Cache.ReadOptions): T | null {\n    const {\n      // Since read returns data or null, without any additional metadata\n      // about whether/where there might have been missing fields, the\n      // default behavior cannot be returnPartialData = true (like it is\n      // for the diff method), since defaulting to true would violate the\n      // integrity of the T in the return type. However, partial data may\n      // be useful in some cases, so returnPartialData:true may be\n      // specified explicitly.\n      returnPartialData = false,\n    } = options;\n    try {\n      return this.storeReader.diffQueryAgainstStore<T>({\n        ...options,\n        store: options.optimistic ? this.optimisticData : this.data,\n        config: this.config,\n        returnPartialData,\n      }).result || null;\n    } catch (e) {\n      if (e instanceof MissingFieldError) {\n        // Swallow MissingFieldError and return null, so callers do not need to\n        // worry about catching \"normal\" exceptions resulting from incomplete\n        // cache data. Unexpected errors will be re-thrown. If you need more\n        // information about which fields were missing, use cache.diff instead,\n        // and examine diffResult.missing.\n        return null;\n      }\n      throw e;\n    }\n  }\n\n  public write(options: Cache.WriteOptions): Reference | undefined {\n    try {\n      ++this.txCount;\n      return this.storeWriter.writeToStore(this.data, options);\n    } finally {\n      if (!--this.txCount && options.broadcast !== false) {\n        this.broadcastWatches();\n      }\n    }\n  }\n\n  public modify(options: Cache.ModifyOptions): boolean {\n    if (hasOwn.call(options, \"id\") && !options.id) {\n      // To my knowledge, TypeScript does not currently provide a way to\n      // enforce that an optional property?:type must *not* be undefined\n      // when present. That ability would be useful here, because we want\n      // options.id to default to ROOT_QUERY only when no options.id was\n      // provided. If the caller attempts to pass options.id with a\n      // falsy/undefined value (perhaps because cache.identify failed), we\n      // should not assume the goal was to modify the ROOT_QUERY object.\n      // We could throw, but it seems natural to return false to indicate\n      // that nothing was modified.\n      return false;\n    }\n    const store = options.optimistic // Defaults to false.\n      ? this.optimisticData\n      : this.data;\n    try {\n      ++this.txCount;\n      return store.modify(options.id || \"ROOT_QUERY\", options.fields);\n    } finally {\n      if (!--this.txCount && options.broadcast !== false) {\n        this.broadcastWatches();\n      }\n    }\n  }\n\n  public diff<TData, TVariables = any>(\n    options: Cache.DiffOptions<TData, TVariables>,\n  ): Cache.DiffResult<TData> {\n    return this.storeReader.diffQueryAgainstStore({\n      ...options,\n      store: options.optimistic ? this.optimisticData : this.data,\n      rootId: options.id || \"ROOT_QUERY\",\n      config: this.config,\n    });\n  }\n\n  public watch<TData = any, TVariables = any>(\n    watch: Cache.WatchOptions<TData, TVariables>,\n  ): () => void {\n    if (!this.watches.size) {\n      // In case we previously called forgetCache(this) because\n      // this.watches became empty (see below), reattach this cache to any\n      // reactive variables on which it previously depended. It might seem\n      // paradoxical that we're able to recall something we supposedly\n      // forgot, but the point of calling forgetCache(this) is to silence\n      // useless broadcasts while this.watches is empty, and to allow the\n      // cache to be garbage collected. If, however, we manage to call\n      // recallCache(this) here, this cache object must not have been\n      // garbage collected yet, and should resume receiving updates from\n      // reactive variables, now that it has a watcher to notify.\n      recallCache(this);\n    }\n    this.watches.add(watch);\n    if (watch.immediate) {\n      this.maybeBroadcastWatch(watch);\n    }\n    return () => {\n      // Once we remove the last watch from this.watches, cache.broadcastWatches\n      // no longer does anything, so we preemptively tell the reactive variable\n      // system to exclude this cache from future broadcasts.\n      if (this.watches.delete(watch) && !this.watches.size) {\n        forgetCache(this);\n      }\n      // Remove this watch from the LRU cache managed by the\n      // maybeBroadcastWatch OptimisticWrapperFunction, to prevent memory\n      // leaks involving the closure of watch.callback.\n      this.maybeBroadcastWatch.forget(watch);\n    };\n  }\n\n  public gc(options?: {\n    // If true, also free non-essential result cache memory by bulk-releasing\n    // this.{store{Reader,Writer},maybeBroadcastWatch}. Defaults to false.\n    resetResultCache?: boolean;\n    // If resetResultCache is true, this.storeReader.canon will be preserved by\n    // default, but can also be discarded by passing resetResultIdentities:true.\n    // Defaults to false.\n    resetResultIdentities?: boolean;\n  }) {\n    canonicalStringify.reset();\n    const ids = this.optimisticData.gc();\n    if (options && !this.txCount) {\n      if (options.resetResultCache) {\n        this.resetResultCache(options.resetResultIdentities);\n      } else if (options.resetResultIdentities) {\n        this.storeReader.resetCanon();\n      }\n    }\n    return ids;\n  }\n\n  // Call this method to ensure the given root ID remains in the cache after\n  // garbage collection, along with its transitive child entities. Note that\n  // the cache automatically retains all directly written entities. By default,\n  // the retainment persists after optimistic updates are removed. Pass true\n  // for the optimistic argument if you would prefer for the retainment to be\n  // discarded when the top-most optimistic layer is removed. Returns the\n  // resulting (non-negative) retainment count.\n  public retain(rootId: string, optimistic?: boolean): number {\n    return (optimistic ? this.optimisticData : this.data).retain(rootId);\n  }\n\n  // Call this method to undo the effect of the retain method, above. Once the\n  // retainment count falls to zero, the given ID will no longer be preserved\n  // during garbage collection, though it may still be preserved by other safe\n  // entities that refer to it. Returns the resulting (non-negative) retainment\n  // count, in case that's useful.\n  public release(rootId: string, optimistic?: boolean): number {\n    return (optimistic ? this.optimisticData : this.data).release(rootId);\n  }\n\n  // Returns the canonical ID for a given StoreObject, obeying typePolicies\n  // and keyFields (and dataIdFromObject, if you still use that). At minimum,\n  // the object must contain a __typename and any primary key fields required\n  // to identify entities of that type. If you pass a query result object, be\n  // sure that none of the primary key fields have been renamed by aliasing.\n  // If you pass a Reference object, its __ref ID string will be returned.\n  public identify(object: StoreObject | Reference): string | undefined {\n    if (isReference(object)) return object.__ref;\n    try {\n      return this.policies.identify(object)[0];\n    } catch (e) {\n      invariant.warn(e);\n    }\n  }\n\n  public evict(options: Cache.EvictOptions): boolean {\n    if (!options.id) {\n      if (hasOwn.call(options, \"id\")) {\n        // See comment in modify method about why we return false when\n        // options.id exists but is falsy/undefined.\n        return false;\n      }\n      options = { ...options, id: \"ROOT_QUERY\" };\n    }\n    try {\n      // It's unlikely that the eviction will end up invoking any other\n      // cache update operations while it's running, but {in,de}crementing\n      // this.txCount still seems like a good idea, for uniformity with\n      // the other update methods.\n      ++this.txCount;\n      // Pass this.data as a limit on the depth of the eviction, so evictions\n      // during optimistic updates (when this.data is temporarily set equal to\n      // this.optimisticData) do not escape their optimistic Layer.\n      return this.optimisticData.evict(options, this.data);\n    } finally {\n      if (!--this.txCount && options.broadcast !== false) {\n        this.broadcastWatches();\n      }\n    }\n  }\n\n  public reset(options?: Cache.ResetOptions): Promise<void> {\n    this.init();\n\n    canonicalStringify.reset();\n\n    if (options && options.discardWatches) {\n      // Similar to what happens in the unsubscribe function returned by\n      // cache.watch, applied to all current watches.\n      this.watches.forEach(watch => this.maybeBroadcastWatch.forget(watch));\n      this.watches.clear();\n      forgetCache(this);\n    } else {\n      // Calling this.init() above unblocks all maybeBroadcastWatch caching, so\n      // this.broadcastWatches() triggers a broadcast to every current watcher\n      // (letting them know their data is now missing). This default behavior is\n      // convenient because it means the watches do not have to be manually\n      // reestablished after resetting the cache. To prevent this broadcast and\n      // cancel all watches, pass true for options.discardWatches.\n      this.broadcastWatches();\n    }\n\n    return Promise.resolve();\n  }\n\n  public removeOptimistic(idToRemove: string) {\n    const newOptimisticData = this.optimisticData.removeLayer(idToRemove);\n    if (newOptimisticData !== this.optimisticData) {\n      this.optimisticData = newOptimisticData;\n      this.broadcastWatches();\n    }\n  }\n\n  private txCount = 0;\n\n  public batch<TUpdateResult>(\n    options: Cache.BatchOptions<InMemoryCache, TUpdateResult>,\n  ): TUpdateResult {\n    const {\n      update,\n      optimistic = true,\n      removeOptimistic,\n      onWatchUpdated,\n    } = options;\n\n    let updateResult: TUpdateResult;\n    const perform = (layer?: EntityStore): TUpdateResult => {\n      const { data, optimisticData } = this;\n      ++this.txCount;\n      if (layer) {\n        this.data = this.optimisticData = layer;\n      }\n      try {\n        return updateResult = update(this);\n      } finally {\n        --this.txCount;\n        this.data = data;\n        this.optimisticData = optimisticData;\n      }\n    };\n\n    const alreadyDirty = new Set<Cache.WatchOptions>();\n\n    if (onWatchUpdated && !this.txCount) {\n      // If an options.onWatchUpdated callback is provided, we want to call it\n      // with only the Cache.WatchOptions objects affected by options.update,\n      // but there might be dirty watchers already waiting to be broadcast that\n      // have nothing to do with the update. To prevent including those watchers\n      // in the post-update broadcast, we perform this initial broadcast to\n      // collect the dirty watchers, so we can re-dirty them later, after the\n      // post-update broadcast, allowing them to receive their pending\n      // broadcasts the next time broadcastWatches is called, just as they would\n      // if we never called cache.batch.\n      this.broadcastWatches({\n        ...options,\n        onWatchUpdated(watch) {\n          alreadyDirty.add(watch);\n          return false;\n        },\n      });\n    }\n\n    if (typeof optimistic === 'string') {\n      // Note that there can be multiple layers with the same optimistic ID.\n      // When removeOptimistic(id) is called for that id, all matching layers\n      // will be removed, and the remaining layers will be reapplied.\n      this.optimisticData = this.optimisticData.addLayer(optimistic, perform);\n    } else if (optimistic === false) {\n      // Ensure both this.data and this.optimisticData refer to the root\n      // (non-optimistic) layer of the cache during the update. Note that\n      // this.data could be a Layer if we are currently executing an optimistic\n      // update function, but otherwise will always be an EntityStore.Root\n      // instance.\n      perform(this.data);\n    } else {\n      // Otherwise, leave this.data and this.optimisticData unchanged and run\n      // the update with broadcast batching.\n      perform();\n    }\n\n    if (typeof removeOptimistic === \"string\") {\n      this.optimisticData = this.optimisticData.removeLayer(removeOptimistic);\n    }\n\n    // Note: if this.txCount > 0, then alreadyDirty.size === 0, so this code\n    // takes the else branch and calls this.broadcastWatches(options), which\n    // does nothing when this.txCount > 0.\n    if (onWatchUpdated && alreadyDirty.size) {\n      this.broadcastWatches({\n        ...options,\n        onWatchUpdated(watch, diff) {\n          const result = onWatchUpdated.call(this, watch, diff);\n          if (result !== false) {\n            // Since onWatchUpdated did not return false, this diff is\n            // about to be broadcast to watch.callback, so we don't need\n            // to re-dirty it with the other alreadyDirty watches below.\n            alreadyDirty.delete(watch);\n          }\n          return result;\n        }\n      });\n      // Silently re-dirty any watches that were already dirty before the update\n      // was performed, and were not broadcast just now.\n      if (alreadyDirty.size) {\n        alreadyDirty.forEach(watch => this.maybeBroadcastWatch.dirty(watch));\n      }\n    } else {\n      // If alreadyDirty is empty or we don't have an onWatchUpdated\n      // function, we don't need to go to the trouble of wrapping\n      // options.onWatchUpdated.\n      this.broadcastWatches(options);\n    }\n\n    return updateResult!;\n  }\n\n  public performTransaction(\n    update: (cache: InMemoryCache) => any,\n    optimisticId?: string | null,\n  ) {\n    return this.batch({\n      update,\n      optimistic: optimisticId || (optimisticId !== null),\n    });\n  }\n\n  public transformDocument(document: DocumentNode): DocumentNode {\n    if (this.addTypename) {\n      let result = this.typenameDocumentCache.get(document);\n      if (!result) {\n        result = addTypenameToDocument(document);\n        this.typenameDocumentCache.set(document, result);\n        // If someone calls transformDocument and then mistakenly passes the\n        // result back into an API that also calls transformDocument, make sure\n        // we don't keep creating new query documents.\n        this.typenameDocumentCache.set(result, result);\n      }\n      return result;\n    }\n    return document;\n  }\n\n  public transformForLink(document: DocumentNode): DocumentNode {\n    const { fragments } = this.config;\n    return fragments\n      ? fragments.transform(document)\n      : document;\n  }\n\n  protected broadcastWatches(options?: BroadcastOptions) {\n    if (!this.txCount) {\n      this.watches.forEach(c => this.maybeBroadcastWatch(c, options));\n    }\n  }\n\n  // This method is wrapped by maybeBroadcastWatch, which is called by\n  // broadcastWatches, so that we compute and broadcast results only when\n  // the data that would be broadcast might have changed. It would be\n  // simpler to check for changes after recomputing a result but before\n  // broadcasting it, but this wrapping approach allows us to skip both\n  // the recomputation and the broadcast, in most cases.\n  private broadcastWatch(\n    c: Cache.WatchOptions,\n    options?: BroadcastOptions,\n  ) {\n    const { lastDiff } = c;\n\n    // Both WatchOptions and DiffOptions extend ReadOptions, and DiffOptions\n    // currently requires no additional properties, so we can use c (a\n    // WatchOptions object) as DiffOptions, without having to allocate a new\n    // object, and without having to enumerate the relevant properties (query,\n    // variables, etc.) explicitly. There will be some additional properties\n    // (lastDiff, callback, etc.), but cache.diff ignores them.\n    const diff = this.diff<any>(c);\n\n    if (options) {\n      if (c.optimistic &&\n          typeof options.optimistic === \"string\") {\n        diff.fromOptimisticTransaction = true;\n      }\n\n      if (options.onWatchUpdated &&\n          options.onWatchUpdated.call(this, c, diff, lastDiff) === false) {\n        // Returning false from the onWatchUpdated callback will prevent\n        // calling c.callback(diff) for this watcher.\n        return;\n      }\n    }\n\n    if (!lastDiff || !equal(lastDiff.result, diff.result)) {\n      c.callback(c.lastDiff = diff, lastDiff);\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}