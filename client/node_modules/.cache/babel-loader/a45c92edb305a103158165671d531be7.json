{"ast":null,"code":"export function iterateObserversSafely(observers,method,argument){var observersWithMethod=[];observers.forEach(function(obs){return obs[method]&&observersWithMethod.push(obs);});observersWithMethod.forEach(function(obs){return obs[method](argument);});}","map":{"version":3,"mappings":"AAEA,MAAM,SAAUA,uBAAV,CACJC,SADI,CAEJC,MAFI,CAGJC,QAHI,CAGQ,CAKZ,GAAMC,oBAAmB,CAAkB,EAA3C,CACAH,SAAS,CAACI,OAAV,CAAkB,aAAG,CAAI,UAAG,CAACH,MAAD,CAAH,EAAeE,mBAAmB,CAACE,IAApB,CAAyBC,GAAzB,CAAf,CAA4C,CAArE,EACAH,mBAAmB,CAACC,OAApB,CAA4B,aAAG,CAAI,MAACE,IAAW,CAACL,MAAD,CAAX,CAAoBC,QAApB,CAAD,CAA8B,CAAjE,EACD","names":["iterateObserversSafely","observers","method","argument","observersWithMethod","forEach","push","obs"],"sourceRoot":"","sources":["../../../src/utilities/observables/iteration.ts"],"sourcesContent":["import { Observer } from \"./Observable\";\n\nexport function iterateObserversSafely<E, A>(\n  observers: Set<Observer<E>>,\n  method: keyof Observer<E>,\n  argument?: A,\n) {\n  // In case observers is modified during iteration, we need to commit to the\n  // original elements, which also provides an opportunity to filter them down\n  // to just the observers with the given method.\n  const observersWithMethod: Observer<E>[] = [];\n  observers.forEach(obs => obs[method] && observersWithMethod.push(obs));\n  observersWithMethod.forEach(obs => (obs as any)[method](argument));\n}\n"]},"metadata":{},"sourceType":"module"}