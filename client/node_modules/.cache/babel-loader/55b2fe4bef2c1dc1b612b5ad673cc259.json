{"ast":null,"code":"// This currentContext variable will only be used if the makeSlotClass\n// function is called, which happens only if this is the first copy of the\n// @wry/context package to be imported.\nvar currentContext=null;// This unique internal object is used to denote the absence of a value\n// for a given Slot, and is never exposed to outside code.\nvar MISSING_VALUE={};var idCounter=1;// Although we can't do anything about the cost of duplicated code from\n// accidentally bundling multiple copies of the @wry/context package, we can\n// avoid creating the Slot class more than once using makeSlotClass.\nvar makeSlotClass=function makeSlotClass(){return(/** @class */function(){function Slot(){// If you have a Slot object, you can find out its slot.id, but you cannot\n// guess the slot.id of a Slot you don't have access to, thanks to the\n// randomized suffix.\nthis.id=[\"slot\",idCounter++,Date.now(),Math.random().toString(36).slice(2)].join(\":\");}Slot.prototype.hasValue=function(){for(var context_1=currentContext;context_1;context_1=context_1.parent){// We use the Slot object iself as a key to its value, which means the\n// value cannot be obtained without a reference to the Slot object.\nif(this.id in context_1.slots){var value=context_1.slots[this.id];if(value===MISSING_VALUE)break;if(context_1!==currentContext){// Cache the value in currentContext.slots so the next lookup will\n// be faster. This caching is safe because the tree of contexts and\n// the values of the slots are logically immutable.\ncurrentContext.slots[this.id]=value;}return true;}}if(currentContext){// If a value was not found for this Slot, it's never going to be found\n// no matter how many times we look it up, so we might as well cache\n// the absence of the value, too.\ncurrentContext.slots[this.id]=MISSING_VALUE;}return false;};Slot.prototype.getValue=function(){if(this.hasValue()){return currentContext.slots[this.id];}};Slot.prototype.withValue=function(value,callback,// Given the prevalence of arrow functions, specifying arguments is likely\n// to be much more common than specifying `this`, hence this ordering:\nargs,thisArg){var _a;var slots=(_a={__proto__:null},_a[this.id]=value,_a);var parent=currentContext;currentContext={parent:parent,slots:slots};try{// Function.prototype.apply allows the arguments array argument to be\n// omitted or undefined, so args! is fine here.\nreturn callback.apply(thisArg,args);}finally{currentContext=parent;}};// Capture the current context and wrap a callback function so that it\n// reestablishes the captured context when called.\nSlot.bind=function(callback){var context=currentContext;return function(){var saved=currentContext;try{currentContext=context;return callback.apply(this,arguments);}finally{currentContext=saved;}};};// Immediately run a callback function without any captured context.\nSlot.noContext=function(callback,// Given the prevalence of arrow functions, specifying arguments is likely\n// to be much more common than specifying `this`, hence this ordering:\nargs,thisArg){if(currentContext){var saved=currentContext;try{currentContext=null;// Function.prototype.apply allows the arguments array argument to be\n// omitted or undefined, so args! is fine here.\nreturn callback.apply(thisArg,args);}finally{currentContext=saved;}}else{return callback.apply(thisArg,args);}};return Slot;}());};function maybe(fn){try{return fn();}catch(ignored){}}// We store a single global implementation of the Slot class as a permanent\n// non-enumerable property of the globalThis object. This obfuscation does\n// nothing to prevent access to the Slot class, but at least it ensures the\n// implementation (i.e. currentContext) cannot be tampered with, and all copies\n// of the @wry/context package (hopefully just one) will share the same Slot\n// implementation. Since the first copy of the @wry/context package to be\n// imported wins, this technique imposes a steep cost for any future breaking\n// changes to the Slot class.\nvar globalKey=\"@wry/context:Slot\";var host=// Prefer globalThis when available.\n// https://github.com/benjamn/wryware/issues/347\nmaybe(function(){return globalThis;})||// Fall back to global, which works in Node.js and may be converted by some\n// bundlers to the appropriate identifier (window, self, ...) depending on the\n// bundling target. https://github.com/endojs/endo/issues/576#issuecomment-1178515224\nmaybe(function(){return global;})||// Otherwise, use a dummy host that's local to this module. We used to fall\n// back to using the Array constructor as a namespace, but that was flagged in\n// https://github.com/benjamn/wryware/issues/347, and can be avoided.\nObject.create(null);// Whichever globalHost we're using, make TypeScript happy about the additional\n// globalKey property.\nvar globalHost=host;var Slot=globalHost[globalKey]||// Earlier versions of this package stored the globalKey property on the Array\n// constructor, so we check there as well, to prevent Slot class duplication.\nArray[globalKey]||function(Slot){try{Object.defineProperty(globalHost,globalKey,{value:Slot,enumerable:false,writable:false,// When it was possible for globalHost to be the Array constructor (a\n// legacy Slot dedup strategy), it was important for the property to be\n// configurable:true so it could be deleted. That does not seem to be as\n// important when globalHost is the global object, but I don't want to\n// cause similar problems again, and configurable:true seems safest.\n// https://github.com/endojs/endo/issues/576#issuecomment-1178274008\nconfigurable:true});}finally{return Slot;}}(makeSlotClass());var bind=Slot.bind,noContext=Slot.noContext;function setTimeoutWithContext(callback,delay){return setTimeout(bind(callback),delay);}// Turn any generator function into an async function (using yield instead\n// of await), with context automatically preserved across yields.\nfunction asyncFromGen(genFn){return function(){var gen=genFn.apply(this,arguments);var boundNext=bind(gen.next);var boundThrow=bind(gen.throw);return new Promise(function(resolve,reject){function invoke(method,argument){try{var result=method.call(gen,argument);}catch(error){return reject(error);}var next=result.done?resolve:invokeNext;if(isPromiseLike(result.value)){result.value.then(next,result.done?reject:invokeThrow);}else{next(result.value);}}var invokeNext=function invokeNext(value){return invoke(boundNext,value);};var invokeThrow=function invokeThrow(error){return invoke(boundThrow,error);};invokeNext();});};}function isPromiseLike(value){return value&&typeof value.then===\"function\";}// If you use the fibers npm package to implement coroutines in Node.js,\n// you should call this function at least once to ensure context management\n// remains coherent across any yields.\nvar wrappedFibers=[];function wrapYieldingFiberMethods(Fiber){// There can be only one implementation of Fiber per process, so this array\n// should never grow longer than one element.\nif(wrappedFibers.indexOf(Fiber)<0){var wrap=function wrap(obj,method){var fn=obj[method];obj[method]=function(){return noContext(fn,arguments,this);};};// These methods can yield, according to\n// https://github.com/laverdet/node-fibers/blob/ddebed9b8ae3883e57f822e2108e6943e5c8d2a8/fibers.js#L97-L100\nwrap(Fiber,\"yield\");wrap(Fiber.prototype,\"run\");wrap(Fiber.prototype,\"throwInto\");wrappedFibers.push(Fiber);}return Fiber;}export{Slot,asyncFromGen,bind,noContext,setTimeoutWithContext as setTimeout,wrapYieldingFiberMethods};","map":{"version":3,"mappings":"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","names":["currentContext","MISSING_VALUE","idCounter","makeSlotClass","Date","now","Math","random","toString","slice","join","Slot","context_1","parent","id","slots","value","hasValue","callback","args","thisArg","__proto__","_a","apply","context","saved","arguments","maybe","fn","ignored","globalKey","host","Object","create","globalHost","Array","defineProperty","enumerable","writable","configurable","bind","noContext","setTimeoutWithContext","delay","setTimeout","asyncFromGen","genFn","gen","boundNext","next","boundThrow","throw","Promise","resolve","reject","invoke","method","argument","result","call","error","done","invokeNext","isPromiseLike","then","invokeThrow","wrappedFibers","wrapYieldingFiberMethods","Fiber","indexOf","wrap","obj","prototype","push"],"sources":["../src/slot.ts","../src/context.ts"],"sourcesContent":["type Context = {\n  parent: Context | null;\n  slots: { [slotId: string]: any };\n}\n\n// This currentContext variable will only be used if the makeSlotClass\n// function is called, which happens only if this is the first copy of the\n// @wry/context package to be imported.\nlet currentContext: Context | null = null;\n\n// This unique internal object is used to denote the absence of a value\n// for a given Slot, and is never exposed to outside code.\nconst MISSING_VALUE: any = {};\n\nlet idCounter = 1;\n\n// Although we can't do anything about the cost of duplicated code from\n// accidentally bundling multiple copies of the @wry/context package, we can\n// avoid creating the Slot class more than once using makeSlotClass.\nconst makeSlotClass = () => class Slot<TValue> {\n  // If you have a Slot object, you can find out its slot.id, but you cannot\n  // guess the slot.id of a Slot you don't have access to, thanks to the\n  // randomized suffix.\n  public readonly id = [\n    \"slot\",\n    idCounter++,\n    Date.now(),\n    Math.random().toString(36).slice(2),\n  ].join(\":\");\n\n  public hasValue() {\n    for (let context = currentContext; context; context = context.parent) {\n      // We use the Slot object iself as a key to its value, which means the\n      // value cannot be obtained without a reference to the Slot object.\n      if (this.id in context.slots) {\n        const value = context.slots[this.id];\n        if (value === MISSING_VALUE) break;\n        if (context !== currentContext) {\n          // Cache the value in currentContext.slots so the next lookup will\n          // be faster. This caching is safe because the tree of contexts and\n          // the values of the slots are logically immutable.\n          currentContext!.slots[this.id] = value;\n        }\n        return true;\n      }\n    }\n    if (currentContext) {\n      // If a value was not found for this Slot, it's never going to be found\n      // no matter how many times we look it up, so we might as well cache\n      // the absence of the value, too.\n      currentContext.slots[this.id] = MISSING_VALUE;\n    }\n    return false;\n  }\n\n  public getValue(): TValue | undefined {\n    if (this.hasValue()) {\n      return currentContext!.slots[this.id] as TValue;\n    }\n  }\n\n  public withValue<TResult, TArgs extends any[], TThis = any>(\n    value: TValue,\n    callback: (this: TThis, ...args: TArgs) => TResult,\n    // Given the prevalence of arrow functions, specifying arguments is likely\n    // to be much more common than specifying `this`, hence this ordering:\n    args?: TArgs,\n    thisArg?: TThis,\n  ): TResult {\n    const slots = {\n      __proto__: null,\n      [this.id]: value,\n    };\n    const parent = currentContext;\n    currentContext = { parent, slots };\n    try {\n      // Function.prototype.apply allows the arguments array argument to be\n      // omitted or undefined, so args! is fine here.\n      return callback.apply(thisArg!, args!);\n    } finally {\n      currentContext = parent;\n    }\n  }\n\n  // Capture the current context and wrap a callback function so that it\n  // reestablishes the captured context when called.\n  static bind<TArgs extends any[], TResult, TThis = any>(\n    callback: (this: TThis, ...args: TArgs) => TResult,\n  ) {\n    const context = currentContext;\n    return function (this: TThis) {\n      const saved = currentContext;\n      try {\n        currentContext = context;\n        return callback.apply(this, arguments as any);\n      } finally {\n        currentContext = saved;\n      }\n    } as typeof callback;\n  }\n\n  // Immediately run a callback function without any captured context.\n  static noContext<TResult, TArgs extends any[], TThis = any>(\n    callback: (this: TThis, ...args: TArgs) => TResult,\n    // Given the prevalence of arrow functions, specifying arguments is likely\n    // to be much more common than specifying `this`, hence this ordering:\n    args?: TArgs,\n    thisArg?: TThis,\n  ) {\n    if (currentContext) {\n      const saved = currentContext;\n      try {\n        currentContext = null;\n        // Function.prototype.apply allows the arguments array argument to be\n        // omitted or undefined, so args! is fine here.\n        return callback.apply(thisArg!, args!);\n      } finally {\n        currentContext = saved;\n      }\n    } else {\n      return callback.apply(thisArg!, args!);\n    }\n  }\n};\n\nfunction maybe<T>(fn: () => T): T | undefined {\n  try {\n    return fn();\n  } catch (ignored) {}\n}\n\n// We store a single global implementation of the Slot class as a permanent\n// non-enumerable property of the globalThis object. This obfuscation does\n// nothing to prevent access to the Slot class, but at least it ensures the\n// implementation (i.e. currentContext) cannot be tampered with, and all copies\n// of the @wry/context package (hopefully just one) will share the same Slot\n// implementation. Since the first copy of the @wry/context package to be\n// imported wins, this technique imposes a steep cost for any future breaking\n// changes to the Slot class.\nconst globalKey = \"@wry/context:Slot\";\n\nconst host =\n  // Prefer globalThis when available.\n  // https://github.com/benjamn/wryware/issues/347\n  maybe(() => globalThis) ||\n  // Fall back to global, which works in Node.js and may be converted by some\n  // bundlers to the appropriate identifier (window, self, ...) depending on the\n  // bundling target. https://github.com/endojs/endo/issues/576#issuecomment-1178515224\n  maybe(() => global) ||\n  // Otherwise, use a dummy host that's local to this module. We used to fall\n  // back to using the Array constructor as a namespace, but that was flagged in\n  // https://github.com/benjamn/wryware/issues/347, and can be avoided.\n  Object.create(null) as typeof Array;\n\n// Whichever globalHost we're using, make TypeScript happy about the additional\n// globalKey property.\nconst globalHost: typeof host & {\n  [globalKey]?: typeof Slot;\n} = host;\n\nexport const Slot: ReturnType<typeof makeSlotClass> =\n  globalHost[globalKey] ||\n  // Earlier versions of this package stored the globalKey property on the Array\n  // constructor, so we check there as well, to prevent Slot class duplication.\n  (Array as typeof globalHost)[globalKey] ||\n  (function (Slot) {\n    try {\n      Object.defineProperty(globalHost, globalKey, {\n        value: Slot,\n        enumerable: false,\n        writable: false,\n        // When it was possible for globalHost to be the Array constructor (a\n        // legacy Slot dedup strategy), it was important for the property to be\n        // configurable:true so it could be deleted. That does not seem to be as\n        // important when globalHost is the global object, but I don't want to\n        // cause similar problems again, and configurable:true seems safest.\n        // https://github.com/endojs/endo/issues/576#issuecomment-1178274008\n        configurable: true\n      });\n    } finally {\n      return Slot;\n    }\n  })(makeSlotClass());\n","import { Slot } from \"./slot\";\nexport { Slot }\nexport const { bind, noContext } = Slot;\n\n// Relying on the @types/node declaration of global.setTimeout can make\n// things tricky for dowstream projects (see PR #7).\ndeclare function setTimeout(\n  callback: (...args: any[]) => any,\n  ms?: number,\n  ...args: any[]\n): any;\n\n// Like global.setTimeout, except the callback runs with captured context.\nexport { setTimeoutWithContext as setTimeout };\nfunction setTimeoutWithContext(callback: () => any, delay: number) {\n  return setTimeout(bind(callback), delay);\n}\n\n// Turn any generator function into an async function (using yield instead\n// of await), with context automatically preserved across yields.\nexport function asyncFromGen<\n  TArgs extends any[],\n  TYield = any,\n  TReturn = any,\n  TNext = any,\n>(\n  genFn: (...args: TArgs) => Generator<TYield, TReturn, TNext>\n) {\n  return function (this: any) {\n    const gen = genFn.apply(this, arguments as any);\n\n    type Method = (\n      this: Generator<TYield, TReturn, TNext>,\n      arg: any,\n    ) => IteratorResult<TYield, TReturn>;\n\n    const boundNext: Method = bind(gen.next);\n    const boundThrow: Method = bind(gen.throw!);\n\n    return new Promise((resolve, reject) => {\n      function invoke(method: Method, argument: any) {\n        try {\n          var result: any = method.call(gen, argument);\n        } catch (error) {\n          return reject(error);\n        }\n        const next = result.done ? resolve : invokeNext;\n        if (isPromiseLike(result.value)) {\n          result.value.then(next, result.done ? reject : invokeThrow);\n        } else {\n          next(result.value);\n        }\n      }\n      const invokeNext = (value?: any) => invoke(boundNext, value);\n      const invokeThrow = (error: any) => invoke(boundThrow, error);\n      invokeNext();\n    });\n  } as (...args: TArgs) => Promise<any>;\n}\n\nfunction isPromiseLike(value: any): value is PromiseLike<any> {\n  return value && typeof value.then === \"function\";\n}\n\n// If you use the fibers npm package to implement coroutines in Node.js,\n// you should call this function at least once to ensure context management\n// remains coherent across any yields.\nconst wrappedFibers: Function[] = [];\nexport function wrapYieldingFiberMethods<F extends Function>(Fiber: F): F {\n  // There can be only one implementation of Fiber per process, so this array\n  // should never grow longer than one element.\n  if (wrappedFibers.indexOf(Fiber) < 0) {\n    const wrap = (obj: any, method: string) => {\n      const fn = obj[method];\n      obj[method] = function () {\n        return noContext(fn, arguments as any, this);\n      };\n    }\n    // These methods can yield, according to\n    // https://github.com/laverdet/node-fibers/blob/ddebed9b8ae3883e57f822e2108e6943e5c8d2a8/fibers.js#L97-L100\n    wrap(Fiber, \"yield\");\n    wrap(Fiber.prototype, \"run\");\n    wrap(Fiber.prototype, \"throwInto\");\n    wrappedFibers.push(Fiber);\n  }\n  return Fiber;\n}\n"]},"metadata":{},"sourceType":"module"}