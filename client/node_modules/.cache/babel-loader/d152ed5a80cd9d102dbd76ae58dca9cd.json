{"ast":null,"code":"import inspect from\"../jsutils/inspect.mjs\";import isAsyncIterable from\"../jsutils/isAsyncIterable.mjs\";import{addPath,pathToArray}from\"../jsutils/Path.mjs\";import{GraphQLError}from\"../error/GraphQLError.mjs\";import{locatedError}from\"../error/locatedError.mjs\";import{getArgumentValues}from\"../execution/values.mjs\";import{assertValidExecutionArguments,buildExecutionContext,buildResolveInfo,collectFields,execute,getFieldDef}from\"../execution/execute.mjs\";import{getOperationRootType}from\"../utilities/getOperationRootType.mjs\";import mapAsyncIterator from\"./mapAsyncIterator.mjs\";export function subscribe(argsOrSchema,document,rootValue,contextValue,variableValues,operationName,fieldResolver,subscribeFieldResolver){/* eslint-enable no-redeclare */ // Extract arguments from object args if provided.\nreturn arguments.length===1?subscribeImpl(argsOrSchema):subscribeImpl({schema:argsOrSchema,document:document,rootValue:rootValue,contextValue:contextValue,variableValues:variableValues,operationName:operationName,fieldResolver:fieldResolver,subscribeFieldResolver:subscribeFieldResolver});}/**\n * This function checks if the error is a GraphQLError. If it is, report it as\n * an ExecutionResult, containing only errors and no data. Otherwise treat the\n * error as a system-class error and re-throw it.\n */function reportGraphQLError(error){if(error instanceof GraphQLError){return{errors:[error]};}throw error;}function subscribeImpl(args){var schema=args.schema,document=args.document,rootValue=args.rootValue,contextValue=args.contextValue,variableValues=args.variableValues,operationName=args.operationName,fieldResolver=args.fieldResolver,subscribeFieldResolver=args.subscribeFieldResolver;var sourcePromise=createSourceEventStream(schema,document,rootValue,contextValue,variableValues,operationName,subscribeFieldResolver);// For each payload yielded from a subscription, map it over the normal\n// GraphQL `execute` function, with `payload` as the rootValue.\n// This implements the \"MapSourceToResponseEvent\" algorithm described in\n// the GraphQL specification. The `execute` function provides the\n// \"ExecuteSubscriptionEvent\" algorithm, as it is nearly identical to the\n// \"ExecuteQuery\" algorithm, for which `execute` is also used.\nvar mapSourceToResponse=function mapSourceToResponse(payload){return execute({schema:schema,document:document,rootValue:payload,contextValue:contextValue,variableValues:variableValues,operationName:operationName,fieldResolver:fieldResolver});};// Resolve the Source Stream, then map every source value to a\n// ExecutionResult value as described above.\nreturn sourcePromise.then(function(resultOrStream){return(// Note: Flow can't refine isAsyncIterable, so explicit casts are used.\nisAsyncIterable(resultOrStream)?mapAsyncIterator(resultOrStream,mapSourceToResponse,reportGraphQLError):resultOrStream);});}/**\n * Implements the \"CreateSourceEventStream\" algorithm described in the\n * GraphQL specification, resolving the subscription source event stream.\n *\n * Returns a Promise which resolves to either an AsyncIterable (if successful)\n * or an ExecutionResult (error). The promise will be rejected if the schema or\n * other arguments to this function are invalid, or if the resolved event stream\n * is not an async iterable.\n *\n * If the client-provided arguments to this function do not result in a\n * compliant subscription, a GraphQL Response (ExecutionResult) with\n * descriptive errors and no data will be returned.\n *\n * If the the source stream could not be created due to faulty subscription\n * resolver logic or underlying systems, the promise will resolve to a single\n * ExecutionResult containing `errors` and no `data`.\n *\n * If the operation succeeded, the promise resolves to the AsyncIterable for the\n * event stream returned by the resolver.\n *\n * A Source Event Stream represents a sequence of events, each of which triggers\n * a GraphQL execution for that event.\n *\n * This may be useful when hosting the stateful subscription service in a\n * different process or machine than the stateless GraphQL execution engine,\n * or otherwise separating these two steps. For more on this, see the\n * \"Supporting Subscriptions at Scale\" information in the GraphQL specification.\n */export function createSourceEventStream(schema,document,rootValue,contextValue,variableValues,operationName,fieldResolver){// If arguments are missing or incorrectly typed, this is an internal\n// developer mistake which should throw an early error.\nassertValidExecutionArguments(schema,document,variableValues);return new Promise(function(resolve){// If a valid context cannot be created due to incorrect arguments,\n// this will throw an error.\nvar exeContext=buildExecutionContext(schema,document,rootValue,contextValue,variableValues,operationName,fieldResolver);resolve(// Return early errors if execution context failed.\nArray.isArray(exeContext)?{errors:exeContext}:executeSubscription(exeContext));}).catch(reportGraphQLError);}function executeSubscription(exeContext){var schema=exeContext.schema,operation=exeContext.operation,variableValues=exeContext.variableValues,rootValue=exeContext.rootValue;var type=getOperationRootType(schema,operation);var fields=collectFields(exeContext,type,operation.selectionSet,Object.create(null),Object.create(null));var responseNames=Object.keys(fields);var responseName=responseNames[0];var fieldNodes=fields[responseName];var fieldNode=fieldNodes[0];var fieldName=fieldNode.name.value;var fieldDef=getFieldDef(schema,type,fieldName);if(!fieldDef){throw new GraphQLError(\"The subscription field \\\"\".concat(fieldName,\"\\\" is not defined.\"),fieldNodes);}var path=addPath(undefined,responseName,type.name);var info=buildResolveInfo(exeContext,fieldDef,fieldNodes,type,path);// Coerce to Promise for easier error handling and consistent return type.\nreturn new Promise(function(resolveResult){var _fieldDef$subscribe;// Implements the \"ResolveFieldEventStream\" algorithm from GraphQL specification.\n// It differs from \"ResolveFieldValue\" due to providing a different `resolveFn`.\n// Build a JS object of arguments from the field.arguments AST, using the\n// variables scope to fulfill any variable references.\nvar args=getArgumentValues(fieldDef,fieldNodes[0],variableValues);// The resolve function's optional third argument is a context value that\n// is provided to every resolve function within an execution. It is commonly\n// used to represent an authenticated user, or request-specific caches.\nvar contextValue=exeContext.contextValue;// Call the `subscribe()` resolver or the default resolver to produce an\n// AsyncIterable yielding raw payloads.\nvar resolveFn=(_fieldDef$subscribe=fieldDef.subscribe)!==null&&_fieldDef$subscribe!==void 0?_fieldDef$subscribe:exeContext.fieldResolver;resolveResult(resolveFn(rootValue,args,contextValue,info));}).then(function(eventStream){if(eventStream instanceof Error){throw locatedError(eventStream,fieldNodes,pathToArray(path));}// Assert field returned an event stream, otherwise yield an error.\nif(!isAsyncIterable(eventStream)){throw new Error('Subscription field must return Async Iterable. '+\"Received: \".concat(inspect(eventStream),\".\"));}return eventStream;},function(error){throw locatedError(error,fieldNodes,pathToArray(path));});}","map":{"version":3,"names":["inspect","isAsyncIterable","addPath","pathToArray","GraphQLError","locatedError","getArgumentValues","assertValidExecutionArguments","buildExecutionContext","buildResolveInfo","collectFields","execute","getFieldDef","getOperationRootType","mapAsyncIterator","subscribe","argsOrSchema","document","rootValue","contextValue","variableValues","operationName","fieldResolver","subscribeFieldResolver","arguments","length","subscribeImpl","schema","reportGraphQLError","error","errors","args","sourcePromise","createSourceEventStream","mapSourceToResponse","payload","then","resultOrStream","Promise","resolve","exeContext","Array","isArray","executeSubscription","catch","operation","type","fields","selectionSet","Object","create","responseNames","keys","responseName","fieldNodes","fieldNode","fieldName","name","value","fieldDef","concat","path","undefined","info","resolveResult","_fieldDef$subscribe","resolveFn","eventStream","Error"],"sources":["C:/Users/jarma/school/challenges/Project3_Final/client/src/node_modules/graphql/subscription/subscribe.mjs"],"sourcesContent":["import inspect from \"../jsutils/inspect.mjs\";\nimport isAsyncIterable from \"../jsutils/isAsyncIterable.mjs\";\nimport { addPath, pathToArray } from \"../jsutils/Path.mjs\";\nimport { GraphQLError } from \"../error/GraphQLError.mjs\";\nimport { locatedError } from \"../error/locatedError.mjs\";\nimport { getArgumentValues } from \"../execution/values.mjs\";\nimport { assertValidExecutionArguments, buildExecutionContext, buildResolveInfo, collectFields, execute, getFieldDef } from \"../execution/execute.mjs\";\nimport { getOperationRootType } from \"../utilities/getOperationRootType.mjs\";\nimport mapAsyncIterator from \"./mapAsyncIterator.mjs\";\nexport function subscribe(argsOrSchema, document, rootValue, contextValue, variableValues, operationName, fieldResolver, subscribeFieldResolver) {\n  /* eslint-enable no-redeclare */\n  // Extract arguments from object args if provided.\n  return arguments.length === 1 ? subscribeImpl(argsOrSchema) : subscribeImpl({\n    schema: argsOrSchema,\n    document: document,\n    rootValue: rootValue,\n    contextValue: contextValue,\n    variableValues: variableValues,\n    operationName: operationName,\n    fieldResolver: fieldResolver,\n    subscribeFieldResolver: subscribeFieldResolver\n  });\n}\n/**\n * This function checks if the error is a GraphQLError. If it is, report it as\n * an ExecutionResult, containing only errors and no data. Otherwise treat the\n * error as a system-class error and re-throw it.\n */\n\nfunction reportGraphQLError(error) {\n  if (error instanceof GraphQLError) {\n    return {\n      errors: [error]\n    };\n  }\n\n  throw error;\n}\n\nfunction subscribeImpl(args) {\n  var schema = args.schema,\n      document = args.document,\n      rootValue = args.rootValue,\n      contextValue = args.contextValue,\n      variableValues = args.variableValues,\n      operationName = args.operationName,\n      fieldResolver = args.fieldResolver,\n      subscribeFieldResolver = args.subscribeFieldResolver;\n  var sourcePromise = createSourceEventStream(schema, document, rootValue, contextValue, variableValues, operationName, subscribeFieldResolver); // For each payload yielded from a subscription, map it over the normal\n  // GraphQL `execute` function, with `payload` as the rootValue.\n  // This implements the \"MapSourceToResponseEvent\" algorithm described in\n  // the GraphQL specification. The `execute` function provides the\n  // \"ExecuteSubscriptionEvent\" algorithm, as it is nearly identical to the\n  // \"ExecuteQuery\" algorithm, for which `execute` is also used.\n\n  var mapSourceToResponse = function mapSourceToResponse(payload) {\n    return execute({\n      schema: schema,\n      document: document,\n      rootValue: payload,\n      contextValue: contextValue,\n      variableValues: variableValues,\n      operationName: operationName,\n      fieldResolver: fieldResolver\n    });\n  }; // Resolve the Source Stream, then map every source value to a\n  // ExecutionResult value as described above.\n\n\n  return sourcePromise.then(function (resultOrStream) {\n    return (// Note: Flow can't refine isAsyncIterable, so explicit casts are used.\n      isAsyncIterable(resultOrStream) ? mapAsyncIterator(resultOrStream, mapSourceToResponse, reportGraphQLError) : resultOrStream\n    );\n  });\n}\n/**\n * Implements the \"CreateSourceEventStream\" algorithm described in the\n * GraphQL specification, resolving the subscription source event stream.\n *\n * Returns a Promise which resolves to either an AsyncIterable (if successful)\n * or an ExecutionResult (error). The promise will be rejected if the schema or\n * other arguments to this function are invalid, or if the resolved event stream\n * is not an async iterable.\n *\n * If the client-provided arguments to this function do not result in a\n * compliant subscription, a GraphQL Response (ExecutionResult) with\n * descriptive errors and no data will be returned.\n *\n * If the the source stream could not be created due to faulty subscription\n * resolver logic or underlying systems, the promise will resolve to a single\n * ExecutionResult containing `errors` and no `data`.\n *\n * If the operation succeeded, the promise resolves to the AsyncIterable for the\n * event stream returned by the resolver.\n *\n * A Source Event Stream represents a sequence of events, each of which triggers\n * a GraphQL execution for that event.\n *\n * This may be useful when hosting the stateful subscription service in a\n * different process or machine than the stateless GraphQL execution engine,\n * or otherwise separating these two steps. For more on this, see the\n * \"Supporting Subscriptions at Scale\" information in the GraphQL specification.\n */\n\n\nexport function createSourceEventStream(schema, document, rootValue, contextValue, variableValues, operationName, fieldResolver) {\n  // If arguments are missing or incorrectly typed, this is an internal\n  // developer mistake which should throw an early error.\n  assertValidExecutionArguments(schema, document, variableValues);\n  return new Promise(function (resolve) {\n    // If a valid context cannot be created due to incorrect arguments,\n    // this will throw an error.\n    var exeContext = buildExecutionContext(schema, document, rootValue, contextValue, variableValues, operationName, fieldResolver);\n    resolve( // Return early errors if execution context failed.\n    Array.isArray(exeContext) ? {\n      errors: exeContext\n    } : executeSubscription(exeContext));\n  }).catch(reportGraphQLError);\n}\n\nfunction executeSubscription(exeContext) {\n  var schema = exeContext.schema,\n      operation = exeContext.operation,\n      variableValues = exeContext.variableValues,\n      rootValue = exeContext.rootValue;\n  var type = getOperationRootType(schema, operation);\n  var fields = collectFields(exeContext, type, operation.selectionSet, Object.create(null), Object.create(null));\n  var responseNames = Object.keys(fields);\n  var responseName = responseNames[0];\n  var fieldNodes = fields[responseName];\n  var fieldNode = fieldNodes[0];\n  var fieldName = fieldNode.name.value;\n  var fieldDef = getFieldDef(schema, type, fieldName);\n\n  if (!fieldDef) {\n    throw new GraphQLError(\"The subscription field \\\"\".concat(fieldName, \"\\\" is not defined.\"), fieldNodes);\n  }\n\n  var path = addPath(undefined, responseName, type.name);\n  var info = buildResolveInfo(exeContext, fieldDef, fieldNodes, type, path); // Coerce to Promise for easier error handling and consistent return type.\n\n  return new Promise(function (resolveResult) {\n    var _fieldDef$subscribe;\n\n    // Implements the \"ResolveFieldEventStream\" algorithm from GraphQL specification.\n    // It differs from \"ResolveFieldValue\" due to providing a different `resolveFn`.\n    // Build a JS object of arguments from the field.arguments AST, using the\n    // variables scope to fulfill any variable references.\n    var args = getArgumentValues(fieldDef, fieldNodes[0], variableValues); // The resolve function's optional third argument is a context value that\n    // is provided to every resolve function within an execution. It is commonly\n    // used to represent an authenticated user, or request-specific caches.\n\n    var contextValue = exeContext.contextValue; // Call the `subscribe()` resolver or the default resolver to produce an\n    // AsyncIterable yielding raw payloads.\n\n    var resolveFn = (_fieldDef$subscribe = fieldDef.subscribe) !== null && _fieldDef$subscribe !== void 0 ? _fieldDef$subscribe : exeContext.fieldResolver;\n    resolveResult(resolveFn(rootValue, args, contextValue, info));\n  }).then(function (eventStream) {\n    if (eventStream instanceof Error) {\n      throw locatedError(eventStream, fieldNodes, pathToArray(path));\n    } // Assert field returned an event stream, otherwise yield an error.\n\n\n    if (!isAsyncIterable(eventStream)) {\n      throw new Error('Subscription field must return Async Iterable. ' + \"Received: \".concat(inspect(eventStream), \".\"));\n    }\n\n    return eventStream;\n  }, function (error) {\n    throw locatedError(error, fieldNodes, pathToArray(path));\n  });\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}