{"ast":null,"code":"var _a=Object.prototype,toString=_a.toString,hasOwnProperty=_a.hasOwnProperty;var fnToStr=Function.prototype.toString;var previousComparisons=new Map();/**\n * Performs a deep equality check on two JavaScript values, tolerating cycles.\n */function equal(a,b){try{return check(a,b);}finally{previousComparisons.clear();}}function check(a,b){// If the two values are strictly equal, our job is easy.\nif(a===b){return true;}// Object.prototype.toString returns a representation of the runtime type of\n// the given value that is considerably more precise than typeof.\nvar aTag=toString.call(a);var bTag=toString.call(b);// If the runtime types of a and b are different, they could maybe be equal\n// under some interpretation of equality, but for simplicity and performance\n// we just return false instead.\nif(aTag!==bTag){return false;}switch(aTag){case'[object Array]':// Arrays are a lot like other objects, but we can cheaply compare their\n// lengths as a short-cut before comparing their elements.\nif(a.length!==b.length)return false;// Fall through to object case...\ncase'[object Object]':{if(previouslyCompared(a,b))return true;var aKeys=definedKeys(a);var bKeys=definedKeys(b);// If `a` and `b` have a different number of enumerable keys, they\n// must be different.\nvar keyCount=aKeys.length;if(keyCount!==bKeys.length)return false;// Now make sure they have the same keys.\nfor(var k=0;k<keyCount;++k){if(!hasOwnProperty.call(b,aKeys[k])){return false;}}// Finally, check deep equality of all child properties.\nfor(var k=0;k<keyCount;++k){var key=aKeys[k];if(!check(a[key],b[key])){return false;}}return true;}case'[object Error]':return a.name===b.name&&a.message===b.message;case'[object Number]':// Handle NaN, which is !== itself.\nif(a!==a)return b!==b;// Fall through to shared +a === +b case...\ncase'[object Boolean]':case'[object Date]':return+a===+b;case'[object RegExp]':case'[object String]':return a==\"\".concat(b);case'[object Map]':case'[object Set]':{if(a.size!==b.size)return false;if(previouslyCompared(a,b))return true;var aIterator=a.entries();var isMap=aTag==='[object Map]';while(true){var info=aIterator.next();if(info.done)break;// If a instanceof Set, aValue === aKey.\nvar _a=info.value,aKey=_a[0],aValue=_a[1];// So this works the same way for both Set and Map.\nif(!b.has(aKey)){return false;}// However, we care about deep equality of values only when dealing\n// with Map structures.\nif(isMap&&!check(aValue,b.get(aKey))){return false;}}return true;}case'[object Uint16Array]':case'[object Uint8Array]':// Buffer, in Node.js.\ncase'[object Uint32Array]':case'[object Int32Array]':case'[object Int8Array]':case'[object Int16Array]':case'[object ArrayBuffer]':// DataView doesn't need these conversions, but the equality check is\n// otherwise the same.\na=new Uint8Array(a);b=new Uint8Array(b);// Fall through...\ncase'[object DataView]':{var len=a.byteLength;if(len===b.byteLength){while(len--&&a[len]===b[len]){// Keep looping as long as the bytes are equal.\n}}return len===-1;}case'[object AsyncFunction]':case'[object GeneratorFunction]':case'[object AsyncGeneratorFunction]':case'[object Function]':{var aCode=fnToStr.call(a);if(aCode!==fnToStr.call(b)){return false;}// We consider non-native functions equal if they have the same code\n// (native functions require === because their code is censored).\n// Note that this behavior is not entirely sound, since !== function\n// objects with the same code can behave differently depending on\n// their closure scope. However, any function can behave differently\n// depending on the values of its input arguments (including this)\n// and its calling context (including its closure scope), even\n// though the function object is === to itself; and it is entirely\n// possible for functions that are not === to behave exactly the\n// same under all conceivable circumstances. Because none of these\n// factors are statically decidable in JavaScript, JS function\n// equality is not well-defined. This ambiguity allows us to\n// consider the best possible heuristic among various imperfect\n// options, and equating non-native functions that have the same\n// code has enormous practical benefits, such as when comparing\n// functions that are repeatedly passed as fresh function\n// expressions within objects that are otherwise deeply equal. Since\n// any function created from the same syntactic expression (in the\n// same code location) will always stringify to the same code\n// according to fnToStr.call, we can reasonably expect these\n// repeatedly passed function expressions to have the same code, and\n// thus behave \"the same\" (with all the caveats mentioned above),\n// even though the runtime function objects are !== to one another.\nreturn!endsWith(aCode,nativeCodeSuffix);}}// Otherwise the values are not equal.\nreturn false;}function definedKeys(obj){// Remember that the second argument to Array.prototype.filter will be\n// used as `this` within the callback function.\nreturn Object.keys(obj).filter(isDefinedKey,obj);}function isDefinedKey(key){return this[key]!==void 0;}var nativeCodeSuffix=\"{ [native code] }\";function endsWith(full,suffix){var fromIndex=full.length-suffix.length;return fromIndex>=0&&full.indexOf(suffix,fromIndex)===fromIndex;}function previouslyCompared(a,b){// Though cyclic references can make an object graph appear infinite from the\n// perspective of a depth-first traversal, the graph still contains a finite\n// number of distinct object references. We use the previousComparisons cache\n// to avoid comparing the same pair of object references more than once, which\n// guarantees termination (even if we end up comparing every object in one\n// graph to every object in the other graph, which is extremely unlikely),\n// while still allowing weird isomorphic structures (like rings with different\n// lengths) a chance to pass the equality test.\nvar bSet=previousComparisons.get(a);if(bSet){// Return true here because we can be sure false will be returned somewhere\n// else if the objects are not equivalent.\nif(bSet.has(b))return true;}else{previousComparisons.set(a,bSet=new Set());}bSet.add(b);return false;}export{equal as default,equal};","map":{"version":3,"mappings":"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","names":["Object","prototype","toString","hasOwnProperty","fnToStr","Function","previousComparisons","Map","a","b","check","clear","aTag","call","bTag","length","previouslyCompared","aKeys","definedKeys","bKeys","keyCount","k","key","name","message","concat","size","aIterator","entries","isMap","info","next","done","value","aKey","aValue","has","get","Uint8Array","len","byteLength","aCode","endsWith","nativeCodeSuffix","obj","keys","filter","isDefinedKey","full","suffix","fromIndex","indexOf","bSet","set","Set","add"],"sources":["../src/equality.ts"],"sourcesContent":["const { toString, hasOwnProperty } = Object.prototype;\nconst fnToStr = Function.prototype.toString;\nconst previousComparisons = new Map<object, Set<object>>();\n\n/**\n * Performs a deep equality check on two JavaScript values, tolerating cycles.\n */\nexport function equal(a: any, b: any): boolean {\n  try {\n    return check(a, b);\n  } finally {\n    previousComparisons.clear();\n  }\n}\n\n// Allow default imports as well.\nexport default equal;\n\nfunction check(a: any, b: any): boolean {\n  // If the two values are strictly equal, our job is easy.\n  if (a === b) {\n    return true;\n  }\n\n  // Object.prototype.toString returns a representation of the runtime type of\n  // the given value that is considerably more precise than typeof.\n  const aTag = toString.call(a);\n  const bTag = toString.call(b);\n\n  // If the runtime types of a and b are different, they could maybe be equal\n  // under some interpretation of equality, but for simplicity and performance\n  // we just return false instead.\n  if (aTag !== bTag) {\n    return false;\n  }\n\n  switch (aTag) {\n    case '[object Array]':\n      // Arrays are a lot like other objects, but we can cheaply compare their\n      // lengths as a short-cut before comparing their elements.\n      if (a.length !== b.length) return false;\n      // Fall through to object case...\n    case '[object Object]': {\n      if (previouslyCompared(a, b)) return true;\n\n      const aKeys = definedKeys(a);\n      const bKeys = definedKeys(b);\n\n      // If `a` and `b` have a different number of enumerable keys, they\n      // must be different.\n      const keyCount = aKeys.length;\n      if (keyCount !== bKeys.length) return false;\n\n      // Now make sure they have the same keys.\n      for (let k = 0; k < keyCount; ++k) {\n        if (!hasOwnProperty.call(b, aKeys[k])) {\n          return false;\n        }\n      }\n\n      // Finally, check deep equality of all child properties.\n      for (let k = 0; k < keyCount; ++k) {\n        const key = aKeys[k];\n        if (!check(a[key], b[key])) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n\n    case '[object Error]':\n      return a.name === b.name && a.message === b.message;\n\n    case '[object Number]':\n      // Handle NaN, which is !== itself.\n      if (a !== a) return b !== b;\n      // Fall through to shared +a === +b case...\n    case '[object Boolean]':\n    case '[object Date]':\n      return +a === +b;\n\n    case '[object RegExp]':\n    case '[object String]':\n      return a == `${b}`;\n\n    case '[object Map]':\n    case '[object Set]': {\n      if (a.size !== b.size) return false;\n      if (previouslyCompared(a, b)) return true;\n\n      const aIterator = a.entries();\n      const isMap = aTag === '[object Map]';\n\n      while (true) {\n        const info = aIterator.next();\n        if (info.done) break;\n\n        // If a instanceof Set, aValue === aKey.\n        const [aKey, aValue] = info.value;\n\n        // So this works the same way for both Set and Map.\n        if (!b.has(aKey)) {\n          return false;\n        }\n\n        // However, we care about deep equality of values only when dealing\n        // with Map structures.\n        if (isMap && !check(aValue, b.get(aKey))) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n\n    case '[object Uint16Array]':\n    case '[object Uint8Array]': // Buffer, in Node.js.\n    case '[object Uint32Array]':\n    case '[object Int32Array]':\n    case '[object Int8Array]':\n    case '[object Int16Array]':\n    case '[object ArrayBuffer]':\n      // DataView doesn't need these conversions, but the equality check is\n      // otherwise the same.\n      a = new Uint8Array(a);\n      b = new Uint8Array(b);\n      // Fall through...\n    case '[object DataView]': {\n      let len = a.byteLength;\n      if (len === b.byteLength) {\n        while (len-- && a[len] === b[len]) {\n          // Keep looping as long as the bytes are equal.\n        }\n      }\n      return len === -1;\n    }\n\n    case '[object AsyncFunction]':\n    case '[object GeneratorFunction]':\n    case '[object AsyncGeneratorFunction]':\n    case '[object Function]': {\n      const aCode = fnToStr.call(a);\n      if (aCode !== fnToStr.call(b)) {\n        return false;\n      }\n\n      // We consider non-native functions equal if they have the same code\n      // (native functions require === because their code is censored).\n      // Note that this behavior is not entirely sound, since !== function\n      // objects with the same code can behave differently depending on\n      // their closure scope. However, any function can behave differently\n      // depending on the values of its input arguments (including this)\n      // and its calling context (including its closure scope), even\n      // though the function object is === to itself; and it is entirely\n      // possible for functions that are not === to behave exactly the\n      // same under all conceivable circumstances. Because none of these\n      // factors are statically decidable in JavaScript, JS function\n      // equality is not well-defined. This ambiguity allows us to\n      // consider the best possible heuristic among various imperfect\n      // options, and equating non-native functions that have the same\n      // code has enormous practical benefits, such as when comparing\n      // functions that are repeatedly passed as fresh function\n      // expressions within objects that are otherwise deeply equal. Since\n      // any function created from the same syntactic expression (in the\n      // same code location) will always stringify to the same code\n      // according to fnToStr.call, we can reasonably expect these\n      // repeatedly passed function expressions to have the same code, and\n      // thus behave \"the same\" (with all the caveats mentioned above),\n      // even though the runtime function objects are !== to one another.\n      return !endsWith(aCode, nativeCodeSuffix);\n    }\n  }\n\n  // Otherwise the values are not equal.\n  return false;\n}\n\nfunction definedKeys<TObject extends object>(obj: TObject) {\n  // Remember that the second argument to Array.prototype.filter will be\n  // used as `this` within the callback function.\n  return Object.keys(obj).filter(isDefinedKey, obj);\n}\nfunction isDefinedKey<TObject extends object>(\n  this: TObject,\n  key: keyof TObject,\n) {\n  return this[key] !== void 0;\n}\n\nconst nativeCodeSuffix = \"{ [native code] }\";\n\nfunction endsWith(full: string, suffix: string) {\n  const fromIndex = full.length - suffix.length;\n  return fromIndex >= 0 &&\n    full.indexOf(suffix, fromIndex) === fromIndex;\n}\n\nfunction previouslyCompared(a: object, b: object): boolean {\n  // Though cyclic references can make an object graph appear infinite from the\n  // perspective of a depth-first traversal, the graph still contains a finite\n  // number of distinct object references. We use the previousComparisons cache\n  // to avoid comparing the same pair of object references more than once, which\n  // guarantees termination (even if we end up comparing every object in one\n  // graph to every object in the other graph, which is extremely unlikely),\n  // while still allowing weird isomorphic structures (like rings with different\n  // lengths) a chance to pass the equality test.\n  let bSet = previousComparisons.get(a);\n  if (bSet) {\n    // Return true here because we can be sure false will be returned somewhere\n    // else if the objects are not equivalent.\n    if (bSet.has(b)) return true;\n  } else {\n    previousComparisons.set(a, bSet = new Set);\n  }\n  bSet.add(b);\n  return false;\n}\n"]},"metadata":{},"sourceType":"module"}