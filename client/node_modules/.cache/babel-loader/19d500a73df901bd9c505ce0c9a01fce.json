{"ast":null,"code":"// A [trie](https://en.wikipedia.org/wiki/Trie) data structure that holds\n// object keys weakly, yet can also hold non-object keys, unlike the\n// native `WeakMap`.\n// If no makeData function is supplied, the looked-up data will be an empty,\n// null-prototype Object.\nvar defaultMakeData=function defaultMakeData(){return Object.create(null);};// Useful for processing arguments objects as well as arrays.\nvar _a=Array.prototype,forEach=_a.forEach,slice=_a.slice;var Trie=/** @class */function(){function Trie(weakness,makeData){if(weakness===void 0){weakness=true;}if(makeData===void 0){makeData=defaultMakeData;}this.weakness=weakness;this.makeData=makeData;}Trie.prototype.lookup=function(){var array=[];for(var _i=0;_i<arguments.length;_i++){array[_i]=arguments[_i];}return this.lookupArray(array);};Trie.prototype.lookupArray=function(array){var node=this;forEach.call(array,function(key){return node=node.getChildTrie(key);});return node.data||(node.data=this.makeData(slice.call(array)));};Trie.prototype.getChildTrie=function(key){var map=this.weakness&&isObjRef(key)?this.weak||(this.weak=new WeakMap()):this.strong||(this.strong=new Map());var child=map.get(key);if(!child)map.set(key,child=new Trie(this.weakness,this.makeData));return child;};return Trie;}();function isObjRef(value){switch(typeof value){case\"object\":if(value===null)break;// Fall through to return true...\ncase\"function\":return true;}return false;}export{Trie};","map":{"version":3,"mappings":"AAAA;AACA;AACA;AAEA;AACA;AACA,GAAMA,gBAAe,CAAG,QAAlBA,gBAAkB,EAAM,cAAM,CAACC,MAAP,CAAc,IAAd,EAAmB,CAAjD,CAEA;AACM,OAAqBC,KAAK,CAACC,SAA3B,CAAEC,OAAO,WAAT,CAAWC,KAAK,SAAhB,CAEN,iCAQE,QACUC,KADV,CACUC,QADV,CAEUC,QAFV,CAE4D,CADlD,8BAAe,KAAf,CAAe,CACf,8BAAkD,gBAAlD,CAAkD,CADlD,KAAQD,QAAR,UACA,KAAQC,QAAR,UACN,CAEGF,sBAAP,WAA+B,GAAWG,SAAX,QAAWC,MAAXA,EAAW,kBAAXA,EAAW,IAAXD,KAAW,IAAX,CAAWE,aAAX,EAC7B,MAAO,MAAKC,WAAL,CAAiBH,KAAjB,CAAP,CACD,CAFM,CAIAH,IAAW,UAAX,CAAWM,WAAX,CAAP,SAAiDH,KAAjD,CAAyD,CACvD,GAAII,KAAI,CAAe,IAAvB,CACAT,OAAO,CAACU,IAAR,CAAaL,KAAb,CAAoB,aAAG,CAAI,WAAI,CAAGI,IAAI,CAACE,YAAL,CAAkBC,GAAlB,CAAP,CAA6B,CAAxD,EACA,MAAOH,KAAI,CAACI,IAAL,GAAcJ,IAAI,CAACI,IAAL,CAAY,KAAKT,QAAL,CAAcH,KAAK,CAACS,IAAN,CAAWL,KAAX,CAAd,CAA1B,CAAP,CACD,CAJM,CAMCH,IAAY,UAAZ,CAAYS,YAAZ,CAAR,SAAqBC,GAArB,CAA6B,CAC3B,GAAME,IAAG,CAAG,KAAKX,QAAL,EAAiBY,QAAQ,CAACH,GAAD,CAAzB,CACR,KAAKI,IAAL,GAAc,KAAKA,IAAL,CAAY,GAAIC,QAAJ,EAA1B,CADQ,CAER,KAAKC,MAAL,GAAgB,KAAKA,MAAL,CAAc,GAAIC,IAAJ,EAA9B,CAFJ,CAGA,GAAIC,MAAK,CAAGN,GAAG,CAACO,GAAJ,CAAQT,GAAR,CAAZ,CACA,GAAI,CAACQ,KAAL,CAAYN,GAAG,CAACQ,GAAJ,CAAQV,GAAR,CAAaQ,KAAK,CAAG,GAAIlB,KAAJ,CAAe,KAAKC,QAApB,CAA8B,KAAKC,QAAnC,CAArB,EACZ,MAAOgB,MAAP,CACD,CAPO,CAQV,MAAClB,KAAD,CAAC,CA/BD,GAiCA,QAASa,SAAT,CAAkBQ,KAAlB,CAA4B,CAC1B,OAAQ,MAAOA,MAAf,EACA,IAAK,QAAL,CACE,GAAIA,KAAK,GAAK,IAAd,CAAoB;AAEtB,IAAK,UAAL,CACE,MAAO,KAAP,CALF,CAOA,MAAO,MAAP,CACF","names":["defaultMakeData","create","Array","prototype","forEach","slice","Trie","weakness","makeData","array","_i","arguments","lookupArray","node","call","getChildTrie","key","data","map","isObjRef","weak","WeakMap","strong","Map","child","get","set","value"],"sources":["../src/trie.ts"],"sourcesContent":["// A [trie](https://en.wikipedia.org/wiki/Trie) data structure that holds\n// object keys weakly, yet can also hold non-object keys, unlike the\n// native `WeakMap`.\n\n// If no makeData function is supplied, the looked-up data will be an empty,\n// null-prototype Object.\nconst defaultMakeData = () => Object.create(null);\n\n// Useful for processing arguments objects as well as arrays.\nconst { forEach, slice } = Array.prototype;\n\nexport class Trie<Data> {\n  // Since a `WeakMap` cannot hold primitive values as keys, we need a\n  // backup `Map` instance to hold primitive keys. Both `this._weakMap`\n  // and `this._strongMap` are lazily initialized.\n  private weak?: WeakMap<any, Trie<Data>>;\n  private strong?: Map<any, Trie<Data>>;\n  private data?: Data;\n\n  constructor(\n    private weakness = true,\n    private makeData: (array: any[]) => Data = defaultMakeData,\n  ) {}\n\n  public lookup<T extends any[]>(...array: T): Data {\n    return this.lookupArray(array);\n  }\n\n  public lookupArray<T extends IArguments | any[]>(array: T): Data {\n    let node: Trie<Data> = this;\n    forEach.call(array, key => node = node.getChildTrie(key));\n    return node.data || (node.data = this.makeData(slice.call(array)));\n  }\n\n  private getChildTrie(key: any) {\n    const map = this.weakness && isObjRef(key)\n      ? this.weak || (this.weak = new WeakMap<any, Trie<Data>>())\n      : this.strong || (this.strong = new Map<any, Trie<Data>>());\n    let child = map.get(key);\n    if (!child) map.set(key, child = new Trie<Data>(this.weakness, this.makeData));\n    return child;\n  }\n}\n\nfunction isObjRef(value: any) {\n  switch (typeof value) {\n  case \"object\":\n    if (value === null) break;\n    // Fall through to return true...\n  case \"function\":\n    return true;\n  }\n  return false;\n}\n"]},"metadata":{},"sourceType":"module"}