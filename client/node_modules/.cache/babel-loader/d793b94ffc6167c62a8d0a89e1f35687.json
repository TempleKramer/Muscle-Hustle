{"ast":null,"code":"import{invariant}from\"../../utilities/globals/index.js\";export var DocumentType;(function(DocumentType){DocumentType[DocumentType[\"Query\"]=0]=\"Query\";DocumentType[DocumentType[\"Mutation\"]=1]=\"Mutation\";DocumentType[DocumentType[\"Subscription\"]=2]=\"Subscription\";})(DocumentType||(DocumentType={}));var cache=new Map();export function operationName(type){var name;switch(type){case DocumentType.Query:name='Query';break;case DocumentType.Mutation:name='Mutation';break;case DocumentType.Subscription:name='Subscription';break;}return name;}export function parser(document){var cached=cache.get(document);if(cached)return cached;var variables,type,name;__DEV__?invariant(!!document&&!!document.kind,\"Argument of \".concat(document,\" passed to parser was not a valid GraphQL \")+\"DocumentNode. You may need to use 'graphql-tag' or another method \"+\"to convert your operation into a document\"):invariant(!!document&&!!document.kind,32);var fragments=[];var queries=[];var mutations=[];var subscriptions=[];for(var _i=0,_a=document.definitions;_i<_a.length;_i++){var x=_a[_i];if(x.kind==='FragmentDefinition'){fragments.push(x);continue;}if(x.kind==='OperationDefinition'){switch(x.operation){case'query':queries.push(x);break;case'mutation':mutations.push(x);break;case'subscription':subscriptions.push(x);break;}}}__DEV__?invariant(!fragments.length||queries.length||mutations.length||subscriptions.length,\"Passing only a fragment to 'graphql' is not yet supported. \"+\"You must include a query, subscription or mutation as well\"):invariant(!fragments.length||queries.length||mutations.length||subscriptions.length,33);__DEV__?invariant(queries.length+mutations.length+subscriptions.length<=1,\"react-apollo only supports a query, subscription, or a mutation per HOC. \"+\"\".concat(document,\" had \").concat(queries.length,\" queries, \").concat(subscriptions.length,\" \")+\"subscriptions and \".concat(mutations.length,\" mutations. \")+\"You can use 'compose' to join multiple operation types to a component\"):invariant(queries.length+mutations.length+subscriptions.length<=1,34);type=queries.length?DocumentType.Query:DocumentType.Mutation;if(!queries.length&&!mutations.length)type=DocumentType.Subscription;var definitions=queries.length?queries:mutations.length?mutations:subscriptions;__DEV__?invariant(definitions.length===1,\"react-apollo only supports one definition per HOC. \".concat(document,\" had \")+\"\".concat(definitions.length,\" definitions. \")+\"You can use 'compose' to join multiple operation types to a component\"):invariant(definitions.length===1,35);var definition=definitions[0];variables=definition.variableDefinitions||[];if(definition.name&&definition.name.kind==='Name'){name=definition.name.value;}else{name='data';}var payload={name:name,type:type,variables:variables};cache.set(document,payload);return payload;}export function verifyDocumentType(document,type){var operation=parser(document);var requiredOperationName=operationName(type);var usedOperationName=operationName(operation.type);__DEV__?invariant(operation.type===type,\"Running a \".concat(requiredOperationName,\" requires a graphql \")+\"\".concat(requiredOperationName,\", but a \").concat(usedOperationName,\" was used instead.\")):invariant(operation.type===type,36);}","map":{"version":3,"mappings":"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","names":["invariant","DocumentType","cache","Map","operationName","type","name","Query","Mutation","Subscription","parser","document","cached","get","variables","__DEV__","concat","fragments","queries","mutations","subscriptions","definitions","_i","x","kind","push","operation","length","variableDefinitions","definition","payload","verifyDocumentType","requiredOperationName"],"sourceRoot":"","sources":["../../../src/react/parser/index.ts"],"sourcesContent":["import { invariant } from '../../utilities/globals';\n\nimport {\n  DocumentNode,\n  DefinitionNode,\n  VariableDefinitionNode,\n  OperationDefinitionNode\n} from 'graphql';\n\nexport enum DocumentType {\n  Query,\n  Mutation,\n  Subscription\n}\n\nexport interface IDocumentDefinition {\n  type: DocumentType;\n  name: string;\n  variables: ReadonlyArray<VariableDefinitionNode>;\n}\n\nconst cache = new Map();\n\nexport function operationName(type: DocumentType) {\n  let name;\n  switch (type) {\n    case DocumentType.Query:\n      name = 'Query';\n      break;\n    case DocumentType.Mutation:\n      name = 'Mutation';\n      break;\n    case DocumentType.Subscription:\n      name = 'Subscription';\n      break;\n  }\n  return name;\n}\n\n// This parser is mostly used to safety check incoming documents.\nexport function parser(document: DocumentNode): IDocumentDefinition {\n  const cached = cache.get(document);\n  if (cached) return cached;\n\n  let variables, type, name;\n\n  invariant(\n    !!document && !!document.kind,\n    `Argument of ${document} passed to parser was not a valid GraphQL ` +\n      `DocumentNode. You may need to use 'graphql-tag' or another method ` +\n      `to convert your operation into a document`\n  );\n\n  const fragments: DefinitionNode[] = []\n  const queries: DefinitionNode[] = []\n  const mutations: DefinitionNode[] = []\n  const subscriptions: DefinitionNode[] = []\n\n  for (const x of document.definitions) {\n    if (x.kind === 'FragmentDefinition') {\n      fragments.push(x);\n      continue\n    }\n\n    if (x.kind === 'OperationDefinition') {\n      switch (x.operation) {\n        case 'query':\n          queries.push(x);\n          break;\n        case 'mutation':\n          mutations.push(x);\n          break;\n        case 'subscription':\n          subscriptions.push(x);\n          break;\n      }\n    }\n  }\n\n  invariant(\n    !fragments.length ||\n      (queries.length || mutations.length || subscriptions.length),\n    `Passing only a fragment to 'graphql' is not yet supported. ` +\n      `You must include a query, subscription or mutation as well`\n  );\n\n  invariant(\n    queries.length + mutations.length + subscriptions.length <= 1,\n    `react-apollo only supports a query, subscription, or a mutation per HOC. ` +\n      `${document} had ${queries.length} queries, ${subscriptions.length} ` +\n      `subscriptions and ${mutations.length} mutations. ` +\n      `You can use 'compose' to join multiple operation types to a component`\n  );\n\n  type = queries.length ? DocumentType.Query : DocumentType.Mutation;\n  if (!queries.length && !mutations.length) type = DocumentType.Subscription;\n\n  const definitions = queries.length\n    ? queries\n    : mutations.length\n    ? mutations\n    : subscriptions;\n\n  invariant(\n    definitions.length === 1,\n    `react-apollo only supports one definition per HOC. ${document} had ` +\n      `${definitions.length} definitions. ` +\n      `You can use 'compose' to join multiple operation types to a component`\n  );\n\n  const definition = definitions[0] as OperationDefinitionNode;\n  variables = definition.variableDefinitions || [];\n\n  if (definition.name && definition.name.kind === 'Name') {\n    name = definition.name.value;\n  } else {\n    name = 'data'; // fallback to using data if no name\n  }\n\n  const payload = { name, type, variables };\n  cache.set(document, payload);\n  return payload;\n}\n\nexport function verifyDocumentType(document: DocumentNode, type: DocumentType) {\n  const operation = parser(document);\n  const requiredOperationName = operationName(type);\n  const usedOperationName = operationName(operation.type);\n  invariant(\n    operation.type === type,\n    `Running a ${requiredOperationName} requires a graphql ` +\n      `${requiredOperationName}, but a ${usedOperationName} was used instead.`\n  );\n}\n\n"]},"metadata":{},"sourceType":"module"}