{"ast":null,"code":"import{Observable}from'zen-observable-ts';import'symbol-observable';var prototype=Observable.prototype;var fakeObsSymbol='@@observable';if(!prototype[fakeObsSymbol]){prototype[fakeObsSymbol]=function(){return this;};}export{Observable};","map":{"version":3,"mappings":"AAAA,OACEA,UADF,KAKO,mBALP,CASA,MAAO,mBAAP,CAWQ,aAAS,CAAKA,UAAU,UAAxB,CACR,GAAMC,cAAa,CAAG,cAAtB,CACA,GAAI,CAACC,SAAS,CAACD,aAAD,CAAd,CAA+B,CAC7BC,SAAS,CAACD,aAAD,CAAT,CAA2B,WAAc,MAAO,KAAP,CAAc,CAAvD,CACD,CAED,OAASD,UAAT","names":["Observable","fakeObsSymbol","prototype"],"sourceRoot":"","sources":["../../../src/utilities/observables/Observable.ts"],"sourcesContent":["import {\n  Observable,\n  Observer,\n  Subscription as ObservableSubscription,\n  Subscriber,\n} from 'zen-observable-ts';\n\n// This simplified polyfill attempts to follow the ECMAScript Observable\n// proposal (https://github.com/zenparsing/es-observable)\nimport 'symbol-observable';\n\nexport type {\n  Observer,\n  ObservableSubscription,\n  Subscriber,\n};\n\n// The zen-observable package defines Observable.prototype[Symbol.observable]\n// when Symbol is supported, but RxJS interop depends on also setting this fake\n// '@@observable' string as a polyfill for Symbol.observable.\nconst { prototype } = Observable;\nconst fakeObsSymbol = '@@observable' as keyof typeof prototype;\nif (!prototype[fakeObsSymbol]) {\n  prototype[fakeObsSymbol] = function () { return this; };\n}\n\nexport { Observable };\n"]},"metadata":{},"sourceType":"module"}