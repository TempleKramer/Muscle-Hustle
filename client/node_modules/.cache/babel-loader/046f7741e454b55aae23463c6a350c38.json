{"ast":null,"code":"import{syntaxError}from\"../error/syntaxError.mjs\";import{Kind}from\"./kinds.mjs\";import{Location}from\"./ast.mjs\";import{TokenKind}from\"./tokenKind.mjs\";import{Source,isSource}from\"./source.mjs\";import{DirectiveLocation}from\"./directiveLocation.mjs\";import{Lexer,isPunctuatorTokenKind}from\"./lexer.mjs\";/**\n * Configuration options to control parser behavior\n */ /**\n * Given a GraphQL source, parses it into a Document.\n * Throws GraphQLError if a syntax error is encountered.\n */export function parse(source,options){var parser=new Parser(source,options);return parser.parseDocument();}/**\n * Given a string containing a GraphQL value (ex. `[42]`), parse the AST for\n * that value.\n * Throws GraphQLError if a syntax error is encountered.\n *\n * This is useful within tools that operate upon GraphQL Values directly and\n * in isolation of complete GraphQL documents.\n *\n * Consider providing the results to the utility function: valueFromAST().\n */export function parseValue(source,options){var parser=new Parser(source,options);parser.expectToken(TokenKind.SOF);var value=parser.parseValueLiteral(false);parser.expectToken(TokenKind.EOF);return value;}/**\n * Given a string containing a GraphQL Type (ex. `[Int!]`), parse the AST for\n * that type.\n * Throws GraphQLError if a syntax error is encountered.\n *\n * This is useful within tools that operate upon GraphQL Types directly and\n * in isolation of complete GraphQL documents.\n *\n * Consider providing the results to the utility function: typeFromAST().\n */export function parseType(source,options){var parser=new Parser(source,options);parser.expectToken(TokenKind.SOF);var type=parser.parseTypeReference();parser.expectToken(TokenKind.EOF);return type;}/**\n * This class is exported only to assist people in implementing their own parsers\n * without duplicating too much code and should be used only as last resort for cases\n * such as experimental syntax or if certain features could not be contributed upstream.\n *\n * It is still part of the internal API and is versioned, so any changes to it are never\n * considered breaking changes. If you still need to support multiple versions of the\n * library, please use the `versionInfo` variable for version detection.\n *\n * @internal\n */export var Parser=/*#__PURE__*/function(){function Parser(source,options){var sourceObj=isSource(source)?source:new Source(source);this._lexer=new Lexer(sourceObj);this._options=options;}/**\n   * Converts a name lex token into a name parse node.\n   */var _proto=Parser.prototype;_proto.parseName=function parseName(){var token=this.expectToken(TokenKind.NAME);return{kind:Kind.NAME,value:token.value,loc:this.loc(token)};}// Implements the parsing rules in the Document section.\n/**\n   * Document : Definition+\n   */;_proto.parseDocument=function parseDocument(){var start=this._lexer.token;return{kind:Kind.DOCUMENT,definitions:this.many(TokenKind.SOF,this.parseDefinition,TokenKind.EOF),loc:this.loc(start)};}/**\n   * Definition :\n   *   - ExecutableDefinition\n   *   - TypeSystemDefinition\n   *   - TypeSystemExtension\n   *\n   * ExecutableDefinition :\n   *   - OperationDefinition\n   *   - FragmentDefinition\n   */;_proto.parseDefinition=function parseDefinition(){if(this.peek(TokenKind.NAME)){switch(this._lexer.token.value){case'query':case'mutation':case'subscription':return this.parseOperationDefinition();case'fragment':return this.parseFragmentDefinition();case'schema':case'scalar':case'type':case'interface':case'union':case'enum':case'input':case'directive':return this.parseTypeSystemDefinition();case'extend':return this.parseTypeSystemExtension();}}else if(this.peek(TokenKind.BRACE_L)){return this.parseOperationDefinition();}else if(this.peekDescription()){return this.parseTypeSystemDefinition();}throw this.unexpected();}// Implements the parsing rules in the Operations section.\n/**\n   * OperationDefinition :\n   *  - SelectionSet\n   *  - OperationType Name? VariableDefinitions? Directives? SelectionSet\n   */;_proto.parseOperationDefinition=function parseOperationDefinition(){var start=this._lexer.token;if(this.peek(TokenKind.BRACE_L)){return{kind:Kind.OPERATION_DEFINITION,operation:'query',name:undefined,variableDefinitions:[],directives:[],selectionSet:this.parseSelectionSet(),loc:this.loc(start)};}var operation=this.parseOperationType();var name;if(this.peek(TokenKind.NAME)){name=this.parseName();}return{kind:Kind.OPERATION_DEFINITION,operation:operation,name:name,variableDefinitions:this.parseVariableDefinitions(),directives:this.parseDirectives(false),selectionSet:this.parseSelectionSet(),loc:this.loc(start)};}/**\n   * OperationType : one of query mutation subscription\n   */;_proto.parseOperationType=function parseOperationType(){var operationToken=this.expectToken(TokenKind.NAME);switch(operationToken.value){case'query':return'query';case'mutation':return'mutation';case'subscription':return'subscription';}throw this.unexpected(operationToken);}/**\n   * VariableDefinitions : ( VariableDefinition+ )\n   */;_proto.parseVariableDefinitions=function parseVariableDefinitions(){return this.optionalMany(TokenKind.PAREN_L,this.parseVariableDefinition,TokenKind.PAREN_R);}/**\n   * VariableDefinition : Variable : Type DefaultValue? Directives[Const]?\n   */;_proto.parseVariableDefinition=function parseVariableDefinition(){var start=this._lexer.token;return{kind:Kind.VARIABLE_DEFINITION,variable:this.parseVariable(),type:(this.expectToken(TokenKind.COLON),this.parseTypeReference()),defaultValue:this.expectOptionalToken(TokenKind.EQUALS)?this.parseValueLiteral(true):undefined,directives:this.parseDirectives(true),loc:this.loc(start)};}/**\n   * Variable : $ Name\n   */;_proto.parseVariable=function parseVariable(){var start=this._lexer.token;this.expectToken(TokenKind.DOLLAR);return{kind:Kind.VARIABLE,name:this.parseName(),loc:this.loc(start)};}/**\n   * SelectionSet : { Selection+ }\n   */;_proto.parseSelectionSet=function parseSelectionSet(){var start=this._lexer.token;return{kind:Kind.SELECTION_SET,selections:this.many(TokenKind.BRACE_L,this.parseSelection,TokenKind.BRACE_R),loc:this.loc(start)};}/**\n   * Selection :\n   *   - Field\n   *   - FragmentSpread\n   *   - InlineFragment\n   */;_proto.parseSelection=function parseSelection(){return this.peek(TokenKind.SPREAD)?this.parseFragment():this.parseField();}/**\n   * Field : Alias? Name Arguments? Directives? SelectionSet?\n   *\n   * Alias : Name :\n   */;_proto.parseField=function parseField(){var start=this._lexer.token;var nameOrAlias=this.parseName();var alias;var name;if(this.expectOptionalToken(TokenKind.COLON)){alias=nameOrAlias;name=this.parseName();}else{name=nameOrAlias;}return{kind:Kind.FIELD,alias:alias,name:name,arguments:this.parseArguments(false),directives:this.parseDirectives(false),selectionSet:this.peek(TokenKind.BRACE_L)?this.parseSelectionSet():undefined,loc:this.loc(start)};}/**\n   * Arguments[Const] : ( Argument[?Const]+ )\n   */;_proto.parseArguments=function parseArguments(isConst){var item=isConst?this.parseConstArgument:this.parseArgument;return this.optionalMany(TokenKind.PAREN_L,item,TokenKind.PAREN_R);}/**\n   * Argument[Const] : Name : Value[?Const]\n   */;_proto.parseArgument=function parseArgument(){var start=this._lexer.token;var name=this.parseName();this.expectToken(TokenKind.COLON);return{kind:Kind.ARGUMENT,name:name,value:this.parseValueLiteral(false),loc:this.loc(start)};};_proto.parseConstArgument=function parseConstArgument(){var start=this._lexer.token;return{kind:Kind.ARGUMENT,name:this.parseName(),value:(this.expectToken(TokenKind.COLON),this.parseValueLiteral(true)),loc:this.loc(start)};}// Implements the parsing rules in the Fragments section.\n/**\n   * Corresponds to both FragmentSpread and InlineFragment in the spec.\n   *\n   * FragmentSpread : ... FragmentName Directives?\n   *\n   * InlineFragment : ... TypeCondition? Directives? SelectionSet\n   */;_proto.parseFragment=function parseFragment(){var start=this._lexer.token;this.expectToken(TokenKind.SPREAD);var hasTypeCondition=this.expectOptionalKeyword('on');if(!hasTypeCondition&&this.peek(TokenKind.NAME)){return{kind:Kind.FRAGMENT_SPREAD,name:this.parseFragmentName(),directives:this.parseDirectives(false),loc:this.loc(start)};}return{kind:Kind.INLINE_FRAGMENT,typeCondition:hasTypeCondition?this.parseNamedType():undefined,directives:this.parseDirectives(false),selectionSet:this.parseSelectionSet(),loc:this.loc(start)};}/**\n   * FragmentDefinition :\n   *   - fragment FragmentName on TypeCondition Directives? SelectionSet\n   *\n   * TypeCondition : NamedType\n   */;_proto.parseFragmentDefinition=function parseFragmentDefinition(){var _this$_options;var start=this._lexer.token;this.expectKeyword('fragment');// Experimental support for defining variables within fragments changes\n// the grammar of FragmentDefinition:\n//   - fragment FragmentName VariableDefinitions? on TypeCondition Directives? SelectionSet\nif(((_this$_options=this._options)===null||_this$_options===void 0?void 0:_this$_options.experimentalFragmentVariables)===true){return{kind:Kind.FRAGMENT_DEFINITION,name:this.parseFragmentName(),variableDefinitions:this.parseVariableDefinitions(),typeCondition:(this.expectKeyword('on'),this.parseNamedType()),directives:this.parseDirectives(false),selectionSet:this.parseSelectionSet(),loc:this.loc(start)};}return{kind:Kind.FRAGMENT_DEFINITION,name:this.parseFragmentName(),typeCondition:(this.expectKeyword('on'),this.parseNamedType()),directives:this.parseDirectives(false),selectionSet:this.parseSelectionSet(),loc:this.loc(start)};}/**\n   * FragmentName : Name but not `on`\n   */;_proto.parseFragmentName=function parseFragmentName(){if(this._lexer.token.value==='on'){throw this.unexpected();}return this.parseName();}// Implements the parsing rules in the Values section.\n/**\n   * Value[Const] :\n   *   - [~Const] Variable\n   *   - IntValue\n   *   - FloatValue\n   *   - StringValue\n   *   - BooleanValue\n   *   - NullValue\n   *   - EnumValue\n   *   - ListValue[?Const]\n   *   - ObjectValue[?Const]\n   *\n   * BooleanValue : one of `true` `false`\n   *\n   * NullValue : `null`\n   *\n   * EnumValue : Name but not `true`, `false` or `null`\n   */;_proto.parseValueLiteral=function parseValueLiteral(isConst){var token=this._lexer.token;switch(token.kind){case TokenKind.BRACKET_L:return this.parseList(isConst);case TokenKind.BRACE_L:return this.parseObject(isConst);case TokenKind.INT:this._lexer.advance();return{kind:Kind.INT,value:token.value,loc:this.loc(token)};case TokenKind.FLOAT:this._lexer.advance();return{kind:Kind.FLOAT,value:token.value,loc:this.loc(token)};case TokenKind.STRING:case TokenKind.BLOCK_STRING:return this.parseStringLiteral();case TokenKind.NAME:this._lexer.advance();switch(token.value){case'true':return{kind:Kind.BOOLEAN,value:true,loc:this.loc(token)};case'false':return{kind:Kind.BOOLEAN,value:false,loc:this.loc(token)};case'null':return{kind:Kind.NULL,loc:this.loc(token)};default:return{kind:Kind.ENUM,value:token.value,loc:this.loc(token)};}case TokenKind.DOLLAR:if(!isConst){return this.parseVariable();}break;}throw this.unexpected();};_proto.parseStringLiteral=function parseStringLiteral(){var token=this._lexer.token;this._lexer.advance();return{kind:Kind.STRING,value:token.value,block:token.kind===TokenKind.BLOCK_STRING,loc:this.loc(token)};}/**\n   * ListValue[Const] :\n   *   - [ ]\n   *   - [ Value[?Const]+ ]\n   */;_proto.parseList=function parseList(isConst){var _this=this;var start=this._lexer.token;var item=function item(){return _this.parseValueLiteral(isConst);};return{kind:Kind.LIST,values:this.any(TokenKind.BRACKET_L,item,TokenKind.BRACKET_R),loc:this.loc(start)};}/**\n   * ObjectValue[Const] :\n   *   - { }\n   *   - { ObjectField[?Const]+ }\n   */;_proto.parseObject=function parseObject(isConst){var _this2=this;var start=this._lexer.token;var item=function item(){return _this2.parseObjectField(isConst);};return{kind:Kind.OBJECT,fields:this.any(TokenKind.BRACE_L,item,TokenKind.BRACE_R),loc:this.loc(start)};}/**\n   * ObjectField[Const] : Name : Value[?Const]\n   */;_proto.parseObjectField=function parseObjectField(isConst){var start=this._lexer.token;var name=this.parseName();this.expectToken(TokenKind.COLON);return{kind:Kind.OBJECT_FIELD,name:name,value:this.parseValueLiteral(isConst),loc:this.loc(start)};}// Implements the parsing rules in the Directives section.\n/**\n   * Directives[Const] : Directive[?Const]+\n   */;_proto.parseDirectives=function parseDirectives(isConst){var directives=[];while(this.peek(TokenKind.AT)){directives.push(this.parseDirective(isConst));}return directives;}/**\n   * Directive[Const] : @ Name Arguments[?Const]?\n   */;_proto.parseDirective=function parseDirective(isConst){var start=this._lexer.token;this.expectToken(TokenKind.AT);return{kind:Kind.DIRECTIVE,name:this.parseName(),arguments:this.parseArguments(isConst),loc:this.loc(start)};}// Implements the parsing rules in the Types section.\n/**\n   * Type :\n   *   - NamedType\n   *   - ListType\n   *   - NonNullType\n   */;_proto.parseTypeReference=function parseTypeReference(){var start=this._lexer.token;var type;if(this.expectOptionalToken(TokenKind.BRACKET_L)){type=this.parseTypeReference();this.expectToken(TokenKind.BRACKET_R);type={kind:Kind.LIST_TYPE,type:type,loc:this.loc(start)};}else{type=this.parseNamedType();}if(this.expectOptionalToken(TokenKind.BANG)){return{kind:Kind.NON_NULL_TYPE,type:type,loc:this.loc(start)};}return type;}/**\n   * NamedType : Name\n   */;_proto.parseNamedType=function parseNamedType(){var start=this._lexer.token;return{kind:Kind.NAMED_TYPE,name:this.parseName(),loc:this.loc(start)};}// Implements the parsing rules in the Type Definition section.\n/**\n   * TypeSystemDefinition :\n   *   - SchemaDefinition\n   *   - TypeDefinition\n   *   - DirectiveDefinition\n   *\n   * TypeDefinition :\n   *   - ScalarTypeDefinition\n   *   - ObjectTypeDefinition\n   *   - InterfaceTypeDefinition\n   *   - UnionTypeDefinition\n   *   - EnumTypeDefinition\n   *   - InputObjectTypeDefinition\n   */;_proto.parseTypeSystemDefinition=function parseTypeSystemDefinition(){// Many definitions begin with a description and require a lookahead.\nvar keywordToken=this.peekDescription()?this._lexer.lookahead():this._lexer.token;if(keywordToken.kind===TokenKind.NAME){switch(keywordToken.value){case'schema':return this.parseSchemaDefinition();case'scalar':return this.parseScalarTypeDefinition();case'type':return this.parseObjectTypeDefinition();case'interface':return this.parseInterfaceTypeDefinition();case'union':return this.parseUnionTypeDefinition();case'enum':return this.parseEnumTypeDefinition();case'input':return this.parseInputObjectTypeDefinition();case'directive':return this.parseDirectiveDefinition();}}throw this.unexpected(keywordToken);};_proto.peekDescription=function peekDescription(){return this.peek(TokenKind.STRING)||this.peek(TokenKind.BLOCK_STRING);}/**\n   * Description : StringValue\n   */;_proto.parseDescription=function parseDescription(){if(this.peekDescription()){return this.parseStringLiteral();}}/**\n   * SchemaDefinition : Description? schema Directives[Const]? { OperationTypeDefinition+ }\n   */;_proto.parseSchemaDefinition=function parseSchemaDefinition(){var start=this._lexer.token;var description=this.parseDescription();this.expectKeyword('schema');var directives=this.parseDirectives(true);var operationTypes=this.many(TokenKind.BRACE_L,this.parseOperationTypeDefinition,TokenKind.BRACE_R);return{kind:Kind.SCHEMA_DEFINITION,description:description,directives:directives,operationTypes:operationTypes,loc:this.loc(start)};}/**\n   * OperationTypeDefinition : OperationType : NamedType\n   */;_proto.parseOperationTypeDefinition=function parseOperationTypeDefinition(){var start=this._lexer.token;var operation=this.parseOperationType();this.expectToken(TokenKind.COLON);var type=this.parseNamedType();return{kind:Kind.OPERATION_TYPE_DEFINITION,operation:operation,type:type,loc:this.loc(start)};}/**\n   * ScalarTypeDefinition : Description? scalar Name Directives[Const]?\n   */;_proto.parseScalarTypeDefinition=function parseScalarTypeDefinition(){var start=this._lexer.token;var description=this.parseDescription();this.expectKeyword('scalar');var name=this.parseName();var directives=this.parseDirectives(true);return{kind:Kind.SCALAR_TYPE_DEFINITION,description:description,name:name,directives:directives,loc:this.loc(start)};}/**\n   * ObjectTypeDefinition :\n   *   Description?\n   *   type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition?\n   */;_proto.parseObjectTypeDefinition=function parseObjectTypeDefinition(){var start=this._lexer.token;var description=this.parseDescription();this.expectKeyword('type');var name=this.parseName();var interfaces=this.parseImplementsInterfaces();var directives=this.parseDirectives(true);var fields=this.parseFieldsDefinition();return{kind:Kind.OBJECT_TYPE_DEFINITION,description:description,name:name,interfaces:interfaces,directives:directives,fields:fields,loc:this.loc(start)};}/**\n   * ImplementsInterfaces :\n   *   - implements `&`? NamedType\n   *   - ImplementsInterfaces & NamedType\n   */;_proto.parseImplementsInterfaces=function parseImplementsInterfaces(){var _this$_options2;if(!this.expectOptionalKeyword('implements')){return[];}if(((_this$_options2=this._options)===null||_this$_options2===void 0?void 0:_this$_options2.allowLegacySDLImplementsInterfaces)===true){var types=[];// Optional leading ampersand\nthis.expectOptionalToken(TokenKind.AMP);do{types.push(this.parseNamedType());}while(this.expectOptionalToken(TokenKind.AMP)||this.peek(TokenKind.NAME));return types;}return this.delimitedMany(TokenKind.AMP,this.parseNamedType);}/**\n   * FieldsDefinition : { FieldDefinition+ }\n   */;_proto.parseFieldsDefinition=function parseFieldsDefinition(){var _this$_options3;// Legacy support for the SDL?\nif(((_this$_options3=this._options)===null||_this$_options3===void 0?void 0:_this$_options3.allowLegacySDLEmptyFields)===true&&this.peek(TokenKind.BRACE_L)&&this._lexer.lookahead().kind===TokenKind.BRACE_R){this._lexer.advance();this._lexer.advance();return[];}return this.optionalMany(TokenKind.BRACE_L,this.parseFieldDefinition,TokenKind.BRACE_R);}/**\n   * FieldDefinition :\n   *   - Description? Name ArgumentsDefinition? : Type Directives[Const]?\n   */;_proto.parseFieldDefinition=function parseFieldDefinition(){var start=this._lexer.token;var description=this.parseDescription();var name=this.parseName();var args=this.parseArgumentDefs();this.expectToken(TokenKind.COLON);var type=this.parseTypeReference();var directives=this.parseDirectives(true);return{kind:Kind.FIELD_DEFINITION,description:description,name:name,arguments:args,type:type,directives:directives,loc:this.loc(start)};}/**\n   * ArgumentsDefinition : ( InputValueDefinition+ )\n   */;_proto.parseArgumentDefs=function parseArgumentDefs(){return this.optionalMany(TokenKind.PAREN_L,this.parseInputValueDef,TokenKind.PAREN_R);}/**\n   * InputValueDefinition :\n   *   - Description? Name : Type DefaultValue? Directives[Const]?\n   */;_proto.parseInputValueDef=function parseInputValueDef(){var start=this._lexer.token;var description=this.parseDescription();var name=this.parseName();this.expectToken(TokenKind.COLON);var type=this.parseTypeReference();var defaultValue;if(this.expectOptionalToken(TokenKind.EQUALS)){defaultValue=this.parseValueLiteral(true);}var directives=this.parseDirectives(true);return{kind:Kind.INPUT_VALUE_DEFINITION,description:description,name:name,type:type,defaultValue:defaultValue,directives:directives,loc:this.loc(start)};}/**\n   * InterfaceTypeDefinition :\n   *   - Description? interface Name Directives[Const]? FieldsDefinition?\n   */;_proto.parseInterfaceTypeDefinition=function parseInterfaceTypeDefinition(){var start=this._lexer.token;var description=this.parseDescription();this.expectKeyword('interface');var name=this.parseName();var interfaces=this.parseImplementsInterfaces();var directives=this.parseDirectives(true);var fields=this.parseFieldsDefinition();return{kind:Kind.INTERFACE_TYPE_DEFINITION,description:description,name:name,interfaces:interfaces,directives:directives,fields:fields,loc:this.loc(start)};}/**\n   * UnionTypeDefinition :\n   *   - Description? union Name Directives[Const]? UnionMemberTypes?\n   */;_proto.parseUnionTypeDefinition=function parseUnionTypeDefinition(){var start=this._lexer.token;var description=this.parseDescription();this.expectKeyword('union');var name=this.parseName();var directives=this.parseDirectives(true);var types=this.parseUnionMemberTypes();return{kind:Kind.UNION_TYPE_DEFINITION,description:description,name:name,directives:directives,types:types,loc:this.loc(start)};}/**\n   * UnionMemberTypes :\n   *   - = `|`? NamedType\n   *   - UnionMemberTypes | NamedType\n   */;_proto.parseUnionMemberTypes=function parseUnionMemberTypes(){return this.expectOptionalToken(TokenKind.EQUALS)?this.delimitedMany(TokenKind.PIPE,this.parseNamedType):[];}/**\n   * EnumTypeDefinition :\n   *   - Description? enum Name Directives[Const]? EnumValuesDefinition?\n   */;_proto.parseEnumTypeDefinition=function parseEnumTypeDefinition(){var start=this._lexer.token;var description=this.parseDescription();this.expectKeyword('enum');var name=this.parseName();var directives=this.parseDirectives(true);var values=this.parseEnumValuesDefinition();return{kind:Kind.ENUM_TYPE_DEFINITION,description:description,name:name,directives:directives,values:values,loc:this.loc(start)};}/**\n   * EnumValuesDefinition : { EnumValueDefinition+ }\n   */;_proto.parseEnumValuesDefinition=function parseEnumValuesDefinition(){return this.optionalMany(TokenKind.BRACE_L,this.parseEnumValueDefinition,TokenKind.BRACE_R);}/**\n   * EnumValueDefinition : Description? EnumValue Directives[Const]?\n   *\n   * EnumValue : Name\n   */;_proto.parseEnumValueDefinition=function parseEnumValueDefinition(){var start=this._lexer.token;var description=this.parseDescription();var name=this.parseName();var directives=this.parseDirectives(true);return{kind:Kind.ENUM_VALUE_DEFINITION,description:description,name:name,directives:directives,loc:this.loc(start)};}/**\n   * InputObjectTypeDefinition :\n   *   - Description? input Name Directives[Const]? InputFieldsDefinition?\n   */;_proto.parseInputObjectTypeDefinition=function parseInputObjectTypeDefinition(){var start=this._lexer.token;var description=this.parseDescription();this.expectKeyword('input');var name=this.parseName();var directives=this.parseDirectives(true);var fields=this.parseInputFieldsDefinition();return{kind:Kind.INPUT_OBJECT_TYPE_DEFINITION,description:description,name:name,directives:directives,fields:fields,loc:this.loc(start)};}/**\n   * InputFieldsDefinition : { InputValueDefinition+ }\n   */;_proto.parseInputFieldsDefinition=function parseInputFieldsDefinition(){return this.optionalMany(TokenKind.BRACE_L,this.parseInputValueDef,TokenKind.BRACE_R);}/**\n   * TypeSystemExtension :\n   *   - SchemaExtension\n   *   - TypeExtension\n   *\n   * TypeExtension :\n   *   - ScalarTypeExtension\n   *   - ObjectTypeExtension\n   *   - InterfaceTypeExtension\n   *   - UnionTypeExtension\n   *   - EnumTypeExtension\n   *   - InputObjectTypeDefinition\n   */;_proto.parseTypeSystemExtension=function parseTypeSystemExtension(){var keywordToken=this._lexer.lookahead();if(keywordToken.kind===TokenKind.NAME){switch(keywordToken.value){case'schema':return this.parseSchemaExtension();case'scalar':return this.parseScalarTypeExtension();case'type':return this.parseObjectTypeExtension();case'interface':return this.parseInterfaceTypeExtension();case'union':return this.parseUnionTypeExtension();case'enum':return this.parseEnumTypeExtension();case'input':return this.parseInputObjectTypeExtension();}}throw this.unexpected(keywordToken);}/**\n   * SchemaExtension :\n   *  - extend schema Directives[Const]? { OperationTypeDefinition+ }\n   *  - extend schema Directives[Const]\n   */;_proto.parseSchemaExtension=function parseSchemaExtension(){var start=this._lexer.token;this.expectKeyword('extend');this.expectKeyword('schema');var directives=this.parseDirectives(true);var operationTypes=this.optionalMany(TokenKind.BRACE_L,this.parseOperationTypeDefinition,TokenKind.BRACE_R);if(directives.length===0&&operationTypes.length===0){throw this.unexpected();}return{kind:Kind.SCHEMA_EXTENSION,directives:directives,operationTypes:operationTypes,loc:this.loc(start)};}/**\n   * ScalarTypeExtension :\n   *   - extend scalar Name Directives[Const]\n   */;_proto.parseScalarTypeExtension=function parseScalarTypeExtension(){var start=this._lexer.token;this.expectKeyword('extend');this.expectKeyword('scalar');var name=this.parseName();var directives=this.parseDirectives(true);if(directives.length===0){throw this.unexpected();}return{kind:Kind.SCALAR_TYPE_EXTENSION,name:name,directives:directives,loc:this.loc(start)};}/**\n   * ObjectTypeExtension :\n   *  - extend type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition\n   *  - extend type Name ImplementsInterfaces? Directives[Const]\n   *  - extend type Name ImplementsInterfaces\n   */;_proto.parseObjectTypeExtension=function parseObjectTypeExtension(){var start=this._lexer.token;this.expectKeyword('extend');this.expectKeyword('type');var name=this.parseName();var interfaces=this.parseImplementsInterfaces();var directives=this.parseDirectives(true);var fields=this.parseFieldsDefinition();if(interfaces.length===0&&directives.length===0&&fields.length===0){throw this.unexpected();}return{kind:Kind.OBJECT_TYPE_EXTENSION,name:name,interfaces:interfaces,directives:directives,fields:fields,loc:this.loc(start)};}/**\n   * InterfaceTypeExtension :\n   *  - extend interface Name ImplementsInterfaces? Directives[Const]? FieldsDefinition\n   *  - extend interface Name ImplementsInterfaces? Directives[Const]\n   *  - extend interface Name ImplementsInterfaces\n   */;_proto.parseInterfaceTypeExtension=function parseInterfaceTypeExtension(){var start=this._lexer.token;this.expectKeyword('extend');this.expectKeyword('interface');var name=this.parseName();var interfaces=this.parseImplementsInterfaces();var directives=this.parseDirectives(true);var fields=this.parseFieldsDefinition();if(interfaces.length===0&&directives.length===0&&fields.length===0){throw this.unexpected();}return{kind:Kind.INTERFACE_TYPE_EXTENSION,name:name,interfaces:interfaces,directives:directives,fields:fields,loc:this.loc(start)};}/**\n   * UnionTypeExtension :\n   *   - extend union Name Directives[Const]? UnionMemberTypes\n   *   - extend union Name Directives[Const]\n   */;_proto.parseUnionTypeExtension=function parseUnionTypeExtension(){var start=this._lexer.token;this.expectKeyword('extend');this.expectKeyword('union');var name=this.parseName();var directives=this.parseDirectives(true);var types=this.parseUnionMemberTypes();if(directives.length===0&&types.length===0){throw this.unexpected();}return{kind:Kind.UNION_TYPE_EXTENSION,name:name,directives:directives,types:types,loc:this.loc(start)};}/**\n   * EnumTypeExtension :\n   *   - extend enum Name Directives[Const]? EnumValuesDefinition\n   *   - extend enum Name Directives[Const]\n   */;_proto.parseEnumTypeExtension=function parseEnumTypeExtension(){var start=this._lexer.token;this.expectKeyword('extend');this.expectKeyword('enum');var name=this.parseName();var directives=this.parseDirectives(true);var values=this.parseEnumValuesDefinition();if(directives.length===0&&values.length===0){throw this.unexpected();}return{kind:Kind.ENUM_TYPE_EXTENSION,name:name,directives:directives,values:values,loc:this.loc(start)};}/**\n   * InputObjectTypeExtension :\n   *   - extend input Name Directives[Const]? InputFieldsDefinition\n   *   - extend input Name Directives[Const]\n   */;_proto.parseInputObjectTypeExtension=function parseInputObjectTypeExtension(){var start=this._lexer.token;this.expectKeyword('extend');this.expectKeyword('input');var name=this.parseName();var directives=this.parseDirectives(true);var fields=this.parseInputFieldsDefinition();if(directives.length===0&&fields.length===0){throw this.unexpected();}return{kind:Kind.INPUT_OBJECT_TYPE_EXTENSION,name:name,directives:directives,fields:fields,loc:this.loc(start)};}/**\n   * DirectiveDefinition :\n   *   - Description? directive @ Name ArgumentsDefinition? `repeatable`? on DirectiveLocations\n   */;_proto.parseDirectiveDefinition=function parseDirectiveDefinition(){var start=this._lexer.token;var description=this.parseDescription();this.expectKeyword('directive');this.expectToken(TokenKind.AT);var name=this.parseName();var args=this.parseArgumentDefs();var repeatable=this.expectOptionalKeyword('repeatable');this.expectKeyword('on');var locations=this.parseDirectiveLocations();return{kind:Kind.DIRECTIVE_DEFINITION,description:description,name:name,arguments:args,repeatable:repeatable,locations:locations,loc:this.loc(start)};}/**\n   * DirectiveLocations :\n   *   - `|`? DirectiveLocation\n   *   - DirectiveLocations | DirectiveLocation\n   */;_proto.parseDirectiveLocations=function parseDirectiveLocations(){return this.delimitedMany(TokenKind.PIPE,this.parseDirectiveLocation);}/*\n   * DirectiveLocation :\n   *   - ExecutableDirectiveLocation\n   *   - TypeSystemDirectiveLocation\n   *\n   * ExecutableDirectiveLocation : one of\n   *   `QUERY`\n   *   `MUTATION`\n   *   `SUBSCRIPTION`\n   *   `FIELD`\n   *   `FRAGMENT_DEFINITION`\n   *   `FRAGMENT_SPREAD`\n   *   `INLINE_FRAGMENT`\n   *\n   * TypeSystemDirectiveLocation : one of\n   *   `SCHEMA`\n   *   `SCALAR`\n   *   `OBJECT`\n   *   `FIELD_DEFINITION`\n   *   `ARGUMENT_DEFINITION`\n   *   `INTERFACE`\n   *   `UNION`\n   *   `ENUM`\n   *   `ENUM_VALUE`\n   *   `INPUT_OBJECT`\n   *   `INPUT_FIELD_DEFINITION`\n   */;_proto.parseDirectiveLocation=function parseDirectiveLocation(){var start=this._lexer.token;var name=this.parseName();if(DirectiveLocation[name.value]!==undefined){return name;}throw this.unexpected(start);}// Core parsing utility functions\n/**\n   * Returns a location object, used to identify the place in the source that created a given parsed object.\n   */;_proto.loc=function loc(startToken){var _this$_options4;if(((_this$_options4=this._options)===null||_this$_options4===void 0?void 0:_this$_options4.noLocation)!==true){return new Location(startToken,this._lexer.lastToken,this._lexer.source);}}/**\n   * Determines if the next token is of a given kind\n   */;_proto.peek=function peek(kind){return this._lexer.token.kind===kind;}/**\n   * If the next token is of the given kind, return that token after advancing the lexer.\n   * Otherwise, do not change the parser state and throw an error.\n   */;_proto.expectToken=function expectToken(kind){var token=this._lexer.token;if(token.kind===kind){this._lexer.advance();return token;}throw syntaxError(this._lexer.source,token.start,\"Expected \".concat(getTokenKindDesc(kind),\", found \").concat(getTokenDesc(token),\".\"));}/**\n   * If the next token is of the given kind, return that token after advancing the lexer.\n   * Otherwise, do not change the parser state and return undefined.\n   */;_proto.expectOptionalToken=function expectOptionalToken(kind){var token=this._lexer.token;if(token.kind===kind){this._lexer.advance();return token;}return undefined;}/**\n   * If the next token is a given keyword, advance the lexer.\n   * Otherwise, do not change the parser state and throw an error.\n   */;_proto.expectKeyword=function expectKeyword(value){var token=this._lexer.token;if(token.kind===TokenKind.NAME&&token.value===value){this._lexer.advance();}else{throw syntaxError(this._lexer.source,token.start,\"Expected \\\"\".concat(value,\"\\\", found \").concat(getTokenDesc(token),\".\"));}}/**\n   * If the next token is a given keyword, return \"true\" after advancing the lexer.\n   * Otherwise, do not change the parser state and return \"false\".\n   */;_proto.expectOptionalKeyword=function expectOptionalKeyword(value){var token=this._lexer.token;if(token.kind===TokenKind.NAME&&token.value===value){this._lexer.advance();return true;}return false;}/**\n   * Helper function for creating an error when an unexpected lexed token is encountered.\n   */;_proto.unexpected=function unexpected(atToken){var token=atToken!==null&&atToken!==void 0?atToken:this._lexer.token;return syntaxError(this._lexer.source,token.start,\"Unexpected \".concat(getTokenDesc(token),\".\"));}/**\n   * Returns a possibly empty list of parse nodes, determined by the parseFn.\n   * This list begins with a lex token of openKind and ends with a lex token of closeKind.\n   * Advances the parser to the next lex token after the closing token.\n   */;_proto.any=function any(openKind,parseFn,closeKind){this.expectToken(openKind);var nodes=[];while(!this.expectOptionalToken(closeKind)){nodes.push(parseFn.call(this));}return nodes;}/**\n   * Returns a list of parse nodes, determined by the parseFn.\n   * It can be empty only if open token is missing otherwise it will always return non-empty list\n   * that begins with a lex token of openKind and ends with a lex token of closeKind.\n   * Advances the parser to the next lex token after the closing token.\n   */;_proto.optionalMany=function optionalMany(openKind,parseFn,closeKind){if(this.expectOptionalToken(openKind)){var nodes=[];do{nodes.push(parseFn.call(this));}while(!this.expectOptionalToken(closeKind));return nodes;}return[];}/**\n   * Returns a non-empty list of parse nodes, determined by the parseFn.\n   * This list begins with a lex token of openKind and ends with a lex token of closeKind.\n   * Advances the parser to the next lex token after the closing token.\n   */;_proto.many=function many(openKind,parseFn,closeKind){this.expectToken(openKind);var nodes=[];do{nodes.push(parseFn.call(this));}while(!this.expectOptionalToken(closeKind));return nodes;}/**\n   * Returns a non-empty list of parse nodes, determined by the parseFn.\n   * This list may begin with a lex token of delimiterKind followed by items separated by lex tokens of tokenKind.\n   * Advances the parser to the next lex token after last item in the list.\n   */;_proto.delimitedMany=function delimitedMany(delimiterKind,parseFn){this.expectOptionalToken(delimiterKind);var nodes=[];do{nodes.push(parseFn.call(this));}while(this.expectOptionalToken(delimiterKind));return nodes;};return Parser;}();/**\n * A helper function to describe a token as a string for debugging.\n */function getTokenDesc(token){var value=token.value;return getTokenKindDesc(token.kind)+(value!=null?\" \\\"\".concat(value,\"\\\"\"):'');}/**\n * A helper function to describe a token kind as a string for debugging.\n */function getTokenKindDesc(kind){return isPunctuatorTokenKind(kind)?\"\\\"\".concat(kind,\"\\\"\"):kind;}","map":{"version":3,"names":["syntaxError","Kind","Location","TokenKind","Source","isSource","DirectiveLocation","Lexer","isPunctuatorTokenKind","parse","source","options","parser","Parser","parseDocument","parseValue","expectToken","SOF","value","parseValueLiteral","EOF","parseType","type","parseTypeReference","sourceObj","_lexer","_options","_proto","prototype","parseName","token","NAME","kind","loc","start","DOCUMENT","definitions","many","parseDefinition","peek","parseOperationDefinition","parseFragmentDefinition","parseTypeSystemDefinition","parseTypeSystemExtension","BRACE_L","peekDescription","unexpected","OPERATION_DEFINITION","operation","name","undefined","variableDefinitions","directives","selectionSet","parseSelectionSet","parseOperationType","parseVariableDefinitions","parseDirectives","operationToken","optionalMany","PAREN_L","parseVariableDefinition","PAREN_R","VARIABLE_DEFINITION","variable","parseVariable","COLON","defaultValue","expectOptionalToken","EQUALS","DOLLAR","VARIABLE","SELECTION_SET","selections","parseSelection","BRACE_R","SPREAD","parseFragment","parseField","nameOrAlias","alias","FIELD","arguments","parseArguments","isConst","item","parseConstArgument","parseArgument","ARGUMENT","hasTypeCondition","expectOptionalKeyword","FRAGMENT_SPREAD","parseFragmentName","INLINE_FRAGMENT","typeCondition","parseNamedType","_this$_options","expectKeyword","experimentalFragmentVariables","FRAGMENT_DEFINITION","BRACKET_L","parseList","parseObject","INT","advance","FLOAT","STRING","BLOCK_STRING","parseStringLiteral","BOOLEAN","NULL","ENUM","block","_this","LIST","values","any","BRACKET_R","_this2","parseObjectField","OBJECT","fields","OBJECT_FIELD","AT","push","parseDirective","DIRECTIVE","LIST_TYPE","BANG","NON_NULL_TYPE","NAMED_TYPE","keywordToken","lookahead","parseSchemaDefinition","parseScalarTypeDefinition","parseObjectTypeDefinition","parseInterfaceTypeDefinition","parseUnionTypeDefinition","parseEnumTypeDefinition","parseInputObjectTypeDefinition","parseDirectiveDefinition","parseDescription","description","operationTypes","parseOperationTypeDefinition","SCHEMA_DEFINITION","OPERATION_TYPE_DEFINITION","SCALAR_TYPE_DEFINITION","interfaces","parseImplementsInterfaces","parseFieldsDefinition","OBJECT_TYPE_DEFINITION","_this$_options2","allowLegacySDLImplementsInterfaces","types","AMP","delimitedMany","_this$_options3","allowLegacySDLEmptyFields","parseFieldDefinition","args","parseArgumentDefs","FIELD_DEFINITION","parseInputValueDef","INPUT_VALUE_DEFINITION","INTERFACE_TYPE_DEFINITION","parseUnionMemberTypes","UNION_TYPE_DEFINITION","PIPE","parseEnumValuesDefinition","ENUM_TYPE_DEFINITION","parseEnumValueDefinition","ENUM_VALUE_DEFINITION","parseInputFieldsDefinition","INPUT_OBJECT_TYPE_DEFINITION","parseSchemaExtension","parseScalarTypeExtension","parseObjectTypeExtension","parseInterfaceTypeExtension","parseUnionTypeExtension","parseEnumTypeExtension","parseInputObjectTypeExtension","length","SCHEMA_EXTENSION","SCALAR_TYPE_EXTENSION","OBJECT_TYPE_EXTENSION","INTERFACE_TYPE_EXTENSION","UNION_TYPE_EXTENSION","ENUM_TYPE_EXTENSION","INPUT_OBJECT_TYPE_EXTENSION","repeatable","locations","parseDirectiveLocations","DIRECTIVE_DEFINITION","parseDirectiveLocation","startToken","_this$_options4","noLocation","lastToken","concat","getTokenKindDesc","getTokenDesc","atToken","openKind","parseFn","closeKind","nodes","call","delimiterKind"],"sources":["C:/Users/jarma/school/challenges/Project3_Final/client/src/node_modules/graphql/language/parser.mjs"],"sourcesContent":["import { syntaxError } from \"../error/syntaxError.mjs\";\nimport { Kind } from \"./kinds.mjs\";\nimport { Location } from \"./ast.mjs\";\nimport { TokenKind } from \"./tokenKind.mjs\";\nimport { Source, isSource } from \"./source.mjs\";\nimport { DirectiveLocation } from \"./directiveLocation.mjs\";\nimport { Lexer, isPunctuatorTokenKind } from \"./lexer.mjs\";\n/**\n * Configuration options to control parser behavior\n */\n\n/**\n * Given a GraphQL source, parses it into a Document.\n * Throws GraphQLError if a syntax error is encountered.\n */\nexport function parse(source, options) {\n  var parser = new Parser(source, options);\n  return parser.parseDocument();\n}\n/**\n * Given a string containing a GraphQL value (ex. `[42]`), parse the AST for\n * that value.\n * Throws GraphQLError if a syntax error is encountered.\n *\n * This is useful within tools that operate upon GraphQL Values directly and\n * in isolation of complete GraphQL documents.\n *\n * Consider providing the results to the utility function: valueFromAST().\n */\n\nexport function parseValue(source, options) {\n  var parser = new Parser(source, options);\n  parser.expectToken(TokenKind.SOF);\n  var value = parser.parseValueLiteral(false);\n  parser.expectToken(TokenKind.EOF);\n  return value;\n}\n/**\n * Given a string containing a GraphQL Type (ex. `[Int!]`), parse the AST for\n * that type.\n * Throws GraphQLError if a syntax error is encountered.\n *\n * This is useful within tools that operate upon GraphQL Types directly and\n * in isolation of complete GraphQL documents.\n *\n * Consider providing the results to the utility function: typeFromAST().\n */\n\nexport function parseType(source, options) {\n  var parser = new Parser(source, options);\n  parser.expectToken(TokenKind.SOF);\n  var type = parser.parseTypeReference();\n  parser.expectToken(TokenKind.EOF);\n  return type;\n}\n/**\n * This class is exported only to assist people in implementing their own parsers\n * without duplicating too much code and should be used only as last resort for cases\n * such as experimental syntax or if certain features could not be contributed upstream.\n *\n * It is still part of the internal API and is versioned, so any changes to it are never\n * considered breaking changes. If you still need to support multiple versions of the\n * library, please use the `versionInfo` variable for version detection.\n *\n * @internal\n */\n\nexport var Parser = /*#__PURE__*/function () {\n  function Parser(source, options) {\n    var sourceObj = isSource(source) ? source : new Source(source);\n    this._lexer = new Lexer(sourceObj);\n    this._options = options;\n  }\n  /**\n   * Converts a name lex token into a name parse node.\n   */\n\n\n  var _proto = Parser.prototype;\n\n  _proto.parseName = function parseName() {\n    var token = this.expectToken(TokenKind.NAME);\n    return {\n      kind: Kind.NAME,\n      value: token.value,\n      loc: this.loc(token)\n    };\n  } // Implements the parsing rules in the Document section.\n\n  /**\n   * Document : Definition+\n   */\n  ;\n\n  _proto.parseDocument = function parseDocument() {\n    var start = this._lexer.token;\n    return {\n      kind: Kind.DOCUMENT,\n      definitions: this.many(TokenKind.SOF, this.parseDefinition, TokenKind.EOF),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * Definition :\n   *   - ExecutableDefinition\n   *   - TypeSystemDefinition\n   *   - TypeSystemExtension\n   *\n   * ExecutableDefinition :\n   *   - OperationDefinition\n   *   - FragmentDefinition\n   */\n  ;\n\n  _proto.parseDefinition = function parseDefinition() {\n    if (this.peek(TokenKind.NAME)) {\n      switch (this._lexer.token.value) {\n        case 'query':\n        case 'mutation':\n        case 'subscription':\n          return this.parseOperationDefinition();\n\n        case 'fragment':\n          return this.parseFragmentDefinition();\n\n        case 'schema':\n        case 'scalar':\n        case 'type':\n        case 'interface':\n        case 'union':\n        case 'enum':\n        case 'input':\n        case 'directive':\n          return this.parseTypeSystemDefinition();\n\n        case 'extend':\n          return this.parseTypeSystemExtension();\n      }\n    } else if (this.peek(TokenKind.BRACE_L)) {\n      return this.parseOperationDefinition();\n    } else if (this.peekDescription()) {\n      return this.parseTypeSystemDefinition();\n    }\n\n    throw this.unexpected();\n  } // Implements the parsing rules in the Operations section.\n\n  /**\n   * OperationDefinition :\n   *  - SelectionSet\n   *  - OperationType Name? VariableDefinitions? Directives? SelectionSet\n   */\n  ;\n\n  _proto.parseOperationDefinition = function parseOperationDefinition() {\n    var start = this._lexer.token;\n\n    if (this.peek(TokenKind.BRACE_L)) {\n      return {\n        kind: Kind.OPERATION_DEFINITION,\n        operation: 'query',\n        name: undefined,\n        variableDefinitions: [],\n        directives: [],\n        selectionSet: this.parseSelectionSet(),\n        loc: this.loc(start)\n      };\n    }\n\n    var operation = this.parseOperationType();\n    var name;\n\n    if (this.peek(TokenKind.NAME)) {\n      name = this.parseName();\n    }\n\n    return {\n      kind: Kind.OPERATION_DEFINITION,\n      operation: operation,\n      name: name,\n      variableDefinitions: this.parseVariableDefinitions(),\n      directives: this.parseDirectives(false),\n      selectionSet: this.parseSelectionSet(),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * OperationType : one of query mutation subscription\n   */\n  ;\n\n  _proto.parseOperationType = function parseOperationType() {\n    var operationToken = this.expectToken(TokenKind.NAME);\n\n    switch (operationToken.value) {\n      case 'query':\n        return 'query';\n\n      case 'mutation':\n        return 'mutation';\n\n      case 'subscription':\n        return 'subscription';\n    }\n\n    throw this.unexpected(operationToken);\n  }\n  /**\n   * VariableDefinitions : ( VariableDefinition+ )\n   */\n  ;\n\n  _proto.parseVariableDefinitions = function parseVariableDefinitions() {\n    return this.optionalMany(TokenKind.PAREN_L, this.parseVariableDefinition, TokenKind.PAREN_R);\n  }\n  /**\n   * VariableDefinition : Variable : Type DefaultValue? Directives[Const]?\n   */\n  ;\n\n  _proto.parseVariableDefinition = function parseVariableDefinition() {\n    var start = this._lexer.token;\n    return {\n      kind: Kind.VARIABLE_DEFINITION,\n      variable: this.parseVariable(),\n      type: (this.expectToken(TokenKind.COLON), this.parseTypeReference()),\n      defaultValue: this.expectOptionalToken(TokenKind.EQUALS) ? this.parseValueLiteral(true) : undefined,\n      directives: this.parseDirectives(true),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * Variable : $ Name\n   */\n  ;\n\n  _proto.parseVariable = function parseVariable() {\n    var start = this._lexer.token;\n    this.expectToken(TokenKind.DOLLAR);\n    return {\n      kind: Kind.VARIABLE,\n      name: this.parseName(),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * SelectionSet : { Selection+ }\n   */\n  ;\n\n  _proto.parseSelectionSet = function parseSelectionSet() {\n    var start = this._lexer.token;\n    return {\n      kind: Kind.SELECTION_SET,\n      selections: this.many(TokenKind.BRACE_L, this.parseSelection, TokenKind.BRACE_R),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * Selection :\n   *   - Field\n   *   - FragmentSpread\n   *   - InlineFragment\n   */\n  ;\n\n  _proto.parseSelection = function parseSelection() {\n    return this.peek(TokenKind.SPREAD) ? this.parseFragment() : this.parseField();\n  }\n  /**\n   * Field : Alias? Name Arguments? Directives? SelectionSet?\n   *\n   * Alias : Name :\n   */\n  ;\n\n  _proto.parseField = function parseField() {\n    var start = this._lexer.token;\n    var nameOrAlias = this.parseName();\n    var alias;\n    var name;\n\n    if (this.expectOptionalToken(TokenKind.COLON)) {\n      alias = nameOrAlias;\n      name = this.parseName();\n    } else {\n      name = nameOrAlias;\n    }\n\n    return {\n      kind: Kind.FIELD,\n      alias: alias,\n      name: name,\n      arguments: this.parseArguments(false),\n      directives: this.parseDirectives(false),\n      selectionSet: this.peek(TokenKind.BRACE_L) ? this.parseSelectionSet() : undefined,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * Arguments[Const] : ( Argument[?Const]+ )\n   */\n  ;\n\n  _proto.parseArguments = function parseArguments(isConst) {\n    var item = isConst ? this.parseConstArgument : this.parseArgument;\n    return this.optionalMany(TokenKind.PAREN_L, item, TokenKind.PAREN_R);\n  }\n  /**\n   * Argument[Const] : Name : Value[?Const]\n   */\n  ;\n\n  _proto.parseArgument = function parseArgument() {\n    var start = this._lexer.token;\n    var name = this.parseName();\n    this.expectToken(TokenKind.COLON);\n    return {\n      kind: Kind.ARGUMENT,\n      name: name,\n      value: this.parseValueLiteral(false),\n      loc: this.loc(start)\n    };\n  };\n\n  _proto.parseConstArgument = function parseConstArgument() {\n    var start = this._lexer.token;\n    return {\n      kind: Kind.ARGUMENT,\n      name: this.parseName(),\n      value: (this.expectToken(TokenKind.COLON), this.parseValueLiteral(true)),\n      loc: this.loc(start)\n    };\n  } // Implements the parsing rules in the Fragments section.\n\n  /**\n   * Corresponds to both FragmentSpread and InlineFragment in the spec.\n   *\n   * FragmentSpread : ... FragmentName Directives?\n   *\n   * InlineFragment : ... TypeCondition? Directives? SelectionSet\n   */\n  ;\n\n  _proto.parseFragment = function parseFragment() {\n    var start = this._lexer.token;\n    this.expectToken(TokenKind.SPREAD);\n    var hasTypeCondition = this.expectOptionalKeyword('on');\n\n    if (!hasTypeCondition && this.peek(TokenKind.NAME)) {\n      return {\n        kind: Kind.FRAGMENT_SPREAD,\n        name: this.parseFragmentName(),\n        directives: this.parseDirectives(false),\n        loc: this.loc(start)\n      };\n    }\n\n    return {\n      kind: Kind.INLINE_FRAGMENT,\n      typeCondition: hasTypeCondition ? this.parseNamedType() : undefined,\n      directives: this.parseDirectives(false),\n      selectionSet: this.parseSelectionSet(),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * FragmentDefinition :\n   *   - fragment FragmentName on TypeCondition Directives? SelectionSet\n   *\n   * TypeCondition : NamedType\n   */\n  ;\n\n  _proto.parseFragmentDefinition = function parseFragmentDefinition() {\n    var _this$_options;\n\n    var start = this._lexer.token;\n    this.expectKeyword('fragment'); // Experimental support for defining variables within fragments changes\n    // the grammar of FragmentDefinition:\n    //   - fragment FragmentName VariableDefinitions? on TypeCondition Directives? SelectionSet\n\n    if (((_this$_options = this._options) === null || _this$_options === void 0 ? void 0 : _this$_options.experimentalFragmentVariables) === true) {\n      return {\n        kind: Kind.FRAGMENT_DEFINITION,\n        name: this.parseFragmentName(),\n        variableDefinitions: this.parseVariableDefinitions(),\n        typeCondition: (this.expectKeyword('on'), this.parseNamedType()),\n        directives: this.parseDirectives(false),\n        selectionSet: this.parseSelectionSet(),\n        loc: this.loc(start)\n      };\n    }\n\n    return {\n      kind: Kind.FRAGMENT_DEFINITION,\n      name: this.parseFragmentName(),\n      typeCondition: (this.expectKeyword('on'), this.parseNamedType()),\n      directives: this.parseDirectives(false),\n      selectionSet: this.parseSelectionSet(),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * FragmentName : Name but not `on`\n   */\n  ;\n\n  _proto.parseFragmentName = function parseFragmentName() {\n    if (this._lexer.token.value === 'on') {\n      throw this.unexpected();\n    }\n\n    return this.parseName();\n  } // Implements the parsing rules in the Values section.\n\n  /**\n   * Value[Const] :\n   *   - [~Const] Variable\n   *   - IntValue\n   *   - FloatValue\n   *   - StringValue\n   *   - BooleanValue\n   *   - NullValue\n   *   - EnumValue\n   *   - ListValue[?Const]\n   *   - ObjectValue[?Const]\n   *\n   * BooleanValue : one of `true` `false`\n   *\n   * NullValue : `null`\n   *\n   * EnumValue : Name but not `true`, `false` or `null`\n   */\n  ;\n\n  _proto.parseValueLiteral = function parseValueLiteral(isConst) {\n    var token = this._lexer.token;\n\n    switch (token.kind) {\n      case TokenKind.BRACKET_L:\n        return this.parseList(isConst);\n\n      case TokenKind.BRACE_L:\n        return this.parseObject(isConst);\n\n      case TokenKind.INT:\n        this._lexer.advance();\n\n        return {\n          kind: Kind.INT,\n          value: token.value,\n          loc: this.loc(token)\n        };\n\n      case TokenKind.FLOAT:\n        this._lexer.advance();\n\n        return {\n          kind: Kind.FLOAT,\n          value: token.value,\n          loc: this.loc(token)\n        };\n\n      case TokenKind.STRING:\n      case TokenKind.BLOCK_STRING:\n        return this.parseStringLiteral();\n\n      case TokenKind.NAME:\n        this._lexer.advance();\n\n        switch (token.value) {\n          case 'true':\n            return {\n              kind: Kind.BOOLEAN,\n              value: true,\n              loc: this.loc(token)\n            };\n\n          case 'false':\n            return {\n              kind: Kind.BOOLEAN,\n              value: false,\n              loc: this.loc(token)\n            };\n\n          case 'null':\n            return {\n              kind: Kind.NULL,\n              loc: this.loc(token)\n            };\n\n          default:\n            return {\n              kind: Kind.ENUM,\n              value: token.value,\n              loc: this.loc(token)\n            };\n        }\n\n      case TokenKind.DOLLAR:\n        if (!isConst) {\n          return this.parseVariable();\n        }\n\n        break;\n    }\n\n    throw this.unexpected();\n  };\n\n  _proto.parseStringLiteral = function parseStringLiteral() {\n    var token = this._lexer.token;\n\n    this._lexer.advance();\n\n    return {\n      kind: Kind.STRING,\n      value: token.value,\n      block: token.kind === TokenKind.BLOCK_STRING,\n      loc: this.loc(token)\n    };\n  }\n  /**\n   * ListValue[Const] :\n   *   - [ ]\n   *   - [ Value[?Const]+ ]\n   */\n  ;\n\n  _proto.parseList = function parseList(isConst) {\n    var _this = this;\n\n    var start = this._lexer.token;\n\n    var item = function item() {\n      return _this.parseValueLiteral(isConst);\n    };\n\n    return {\n      kind: Kind.LIST,\n      values: this.any(TokenKind.BRACKET_L, item, TokenKind.BRACKET_R),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * ObjectValue[Const] :\n   *   - { }\n   *   - { ObjectField[?Const]+ }\n   */\n  ;\n\n  _proto.parseObject = function parseObject(isConst) {\n    var _this2 = this;\n\n    var start = this._lexer.token;\n\n    var item = function item() {\n      return _this2.parseObjectField(isConst);\n    };\n\n    return {\n      kind: Kind.OBJECT,\n      fields: this.any(TokenKind.BRACE_L, item, TokenKind.BRACE_R),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * ObjectField[Const] : Name : Value[?Const]\n   */\n  ;\n\n  _proto.parseObjectField = function parseObjectField(isConst) {\n    var start = this._lexer.token;\n    var name = this.parseName();\n    this.expectToken(TokenKind.COLON);\n    return {\n      kind: Kind.OBJECT_FIELD,\n      name: name,\n      value: this.parseValueLiteral(isConst),\n      loc: this.loc(start)\n    };\n  } // Implements the parsing rules in the Directives section.\n\n  /**\n   * Directives[Const] : Directive[?Const]+\n   */\n  ;\n\n  _proto.parseDirectives = function parseDirectives(isConst) {\n    var directives = [];\n\n    while (this.peek(TokenKind.AT)) {\n      directives.push(this.parseDirective(isConst));\n    }\n\n    return directives;\n  }\n  /**\n   * Directive[Const] : @ Name Arguments[?Const]?\n   */\n  ;\n\n  _proto.parseDirective = function parseDirective(isConst) {\n    var start = this._lexer.token;\n    this.expectToken(TokenKind.AT);\n    return {\n      kind: Kind.DIRECTIVE,\n      name: this.parseName(),\n      arguments: this.parseArguments(isConst),\n      loc: this.loc(start)\n    };\n  } // Implements the parsing rules in the Types section.\n\n  /**\n   * Type :\n   *   - NamedType\n   *   - ListType\n   *   - NonNullType\n   */\n  ;\n\n  _proto.parseTypeReference = function parseTypeReference() {\n    var start = this._lexer.token;\n    var type;\n\n    if (this.expectOptionalToken(TokenKind.BRACKET_L)) {\n      type = this.parseTypeReference();\n      this.expectToken(TokenKind.BRACKET_R);\n      type = {\n        kind: Kind.LIST_TYPE,\n        type: type,\n        loc: this.loc(start)\n      };\n    } else {\n      type = this.parseNamedType();\n    }\n\n    if (this.expectOptionalToken(TokenKind.BANG)) {\n      return {\n        kind: Kind.NON_NULL_TYPE,\n        type: type,\n        loc: this.loc(start)\n      };\n    }\n\n    return type;\n  }\n  /**\n   * NamedType : Name\n   */\n  ;\n\n  _proto.parseNamedType = function parseNamedType() {\n    var start = this._lexer.token;\n    return {\n      kind: Kind.NAMED_TYPE,\n      name: this.parseName(),\n      loc: this.loc(start)\n    };\n  } // Implements the parsing rules in the Type Definition section.\n\n  /**\n   * TypeSystemDefinition :\n   *   - SchemaDefinition\n   *   - TypeDefinition\n   *   - DirectiveDefinition\n   *\n   * TypeDefinition :\n   *   - ScalarTypeDefinition\n   *   - ObjectTypeDefinition\n   *   - InterfaceTypeDefinition\n   *   - UnionTypeDefinition\n   *   - EnumTypeDefinition\n   *   - InputObjectTypeDefinition\n   */\n  ;\n\n  _proto.parseTypeSystemDefinition = function parseTypeSystemDefinition() {\n    // Many definitions begin with a description and require a lookahead.\n    var keywordToken = this.peekDescription() ? this._lexer.lookahead() : this._lexer.token;\n\n    if (keywordToken.kind === TokenKind.NAME) {\n      switch (keywordToken.value) {\n        case 'schema':\n          return this.parseSchemaDefinition();\n\n        case 'scalar':\n          return this.parseScalarTypeDefinition();\n\n        case 'type':\n          return this.parseObjectTypeDefinition();\n\n        case 'interface':\n          return this.parseInterfaceTypeDefinition();\n\n        case 'union':\n          return this.parseUnionTypeDefinition();\n\n        case 'enum':\n          return this.parseEnumTypeDefinition();\n\n        case 'input':\n          return this.parseInputObjectTypeDefinition();\n\n        case 'directive':\n          return this.parseDirectiveDefinition();\n      }\n    }\n\n    throw this.unexpected(keywordToken);\n  };\n\n  _proto.peekDescription = function peekDescription() {\n    return this.peek(TokenKind.STRING) || this.peek(TokenKind.BLOCK_STRING);\n  }\n  /**\n   * Description : StringValue\n   */\n  ;\n\n  _proto.parseDescription = function parseDescription() {\n    if (this.peekDescription()) {\n      return this.parseStringLiteral();\n    }\n  }\n  /**\n   * SchemaDefinition : Description? schema Directives[Const]? { OperationTypeDefinition+ }\n   */\n  ;\n\n  _proto.parseSchemaDefinition = function parseSchemaDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword('schema');\n    var directives = this.parseDirectives(true);\n    var operationTypes = this.many(TokenKind.BRACE_L, this.parseOperationTypeDefinition, TokenKind.BRACE_R);\n    return {\n      kind: Kind.SCHEMA_DEFINITION,\n      description: description,\n      directives: directives,\n      operationTypes: operationTypes,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * OperationTypeDefinition : OperationType : NamedType\n   */\n  ;\n\n  _proto.parseOperationTypeDefinition = function parseOperationTypeDefinition() {\n    var start = this._lexer.token;\n    var operation = this.parseOperationType();\n    this.expectToken(TokenKind.COLON);\n    var type = this.parseNamedType();\n    return {\n      kind: Kind.OPERATION_TYPE_DEFINITION,\n      operation: operation,\n      type: type,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * ScalarTypeDefinition : Description? scalar Name Directives[Const]?\n   */\n  ;\n\n  _proto.parseScalarTypeDefinition = function parseScalarTypeDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword('scalar');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    return {\n      kind: Kind.SCALAR_TYPE_DEFINITION,\n      description: description,\n      name: name,\n      directives: directives,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * ObjectTypeDefinition :\n   *   Description?\n   *   type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition?\n   */\n  ;\n\n  _proto.parseObjectTypeDefinition = function parseObjectTypeDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword('type');\n    var name = this.parseName();\n    var interfaces = this.parseImplementsInterfaces();\n    var directives = this.parseDirectives(true);\n    var fields = this.parseFieldsDefinition();\n    return {\n      kind: Kind.OBJECT_TYPE_DEFINITION,\n      description: description,\n      name: name,\n      interfaces: interfaces,\n      directives: directives,\n      fields: fields,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * ImplementsInterfaces :\n   *   - implements `&`? NamedType\n   *   - ImplementsInterfaces & NamedType\n   */\n  ;\n\n  _proto.parseImplementsInterfaces = function parseImplementsInterfaces() {\n    var _this$_options2;\n\n    if (!this.expectOptionalKeyword('implements')) {\n      return [];\n    }\n\n    if (((_this$_options2 = this._options) === null || _this$_options2 === void 0 ? void 0 : _this$_options2.allowLegacySDLImplementsInterfaces) === true) {\n      var types = []; // Optional leading ampersand\n\n      this.expectOptionalToken(TokenKind.AMP);\n\n      do {\n        types.push(this.parseNamedType());\n      } while (this.expectOptionalToken(TokenKind.AMP) || this.peek(TokenKind.NAME));\n\n      return types;\n    }\n\n    return this.delimitedMany(TokenKind.AMP, this.parseNamedType);\n  }\n  /**\n   * FieldsDefinition : { FieldDefinition+ }\n   */\n  ;\n\n  _proto.parseFieldsDefinition = function parseFieldsDefinition() {\n    var _this$_options3;\n\n    // Legacy support for the SDL?\n    if (((_this$_options3 = this._options) === null || _this$_options3 === void 0 ? void 0 : _this$_options3.allowLegacySDLEmptyFields) === true && this.peek(TokenKind.BRACE_L) && this._lexer.lookahead().kind === TokenKind.BRACE_R) {\n      this._lexer.advance();\n\n      this._lexer.advance();\n\n      return [];\n    }\n\n    return this.optionalMany(TokenKind.BRACE_L, this.parseFieldDefinition, TokenKind.BRACE_R);\n  }\n  /**\n   * FieldDefinition :\n   *   - Description? Name ArgumentsDefinition? : Type Directives[Const]?\n   */\n  ;\n\n  _proto.parseFieldDefinition = function parseFieldDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    var name = this.parseName();\n    var args = this.parseArgumentDefs();\n    this.expectToken(TokenKind.COLON);\n    var type = this.parseTypeReference();\n    var directives = this.parseDirectives(true);\n    return {\n      kind: Kind.FIELD_DEFINITION,\n      description: description,\n      name: name,\n      arguments: args,\n      type: type,\n      directives: directives,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * ArgumentsDefinition : ( InputValueDefinition+ )\n   */\n  ;\n\n  _proto.parseArgumentDefs = function parseArgumentDefs() {\n    return this.optionalMany(TokenKind.PAREN_L, this.parseInputValueDef, TokenKind.PAREN_R);\n  }\n  /**\n   * InputValueDefinition :\n   *   - Description? Name : Type DefaultValue? Directives[Const]?\n   */\n  ;\n\n  _proto.parseInputValueDef = function parseInputValueDef() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    var name = this.parseName();\n    this.expectToken(TokenKind.COLON);\n    var type = this.parseTypeReference();\n    var defaultValue;\n\n    if (this.expectOptionalToken(TokenKind.EQUALS)) {\n      defaultValue = this.parseValueLiteral(true);\n    }\n\n    var directives = this.parseDirectives(true);\n    return {\n      kind: Kind.INPUT_VALUE_DEFINITION,\n      description: description,\n      name: name,\n      type: type,\n      defaultValue: defaultValue,\n      directives: directives,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * InterfaceTypeDefinition :\n   *   - Description? interface Name Directives[Const]? FieldsDefinition?\n   */\n  ;\n\n  _proto.parseInterfaceTypeDefinition = function parseInterfaceTypeDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword('interface');\n    var name = this.parseName();\n    var interfaces = this.parseImplementsInterfaces();\n    var directives = this.parseDirectives(true);\n    var fields = this.parseFieldsDefinition();\n    return {\n      kind: Kind.INTERFACE_TYPE_DEFINITION,\n      description: description,\n      name: name,\n      interfaces: interfaces,\n      directives: directives,\n      fields: fields,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * UnionTypeDefinition :\n   *   - Description? union Name Directives[Const]? UnionMemberTypes?\n   */\n  ;\n\n  _proto.parseUnionTypeDefinition = function parseUnionTypeDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword('union');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    var types = this.parseUnionMemberTypes();\n    return {\n      kind: Kind.UNION_TYPE_DEFINITION,\n      description: description,\n      name: name,\n      directives: directives,\n      types: types,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * UnionMemberTypes :\n   *   - = `|`? NamedType\n   *   - UnionMemberTypes | NamedType\n   */\n  ;\n\n  _proto.parseUnionMemberTypes = function parseUnionMemberTypes() {\n    return this.expectOptionalToken(TokenKind.EQUALS) ? this.delimitedMany(TokenKind.PIPE, this.parseNamedType) : [];\n  }\n  /**\n   * EnumTypeDefinition :\n   *   - Description? enum Name Directives[Const]? EnumValuesDefinition?\n   */\n  ;\n\n  _proto.parseEnumTypeDefinition = function parseEnumTypeDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword('enum');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    var values = this.parseEnumValuesDefinition();\n    return {\n      kind: Kind.ENUM_TYPE_DEFINITION,\n      description: description,\n      name: name,\n      directives: directives,\n      values: values,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * EnumValuesDefinition : { EnumValueDefinition+ }\n   */\n  ;\n\n  _proto.parseEnumValuesDefinition = function parseEnumValuesDefinition() {\n    return this.optionalMany(TokenKind.BRACE_L, this.parseEnumValueDefinition, TokenKind.BRACE_R);\n  }\n  /**\n   * EnumValueDefinition : Description? EnumValue Directives[Const]?\n   *\n   * EnumValue : Name\n   */\n  ;\n\n  _proto.parseEnumValueDefinition = function parseEnumValueDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    return {\n      kind: Kind.ENUM_VALUE_DEFINITION,\n      description: description,\n      name: name,\n      directives: directives,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * InputObjectTypeDefinition :\n   *   - Description? input Name Directives[Const]? InputFieldsDefinition?\n   */\n  ;\n\n  _proto.parseInputObjectTypeDefinition = function parseInputObjectTypeDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword('input');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    var fields = this.parseInputFieldsDefinition();\n    return {\n      kind: Kind.INPUT_OBJECT_TYPE_DEFINITION,\n      description: description,\n      name: name,\n      directives: directives,\n      fields: fields,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * InputFieldsDefinition : { InputValueDefinition+ }\n   */\n  ;\n\n  _proto.parseInputFieldsDefinition = function parseInputFieldsDefinition() {\n    return this.optionalMany(TokenKind.BRACE_L, this.parseInputValueDef, TokenKind.BRACE_R);\n  }\n  /**\n   * TypeSystemExtension :\n   *   - SchemaExtension\n   *   - TypeExtension\n   *\n   * TypeExtension :\n   *   - ScalarTypeExtension\n   *   - ObjectTypeExtension\n   *   - InterfaceTypeExtension\n   *   - UnionTypeExtension\n   *   - EnumTypeExtension\n   *   - InputObjectTypeDefinition\n   */\n  ;\n\n  _proto.parseTypeSystemExtension = function parseTypeSystemExtension() {\n    var keywordToken = this._lexer.lookahead();\n\n    if (keywordToken.kind === TokenKind.NAME) {\n      switch (keywordToken.value) {\n        case 'schema':\n          return this.parseSchemaExtension();\n\n        case 'scalar':\n          return this.parseScalarTypeExtension();\n\n        case 'type':\n          return this.parseObjectTypeExtension();\n\n        case 'interface':\n          return this.parseInterfaceTypeExtension();\n\n        case 'union':\n          return this.parseUnionTypeExtension();\n\n        case 'enum':\n          return this.parseEnumTypeExtension();\n\n        case 'input':\n          return this.parseInputObjectTypeExtension();\n      }\n    }\n\n    throw this.unexpected(keywordToken);\n  }\n  /**\n   * SchemaExtension :\n   *  - extend schema Directives[Const]? { OperationTypeDefinition+ }\n   *  - extend schema Directives[Const]\n   */\n  ;\n\n  _proto.parseSchemaExtension = function parseSchemaExtension() {\n    var start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('schema');\n    var directives = this.parseDirectives(true);\n    var operationTypes = this.optionalMany(TokenKind.BRACE_L, this.parseOperationTypeDefinition, TokenKind.BRACE_R);\n\n    if (directives.length === 0 && operationTypes.length === 0) {\n      throw this.unexpected();\n    }\n\n    return {\n      kind: Kind.SCHEMA_EXTENSION,\n      directives: directives,\n      operationTypes: operationTypes,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * ScalarTypeExtension :\n   *   - extend scalar Name Directives[Const]\n   */\n  ;\n\n  _proto.parseScalarTypeExtension = function parseScalarTypeExtension() {\n    var start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('scalar');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n\n    if (directives.length === 0) {\n      throw this.unexpected();\n    }\n\n    return {\n      kind: Kind.SCALAR_TYPE_EXTENSION,\n      name: name,\n      directives: directives,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * ObjectTypeExtension :\n   *  - extend type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition\n   *  - extend type Name ImplementsInterfaces? Directives[Const]\n   *  - extend type Name ImplementsInterfaces\n   */\n  ;\n\n  _proto.parseObjectTypeExtension = function parseObjectTypeExtension() {\n    var start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('type');\n    var name = this.parseName();\n    var interfaces = this.parseImplementsInterfaces();\n    var directives = this.parseDirectives(true);\n    var fields = this.parseFieldsDefinition();\n\n    if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {\n      throw this.unexpected();\n    }\n\n    return {\n      kind: Kind.OBJECT_TYPE_EXTENSION,\n      name: name,\n      interfaces: interfaces,\n      directives: directives,\n      fields: fields,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * InterfaceTypeExtension :\n   *  - extend interface Name ImplementsInterfaces? Directives[Const]? FieldsDefinition\n   *  - extend interface Name ImplementsInterfaces? Directives[Const]\n   *  - extend interface Name ImplementsInterfaces\n   */\n  ;\n\n  _proto.parseInterfaceTypeExtension = function parseInterfaceTypeExtension() {\n    var start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('interface');\n    var name = this.parseName();\n    var interfaces = this.parseImplementsInterfaces();\n    var directives = this.parseDirectives(true);\n    var fields = this.parseFieldsDefinition();\n\n    if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {\n      throw this.unexpected();\n    }\n\n    return {\n      kind: Kind.INTERFACE_TYPE_EXTENSION,\n      name: name,\n      interfaces: interfaces,\n      directives: directives,\n      fields: fields,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * UnionTypeExtension :\n   *   - extend union Name Directives[Const]? UnionMemberTypes\n   *   - extend union Name Directives[Const]\n   */\n  ;\n\n  _proto.parseUnionTypeExtension = function parseUnionTypeExtension() {\n    var start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('union');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    var types = this.parseUnionMemberTypes();\n\n    if (directives.length === 0 && types.length === 0) {\n      throw this.unexpected();\n    }\n\n    return {\n      kind: Kind.UNION_TYPE_EXTENSION,\n      name: name,\n      directives: directives,\n      types: types,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * EnumTypeExtension :\n   *   - extend enum Name Directives[Const]? EnumValuesDefinition\n   *   - extend enum Name Directives[Const]\n   */\n  ;\n\n  _proto.parseEnumTypeExtension = function parseEnumTypeExtension() {\n    var start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('enum');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    var values = this.parseEnumValuesDefinition();\n\n    if (directives.length === 0 && values.length === 0) {\n      throw this.unexpected();\n    }\n\n    return {\n      kind: Kind.ENUM_TYPE_EXTENSION,\n      name: name,\n      directives: directives,\n      values: values,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * InputObjectTypeExtension :\n   *   - extend input Name Directives[Const]? InputFieldsDefinition\n   *   - extend input Name Directives[Const]\n   */\n  ;\n\n  _proto.parseInputObjectTypeExtension = function parseInputObjectTypeExtension() {\n    var start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('input');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    var fields = this.parseInputFieldsDefinition();\n\n    if (directives.length === 0 && fields.length === 0) {\n      throw this.unexpected();\n    }\n\n    return {\n      kind: Kind.INPUT_OBJECT_TYPE_EXTENSION,\n      name: name,\n      directives: directives,\n      fields: fields,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * DirectiveDefinition :\n   *   - Description? directive @ Name ArgumentsDefinition? `repeatable`? on DirectiveLocations\n   */\n  ;\n\n  _proto.parseDirectiveDefinition = function parseDirectiveDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword('directive');\n    this.expectToken(TokenKind.AT);\n    var name = this.parseName();\n    var args = this.parseArgumentDefs();\n    var repeatable = this.expectOptionalKeyword('repeatable');\n    this.expectKeyword('on');\n    var locations = this.parseDirectiveLocations();\n    return {\n      kind: Kind.DIRECTIVE_DEFINITION,\n      description: description,\n      name: name,\n      arguments: args,\n      repeatable: repeatable,\n      locations: locations,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * DirectiveLocations :\n   *   - `|`? DirectiveLocation\n   *   - DirectiveLocations | DirectiveLocation\n   */\n  ;\n\n  _proto.parseDirectiveLocations = function parseDirectiveLocations() {\n    return this.delimitedMany(TokenKind.PIPE, this.parseDirectiveLocation);\n  }\n  /*\n   * DirectiveLocation :\n   *   - ExecutableDirectiveLocation\n   *   - TypeSystemDirectiveLocation\n   *\n   * ExecutableDirectiveLocation : one of\n   *   `QUERY`\n   *   `MUTATION`\n   *   `SUBSCRIPTION`\n   *   `FIELD`\n   *   `FRAGMENT_DEFINITION`\n   *   `FRAGMENT_SPREAD`\n   *   `INLINE_FRAGMENT`\n   *\n   * TypeSystemDirectiveLocation : one of\n   *   `SCHEMA`\n   *   `SCALAR`\n   *   `OBJECT`\n   *   `FIELD_DEFINITION`\n   *   `ARGUMENT_DEFINITION`\n   *   `INTERFACE`\n   *   `UNION`\n   *   `ENUM`\n   *   `ENUM_VALUE`\n   *   `INPUT_OBJECT`\n   *   `INPUT_FIELD_DEFINITION`\n   */\n  ;\n\n  _proto.parseDirectiveLocation = function parseDirectiveLocation() {\n    var start = this._lexer.token;\n    var name = this.parseName();\n\n    if (DirectiveLocation[name.value] !== undefined) {\n      return name;\n    }\n\n    throw this.unexpected(start);\n  } // Core parsing utility functions\n\n  /**\n   * Returns a location object, used to identify the place in the source that created a given parsed object.\n   */\n  ;\n\n  _proto.loc = function loc(startToken) {\n    var _this$_options4;\n\n    if (((_this$_options4 = this._options) === null || _this$_options4 === void 0 ? void 0 : _this$_options4.noLocation) !== true) {\n      return new Location(startToken, this._lexer.lastToken, this._lexer.source);\n    }\n  }\n  /**\n   * Determines if the next token is of a given kind\n   */\n  ;\n\n  _proto.peek = function peek(kind) {\n    return this._lexer.token.kind === kind;\n  }\n  /**\n   * If the next token is of the given kind, return that token after advancing the lexer.\n   * Otherwise, do not change the parser state and throw an error.\n   */\n  ;\n\n  _proto.expectToken = function expectToken(kind) {\n    var token = this._lexer.token;\n\n    if (token.kind === kind) {\n      this._lexer.advance();\n\n      return token;\n    }\n\n    throw syntaxError(this._lexer.source, token.start, \"Expected \".concat(getTokenKindDesc(kind), \", found \").concat(getTokenDesc(token), \".\"));\n  }\n  /**\n   * If the next token is of the given kind, return that token after advancing the lexer.\n   * Otherwise, do not change the parser state and return undefined.\n   */\n  ;\n\n  _proto.expectOptionalToken = function expectOptionalToken(kind) {\n    var token = this._lexer.token;\n\n    if (token.kind === kind) {\n      this._lexer.advance();\n\n      return token;\n    }\n\n    return undefined;\n  }\n  /**\n   * If the next token is a given keyword, advance the lexer.\n   * Otherwise, do not change the parser state and throw an error.\n   */\n  ;\n\n  _proto.expectKeyword = function expectKeyword(value) {\n    var token = this._lexer.token;\n\n    if (token.kind === TokenKind.NAME && token.value === value) {\n      this._lexer.advance();\n    } else {\n      throw syntaxError(this._lexer.source, token.start, \"Expected \\\"\".concat(value, \"\\\", found \").concat(getTokenDesc(token), \".\"));\n    }\n  }\n  /**\n   * If the next token is a given keyword, return \"true\" after advancing the lexer.\n   * Otherwise, do not change the parser state and return \"false\".\n   */\n  ;\n\n  _proto.expectOptionalKeyword = function expectOptionalKeyword(value) {\n    var token = this._lexer.token;\n\n    if (token.kind === TokenKind.NAME && token.value === value) {\n      this._lexer.advance();\n\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * Helper function for creating an error when an unexpected lexed token is encountered.\n   */\n  ;\n\n  _proto.unexpected = function unexpected(atToken) {\n    var token = atToken !== null && atToken !== void 0 ? atToken : this._lexer.token;\n    return syntaxError(this._lexer.source, token.start, \"Unexpected \".concat(getTokenDesc(token), \".\"));\n  }\n  /**\n   * Returns a possibly empty list of parse nodes, determined by the parseFn.\n   * This list begins with a lex token of openKind and ends with a lex token of closeKind.\n   * Advances the parser to the next lex token after the closing token.\n   */\n  ;\n\n  _proto.any = function any(openKind, parseFn, closeKind) {\n    this.expectToken(openKind);\n    var nodes = [];\n\n    while (!this.expectOptionalToken(closeKind)) {\n      nodes.push(parseFn.call(this));\n    }\n\n    return nodes;\n  }\n  /**\n   * Returns a list of parse nodes, determined by the parseFn.\n   * It can be empty only if open token is missing otherwise it will always return non-empty list\n   * that begins with a lex token of openKind and ends with a lex token of closeKind.\n   * Advances the parser to the next lex token after the closing token.\n   */\n  ;\n\n  _proto.optionalMany = function optionalMany(openKind, parseFn, closeKind) {\n    if (this.expectOptionalToken(openKind)) {\n      var nodes = [];\n\n      do {\n        nodes.push(parseFn.call(this));\n      } while (!this.expectOptionalToken(closeKind));\n\n      return nodes;\n    }\n\n    return [];\n  }\n  /**\n   * Returns a non-empty list of parse nodes, determined by the parseFn.\n   * This list begins with a lex token of openKind and ends with a lex token of closeKind.\n   * Advances the parser to the next lex token after the closing token.\n   */\n  ;\n\n  _proto.many = function many(openKind, parseFn, closeKind) {\n    this.expectToken(openKind);\n    var nodes = [];\n\n    do {\n      nodes.push(parseFn.call(this));\n    } while (!this.expectOptionalToken(closeKind));\n\n    return nodes;\n  }\n  /**\n   * Returns a non-empty list of parse nodes, determined by the parseFn.\n   * This list may begin with a lex token of delimiterKind followed by items separated by lex tokens of tokenKind.\n   * Advances the parser to the next lex token after last item in the list.\n   */\n  ;\n\n  _proto.delimitedMany = function delimitedMany(delimiterKind, parseFn) {\n    this.expectOptionalToken(delimiterKind);\n    var nodes = [];\n\n    do {\n      nodes.push(parseFn.call(this));\n    } while (this.expectOptionalToken(delimiterKind));\n\n    return nodes;\n  };\n\n  return Parser;\n}();\n/**\n * A helper function to describe a token as a string for debugging.\n */\n\nfunction getTokenDesc(token) {\n  var value = token.value;\n  return getTokenKindDesc(token.kind) + (value != null ? \" \\\"\".concat(value, \"\\\"\") : '');\n}\n/**\n * A helper function to describe a token kind as a string for debugging.\n */\n\n\nfunction getTokenKindDesc(kind) {\n  return isPunctuatorTokenKind(kind) ? \"\\\"\".concat(kind, \"\\\"\") : kind;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}