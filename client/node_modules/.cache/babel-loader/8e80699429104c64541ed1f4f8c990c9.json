{"ast":null,"code":"import find from\"../polyfills/find.mjs\";import objectValues from\"../polyfills/objectValues.mjs\";import inspect from\"../jsutils/inspect.mjs\";import{GraphQLError}from\"../error/GraphQLError.mjs\";import{locatedError}from\"../error/locatedError.mjs\";import{isValidNameError}from\"../utilities/assertValidName.mjs\";import{isEqualType,isTypeSubTypeOf}from\"../utilities/typeComparators.mjs\";import{assertSchema}from\"./schema.mjs\";import{isIntrospectionType}from\"./introspection.mjs\";import{isDirective,GraphQLDeprecatedDirective}from\"./directives.mjs\";import{isObjectType,isInterfaceType,isUnionType,isEnumType,isInputObjectType,isNamedType,isNonNullType,isInputType,isOutputType,isRequiredArgument,isRequiredInputField}from\"./definition.mjs\";/**\n * Implements the \"Type Validation\" sub-sections of the specification's\n * \"Type System\" section.\n *\n * Validation runs synchronously, returning an array of encountered errors, or\n * an empty array if no errors were encountered and the Schema is valid.\n */export function validateSchema(schema){// First check to ensure the provided value is in fact a GraphQLSchema.\nassertSchema(schema);// If this Schema has already been validated, return the previous results.\nif(schema.__validationErrors){return schema.__validationErrors;}// Validate the schema, producing a list of errors.\nvar context=new SchemaValidationContext(schema);validateRootTypes(context);validateDirectives(context);validateTypes(context);// Persist the results of validation before returning to ensure validation\n// does not run multiple times for this schema.\nvar errors=context.getErrors();schema.__validationErrors=errors;return errors;}/**\n * Utility function which asserts a schema is valid by throwing an error if\n * it is invalid.\n */export function assertValidSchema(schema){var errors=validateSchema(schema);if(errors.length!==0){throw new Error(errors.map(function(error){return error.message;}).join('\\n\\n'));}}var SchemaValidationContext=/*#__PURE__*/function(){function SchemaValidationContext(schema){this._errors=[];this.schema=schema;}var _proto=SchemaValidationContext.prototype;_proto.reportError=function reportError(message,nodes){var _nodes=Array.isArray(nodes)?nodes.filter(Boolean):nodes;this.addError(new GraphQLError(message,_nodes));};_proto.addError=function addError(error){this._errors.push(error);};_proto.getErrors=function getErrors(){return this._errors;};return SchemaValidationContext;}();function validateRootTypes(context){var schema=context.schema;var queryType=schema.getQueryType();if(!queryType){context.reportError('Query root type must be provided.',schema.astNode);}else if(!isObjectType(queryType)){var _getOperationTypeNode;context.reportError(\"Query root type must be Object type, it cannot be \".concat(inspect(queryType),\".\"),(_getOperationTypeNode=getOperationTypeNode(schema,'query'))!==null&&_getOperationTypeNode!==void 0?_getOperationTypeNode:queryType.astNode);}var mutationType=schema.getMutationType();if(mutationType&&!isObjectType(mutationType)){var _getOperationTypeNode2;context.reportError('Mutation root type must be Object type if provided, it cannot be '+\"\".concat(inspect(mutationType),\".\"),(_getOperationTypeNode2=getOperationTypeNode(schema,'mutation'))!==null&&_getOperationTypeNode2!==void 0?_getOperationTypeNode2:mutationType.astNode);}var subscriptionType=schema.getSubscriptionType();if(subscriptionType&&!isObjectType(subscriptionType)){var _getOperationTypeNode3;context.reportError('Subscription root type must be Object type if provided, it cannot be '+\"\".concat(inspect(subscriptionType),\".\"),(_getOperationTypeNode3=getOperationTypeNode(schema,'subscription'))!==null&&_getOperationTypeNode3!==void 0?_getOperationTypeNode3:subscriptionType.astNode);}}function getOperationTypeNode(schema,operation){var operationNodes=getAllSubNodes(schema,function(node){return node.operationTypes;});for(var _i2=0;_i2<operationNodes.length;_i2++){var node=operationNodes[_i2];if(node.operation===operation){return node.type;}}return undefined;}function validateDirectives(context){for(var _i4=0,_context$schema$getDi2=context.schema.getDirectives();_i4<_context$schema$getDi2.length;_i4++){var directive=_context$schema$getDi2[_i4];// Ensure all directives are in fact GraphQL directives.\nif(!isDirective(directive)){context.reportError(\"Expected directive but got: \".concat(inspect(directive),\".\"),directive===null||directive===void 0?void 0:directive.astNode);continue;}// Ensure they are named correctly.\nvalidateName(context,directive);// TODO: Ensure proper locations.\n// Ensure the arguments are valid.\nfor(var _i6=0,_directive$args2=directive.args;_i6<_directive$args2.length;_i6++){var arg=_directive$args2[_i6];// Ensure they are named correctly.\nvalidateName(context,arg);// Ensure the type is an input type.\nif(!isInputType(arg.type)){context.reportError(\"The type of @\".concat(directive.name,\"(\").concat(arg.name,\":) must be Input Type \")+\"but got: \".concat(inspect(arg.type),\".\"),arg.astNode);}if(isRequiredArgument(arg)&&arg.deprecationReason!=null){var _arg$astNode;context.reportError(\"Required argument @\".concat(directive.name,\"(\").concat(arg.name,\":) cannot be deprecated.\"),[getDeprecatedDirectiveNode(arg.astNode),// istanbul ignore next (TODO need to write coverage tests)\n(_arg$astNode=arg.astNode)===null||_arg$astNode===void 0?void 0:_arg$astNode.type]);}}}}function validateName(context,node){// Ensure names are valid, however introspection types opt out.\nvar error=isValidNameError(node.name);if(error){context.addError(locatedError(error,node.astNode));}}function validateTypes(context){var validateInputObjectCircularRefs=createInputObjectCircularRefsValidator(context);var typeMap=context.schema.getTypeMap();for(var _i8=0,_objectValues2=objectValues(typeMap);_i8<_objectValues2.length;_i8++){var type=_objectValues2[_i8];// Ensure all provided types are in fact GraphQL type.\nif(!isNamedType(type)){context.reportError(\"Expected GraphQL named type but got: \".concat(inspect(type),\".\"),type.astNode);continue;}// Ensure it is named correctly (excluding introspection types).\nif(!isIntrospectionType(type)){validateName(context,type);}if(isObjectType(type)){// Ensure fields are valid\nvalidateFields(context,type);// Ensure objects implement the interfaces they claim to.\nvalidateInterfaces(context,type);}else if(isInterfaceType(type)){// Ensure fields are valid.\nvalidateFields(context,type);// Ensure interfaces implement the interfaces they claim to.\nvalidateInterfaces(context,type);}else if(isUnionType(type)){// Ensure Unions include valid member types.\nvalidateUnionMembers(context,type);}else if(isEnumType(type)){// Ensure Enums have valid values.\nvalidateEnumValues(context,type);}else if(isInputObjectType(type)){// Ensure Input Object fields are valid.\nvalidateInputFields(context,type);// Ensure Input Objects do not contain non-nullable circular references\nvalidateInputObjectCircularRefs(type);}}}function validateFields(context,type){var fields=objectValues(type.getFields());// Objects and Interfaces both must define one or more fields.\nif(fields.length===0){context.reportError(\"Type \".concat(type.name,\" must define one or more fields.\"),getAllNodes(type));}for(var _i10=0;_i10<fields.length;_i10++){var field=fields[_i10];// Ensure they are named correctly.\nvalidateName(context,field);// Ensure the type is an output type\nif(!isOutputType(field.type)){var _field$astNode;context.reportError(\"The type of \".concat(type.name,\".\").concat(field.name,\" must be Output Type \")+\"but got: \".concat(inspect(field.type),\".\"),(_field$astNode=field.astNode)===null||_field$astNode===void 0?void 0:_field$astNode.type);}// Ensure the arguments are valid\nfor(var _i12=0,_field$args2=field.args;_i12<_field$args2.length;_i12++){var arg=_field$args2[_i12];var argName=arg.name;// Ensure they are named correctly.\nvalidateName(context,arg);// Ensure the type is an input type\nif(!isInputType(arg.type)){var _arg$astNode2;context.reportError(\"The type of \".concat(type.name,\".\").concat(field.name,\"(\").concat(argName,\":) must be Input \")+\"Type but got: \".concat(inspect(arg.type),\".\"),(_arg$astNode2=arg.astNode)===null||_arg$astNode2===void 0?void 0:_arg$astNode2.type);}if(isRequiredArgument(arg)&&arg.deprecationReason!=null){var _arg$astNode3;context.reportError(\"Required argument \".concat(type.name,\".\").concat(field.name,\"(\").concat(argName,\":) cannot be deprecated.\"),[getDeprecatedDirectiveNode(arg.astNode),// istanbul ignore next (TODO need to write coverage tests)\n(_arg$astNode3=arg.astNode)===null||_arg$astNode3===void 0?void 0:_arg$astNode3.type]);}}}}function validateInterfaces(context,type){var ifaceTypeNames=Object.create(null);for(var _i14=0,_type$getInterfaces2=type.getInterfaces();_i14<_type$getInterfaces2.length;_i14++){var iface=_type$getInterfaces2[_i14];if(!isInterfaceType(iface)){context.reportError(\"Type \".concat(inspect(type),\" must only implement Interface types, \")+\"it cannot implement \".concat(inspect(iface),\".\"),getAllImplementsInterfaceNodes(type,iface));continue;}if(type===iface){context.reportError(\"Type \".concat(type.name,\" cannot implement itself because it would create a circular reference.\"),getAllImplementsInterfaceNodes(type,iface));continue;}if(ifaceTypeNames[iface.name]){context.reportError(\"Type \".concat(type.name,\" can only implement \").concat(iface.name,\" once.\"),getAllImplementsInterfaceNodes(type,iface));continue;}ifaceTypeNames[iface.name]=true;validateTypeImplementsAncestors(context,type,iface);validateTypeImplementsInterface(context,type,iface);}}function validateTypeImplementsInterface(context,type,iface){var typeFieldMap=type.getFields();// Assert each interface field is implemented.\nfor(var _i16=0,_objectValues4=objectValues(iface.getFields());_i16<_objectValues4.length;_i16++){var ifaceField=_objectValues4[_i16];var fieldName=ifaceField.name;var typeField=typeFieldMap[fieldName];// Assert interface field exists on type.\nif(!typeField){context.reportError(\"Interface field \".concat(iface.name,\".\").concat(fieldName,\" expected but \").concat(type.name,\" does not provide it.\"),[ifaceField.astNode].concat(getAllNodes(type)));continue;}// Assert interface field type is satisfied by type field type, by being\n// a valid subtype. (covariant)\nif(!isTypeSubTypeOf(context.schema,typeField.type,ifaceField.type)){var _ifaceField$astNode,_typeField$astNode;context.reportError(\"Interface field \".concat(iface.name,\".\").concat(fieldName,\" expects type \")+\"\".concat(inspect(ifaceField.type),\" but \").concat(type.name,\".\").concat(fieldName,\" \")+\"is type \".concat(inspect(typeField.type),\".\"),[// istanbul ignore next (TODO need to write coverage tests)\n(_ifaceField$astNode=ifaceField.astNode)===null||_ifaceField$astNode===void 0?void 0:_ifaceField$astNode.type,// istanbul ignore next (TODO need to write coverage tests)\n(_typeField$astNode=typeField.astNode)===null||_typeField$astNode===void 0?void 0:_typeField$astNode.type]);}// Assert each interface field arg is implemented.\nvar _loop=function _loop(_i18,_ifaceField$args2){var ifaceArg=_ifaceField$args2[_i18];var argName=ifaceArg.name;var typeArg=find(typeField.args,function(arg){return arg.name===argName;});// Assert interface field arg exists on object field.\nif(!typeArg){context.reportError(\"Interface field argument \".concat(iface.name,\".\").concat(fieldName,\"(\").concat(argName,\":) expected but \").concat(type.name,\".\").concat(fieldName,\" does not provide it.\"),[ifaceArg.astNode,typeField.astNode]);return\"continue\";}// Assert interface field arg type matches object field arg type.\n// (invariant)\n// TODO: change to contravariant?\nif(!isEqualType(ifaceArg.type,typeArg.type)){var _ifaceArg$astNode,_typeArg$astNode;context.reportError(\"Interface field argument \".concat(iface.name,\".\").concat(fieldName,\"(\").concat(argName,\":) \")+\"expects type \".concat(inspect(ifaceArg.type),\" but \")+\"\".concat(type.name,\".\").concat(fieldName,\"(\").concat(argName,\":) is type \")+\"\".concat(inspect(typeArg.type),\".\"),[// istanbul ignore next (TODO need to write coverage tests)\n(_ifaceArg$astNode=ifaceArg.astNode)===null||_ifaceArg$astNode===void 0?void 0:_ifaceArg$astNode.type,// istanbul ignore next (TODO need to write coverage tests)\n(_typeArg$astNode=typeArg.astNode)===null||_typeArg$astNode===void 0?void 0:_typeArg$astNode.type]);}// TODO: validate default values?\n};for(var _i18=0,_ifaceField$args2=ifaceField.args;_i18<_ifaceField$args2.length;_i18++){var _ret=_loop(_i18,_ifaceField$args2);if(_ret===\"continue\")continue;}// Assert additional arguments must not be required.\nvar _loop2=function _loop2(_i20,_typeField$args2){var typeArg=_typeField$args2[_i20];var argName=typeArg.name;var ifaceArg=find(ifaceField.args,function(arg){return arg.name===argName;});if(!ifaceArg&&isRequiredArgument(typeArg)){context.reportError(\"Object field \".concat(type.name,\".\").concat(fieldName,\" includes required argument \").concat(argName,\" that is missing from the Interface field \").concat(iface.name,\".\").concat(fieldName,\".\"),[typeArg.astNode,ifaceField.astNode]);}};for(var _i20=0,_typeField$args2=typeField.args;_i20<_typeField$args2.length;_i20++){_loop2(_i20,_typeField$args2);}}}function validateTypeImplementsAncestors(context,type,iface){var ifaceInterfaces=type.getInterfaces();for(var _i22=0,_iface$getInterfaces2=iface.getInterfaces();_i22<_iface$getInterfaces2.length;_i22++){var transitive=_iface$getInterfaces2[_i22];if(ifaceInterfaces.indexOf(transitive)===-1){context.reportError(transitive===type?\"Type \".concat(type.name,\" cannot implement \").concat(iface.name,\" because it would create a circular reference.\"):\"Type \".concat(type.name,\" must implement \").concat(transitive.name,\" because it is implemented by \").concat(iface.name,\".\"),[].concat(getAllImplementsInterfaceNodes(iface,transitive),getAllImplementsInterfaceNodes(type,iface)));}}}function validateUnionMembers(context,union){var memberTypes=union.getTypes();if(memberTypes.length===0){context.reportError(\"Union type \".concat(union.name,\" must define one or more member types.\"),getAllNodes(union));}var includedTypeNames=Object.create(null);for(var _i24=0;_i24<memberTypes.length;_i24++){var memberType=memberTypes[_i24];if(includedTypeNames[memberType.name]){context.reportError(\"Union type \".concat(union.name,\" can only include type \").concat(memberType.name,\" once.\"),getUnionMemberTypeNodes(union,memberType.name));continue;}includedTypeNames[memberType.name]=true;if(!isObjectType(memberType)){context.reportError(\"Union type \".concat(union.name,\" can only include Object types, \")+\"it cannot include \".concat(inspect(memberType),\".\"),getUnionMemberTypeNodes(union,String(memberType)));}}}function validateEnumValues(context,enumType){var enumValues=enumType.getValues();if(enumValues.length===0){context.reportError(\"Enum type \".concat(enumType.name,\" must define one or more values.\"),getAllNodes(enumType));}for(var _i26=0;_i26<enumValues.length;_i26++){var enumValue=enumValues[_i26];var valueName=enumValue.name;// Ensure valid name.\nvalidateName(context,enumValue);if(valueName==='true'||valueName==='false'||valueName==='null'){context.reportError(\"Enum type \".concat(enumType.name,\" cannot include value: \").concat(valueName,\".\"),enumValue.astNode);}}}function validateInputFields(context,inputObj){var fields=objectValues(inputObj.getFields());if(fields.length===0){context.reportError(\"Input Object type \".concat(inputObj.name,\" must define one or more fields.\"),getAllNodes(inputObj));}// Ensure the arguments are valid\nfor(var _i28=0;_i28<fields.length;_i28++){var field=fields[_i28];// Ensure they are named correctly.\nvalidateName(context,field);// Ensure the type is an input type\nif(!isInputType(field.type)){var _field$astNode2;context.reportError(\"The type of \".concat(inputObj.name,\".\").concat(field.name,\" must be Input Type \")+\"but got: \".concat(inspect(field.type),\".\"),(_field$astNode2=field.astNode)===null||_field$astNode2===void 0?void 0:_field$astNode2.type);}if(isRequiredInputField(field)&&field.deprecationReason!=null){var _field$astNode3;context.reportError(\"Required input field \".concat(inputObj.name,\".\").concat(field.name,\" cannot be deprecated.\"),[getDeprecatedDirectiveNode(field.astNode),// istanbul ignore next (TODO need to write coverage tests)\n(_field$astNode3=field.astNode)===null||_field$astNode3===void 0?void 0:_field$astNode3.type]);}}}function createInputObjectCircularRefsValidator(context){// Modified copy of algorithm from 'src/validation/rules/NoFragmentCycles.js'.\n// Tracks already visited types to maintain O(N) and to ensure that cycles\n// are not redundantly reported.\nvar visitedTypes=Object.create(null);// Array of types nodes used to produce meaningful errors\nvar fieldPath=[];// Position in the type path\nvar fieldPathIndexByTypeName=Object.create(null);return detectCycleRecursive;// This does a straight-forward DFS to find cycles.\n// It does not terminate when a cycle was found but continues to explore\n// the graph to find all possible cycles.\nfunction detectCycleRecursive(inputObj){if(visitedTypes[inputObj.name]){return;}visitedTypes[inputObj.name]=true;fieldPathIndexByTypeName[inputObj.name]=fieldPath.length;var fields=objectValues(inputObj.getFields());for(var _i30=0;_i30<fields.length;_i30++){var field=fields[_i30];if(isNonNullType(field.type)&&isInputObjectType(field.type.ofType)){var fieldType=field.type.ofType;var cycleIndex=fieldPathIndexByTypeName[fieldType.name];fieldPath.push(field);if(cycleIndex===undefined){detectCycleRecursive(fieldType);}else{var cyclePath=fieldPath.slice(cycleIndex);var pathStr=cyclePath.map(function(fieldObj){return fieldObj.name;}).join('.');context.reportError(\"Cannot reference Input Object \\\"\".concat(fieldType.name,\"\\\" within itself through a series of non-null fields: \\\"\").concat(pathStr,\"\\\".\"),cyclePath.map(function(fieldObj){return fieldObj.astNode;}));}fieldPath.pop();}}fieldPathIndexByTypeName[inputObj.name]=undefined;}}function getAllNodes(object){var astNode=object.astNode,extensionASTNodes=object.extensionASTNodes;return astNode?extensionASTNodes?[astNode].concat(extensionASTNodes):[astNode]:extensionASTNodes!==null&&extensionASTNodes!==void 0?extensionASTNodes:[];}function getAllSubNodes(object,getter){var subNodes=[];for(var _i32=0,_getAllNodes2=getAllNodes(object);_i32<_getAllNodes2.length;_i32++){var _getter;var node=_getAllNodes2[_i32];// istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\nsubNodes=subNodes.concat((_getter=getter(node))!==null&&_getter!==void 0?_getter:[]);}return subNodes;}function getAllImplementsInterfaceNodes(type,iface){return getAllSubNodes(type,function(typeNode){return typeNode.interfaces;}).filter(function(ifaceNode){return ifaceNode.name.value===iface.name;});}function getUnionMemberTypeNodes(union,typeName){return getAllSubNodes(union,function(unionNode){return unionNode.types;}).filter(function(typeNode){return typeNode.name.value===typeName;});}function getDeprecatedDirectiveNode(definitionNode){var _definitionNode$direc;// istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\nreturn definitionNode===null||definitionNode===void 0?void 0:(_definitionNode$direc=definitionNode.directives)===null||_definitionNode$direc===void 0?void 0:_definitionNode$direc.find(function(node){return node.name.value===GraphQLDeprecatedDirective.name;});}","map":{"version":3,"names":["find","objectValues","inspect","GraphQLError","locatedError","isValidNameError","isEqualType","isTypeSubTypeOf","assertSchema","isIntrospectionType","isDirective","GraphQLDeprecatedDirective","isObjectType","isInterfaceType","isUnionType","isEnumType","isInputObjectType","isNamedType","isNonNullType","isInputType","isOutputType","isRequiredArgument","isRequiredInputField","validateSchema","schema","__validationErrors","context","SchemaValidationContext","validateRootTypes","validateDirectives","validateTypes","errors","getErrors","assertValidSchema","length","Error","map","error","message","join","_errors","_proto","prototype","reportError","nodes","_nodes","Array","isArray","filter","Boolean","addError","push","queryType","getQueryType","astNode","_getOperationTypeNode","concat","getOperationTypeNode","mutationType","getMutationType","_getOperationTypeNode2","subscriptionType","getSubscriptionType","_getOperationTypeNode3","operation","operationNodes","getAllSubNodes","node","operationTypes","_i2","type","undefined","_i4","_context$schema$getDi2","getDirectives","directive","validateName","_i6","_directive$args2","args","arg","name","deprecationReason","_arg$astNode","getDeprecatedDirectiveNode","validateInputObjectCircularRefs","createInputObjectCircularRefsValidator","typeMap","getTypeMap","_i8","_objectValues2","validateFields","validateInterfaces","validateUnionMembers","validateEnumValues","validateInputFields","fields","getFields","getAllNodes","_i10","field","_field$astNode","_i12","_field$args2","argName","_arg$astNode2","_arg$astNode3","ifaceTypeNames","Object","create","_i14","_type$getInterfaces2","getInterfaces","iface","getAllImplementsInterfaceNodes","validateTypeImplementsAncestors","validateTypeImplementsInterface","typeFieldMap","_i16","_objectValues4","ifaceField","fieldName","typeField","_ifaceField$astNode","_typeField$astNode","_loop","_i18","_ifaceField$args2","ifaceArg","typeArg","_ifaceArg$astNode","_typeArg$astNode","_ret","_loop2","_i20","_typeField$args2","ifaceInterfaces","_i22","_iface$getInterfaces2","transitive","indexOf","union","memberTypes","getTypes","includedTypeNames","_i24","memberType","getUnionMemberTypeNodes","String","enumType","enumValues","getValues","_i26","enumValue","valueName","inputObj","_i28","_field$astNode2","_field$astNode3","visitedTypes","fieldPath","fieldPathIndexByTypeName","detectCycleRecursive","_i30","ofType","fieldType","cycleIndex","cyclePath","slice","pathStr","fieldObj","pop","object","extensionASTNodes","getter","subNodes","_i32","_getAllNodes2","_getter","typeNode","interfaces","ifaceNode","value","typeName","unionNode","types","definitionNode","_definitionNode$direc","directives"],"sources":["C:/Users/jarma/school/challenges/Project3_Final/client/src/node_modules/graphql/type/validate.mjs"],"sourcesContent":["import find from \"../polyfills/find.mjs\";\nimport objectValues from \"../polyfills/objectValues.mjs\";\nimport inspect from \"../jsutils/inspect.mjs\";\nimport { GraphQLError } from \"../error/GraphQLError.mjs\";\nimport { locatedError } from \"../error/locatedError.mjs\";\nimport { isValidNameError } from \"../utilities/assertValidName.mjs\";\nimport { isEqualType, isTypeSubTypeOf } from \"../utilities/typeComparators.mjs\";\nimport { assertSchema } from \"./schema.mjs\";\nimport { isIntrospectionType } from \"./introspection.mjs\";\nimport { isDirective, GraphQLDeprecatedDirective } from \"./directives.mjs\";\nimport { isObjectType, isInterfaceType, isUnionType, isEnumType, isInputObjectType, isNamedType, isNonNullType, isInputType, isOutputType, isRequiredArgument, isRequiredInputField } from \"./definition.mjs\";\n/**\n * Implements the \"Type Validation\" sub-sections of the specification's\n * \"Type System\" section.\n *\n * Validation runs synchronously, returning an array of encountered errors, or\n * an empty array if no errors were encountered and the Schema is valid.\n */\n\nexport function validateSchema(schema) {\n  // First check to ensure the provided value is in fact a GraphQLSchema.\n  assertSchema(schema); // If this Schema has already been validated, return the previous results.\n\n  if (schema.__validationErrors) {\n    return schema.__validationErrors;\n  } // Validate the schema, producing a list of errors.\n\n\n  var context = new SchemaValidationContext(schema);\n  validateRootTypes(context);\n  validateDirectives(context);\n  validateTypes(context); // Persist the results of validation before returning to ensure validation\n  // does not run multiple times for this schema.\n\n  var errors = context.getErrors();\n  schema.__validationErrors = errors;\n  return errors;\n}\n/**\n * Utility function which asserts a schema is valid by throwing an error if\n * it is invalid.\n */\n\nexport function assertValidSchema(schema) {\n  var errors = validateSchema(schema);\n\n  if (errors.length !== 0) {\n    throw new Error(errors.map(function (error) {\n      return error.message;\n    }).join('\\n\\n'));\n  }\n}\n\nvar SchemaValidationContext = /*#__PURE__*/function () {\n  function SchemaValidationContext(schema) {\n    this._errors = [];\n    this.schema = schema;\n  }\n\n  var _proto = SchemaValidationContext.prototype;\n\n  _proto.reportError = function reportError(message, nodes) {\n    var _nodes = Array.isArray(nodes) ? nodes.filter(Boolean) : nodes;\n\n    this.addError(new GraphQLError(message, _nodes));\n  };\n\n  _proto.addError = function addError(error) {\n    this._errors.push(error);\n  };\n\n  _proto.getErrors = function getErrors() {\n    return this._errors;\n  };\n\n  return SchemaValidationContext;\n}();\n\nfunction validateRootTypes(context) {\n  var schema = context.schema;\n  var queryType = schema.getQueryType();\n\n  if (!queryType) {\n    context.reportError('Query root type must be provided.', schema.astNode);\n  } else if (!isObjectType(queryType)) {\n    var _getOperationTypeNode;\n\n    context.reportError(\"Query root type must be Object type, it cannot be \".concat(inspect(queryType), \".\"), (_getOperationTypeNode = getOperationTypeNode(schema, 'query')) !== null && _getOperationTypeNode !== void 0 ? _getOperationTypeNode : queryType.astNode);\n  }\n\n  var mutationType = schema.getMutationType();\n\n  if (mutationType && !isObjectType(mutationType)) {\n    var _getOperationTypeNode2;\n\n    context.reportError('Mutation root type must be Object type if provided, it cannot be ' + \"\".concat(inspect(mutationType), \".\"), (_getOperationTypeNode2 = getOperationTypeNode(schema, 'mutation')) !== null && _getOperationTypeNode2 !== void 0 ? _getOperationTypeNode2 : mutationType.astNode);\n  }\n\n  var subscriptionType = schema.getSubscriptionType();\n\n  if (subscriptionType && !isObjectType(subscriptionType)) {\n    var _getOperationTypeNode3;\n\n    context.reportError('Subscription root type must be Object type if provided, it cannot be ' + \"\".concat(inspect(subscriptionType), \".\"), (_getOperationTypeNode3 = getOperationTypeNode(schema, 'subscription')) !== null && _getOperationTypeNode3 !== void 0 ? _getOperationTypeNode3 : subscriptionType.astNode);\n  }\n}\n\nfunction getOperationTypeNode(schema, operation) {\n  var operationNodes = getAllSubNodes(schema, function (node) {\n    return node.operationTypes;\n  });\n\n  for (var _i2 = 0; _i2 < operationNodes.length; _i2++) {\n    var node = operationNodes[_i2];\n\n    if (node.operation === operation) {\n      return node.type;\n    }\n  }\n\n  return undefined;\n}\n\nfunction validateDirectives(context) {\n  for (var _i4 = 0, _context$schema$getDi2 = context.schema.getDirectives(); _i4 < _context$schema$getDi2.length; _i4++) {\n    var directive = _context$schema$getDi2[_i4];\n\n    // Ensure all directives are in fact GraphQL directives.\n    if (!isDirective(directive)) {\n      context.reportError(\"Expected directive but got: \".concat(inspect(directive), \".\"), directive === null || directive === void 0 ? void 0 : directive.astNode);\n      continue;\n    } // Ensure they are named correctly.\n\n\n    validateName(context, directive); // TODO: Ensure proper locations.\n    // Ensure the arguments are valid.\n\n    for (var _i6 = 0, _directive$args2 = directive.args; _i6 < _directive$args2.length; _i6++) {\n      var arg = _directive$args2[_i6];\n      // Ensure they are named correctly.\n      validateName(context, arg); // Ensure the type is an input type.\n\n      if (!isInputType(arg.type)) {\n        context.reportError(\"The type of @\".concat(directive.name, \"(\").concat(arg.name, \":) must be Input Type \") + \"but got: \".concat(inspect(arg.type), \".\"), arg.astNode);\n      }\n\n      if (isRequiredArgument(arg) && arg.deprecationReason != null) {\n        var _arg$astNode;\n\n        context.reportError(\"Required argument @\".concat(directive.name, \"(\").concat(arg.name, \":) cannot be deprecated.\"), [getDeprecatedDirectiveNode(arg.astNode), // istanbul ignore next (TODO need to write coverage tests)\n        (_arg$astNode = arg.astNode) === null || _arg$astNode === void 0 ? void 0 : _arg$astNode.type]);\n      }\n    }\n  }\n}\n\nfunction validateName(context, node) {\n  // Ensure names are valid, however introspection types opt out.\n  var error = isValidNameError(node.name);\n\n  if (error) {\n    context.addError(locatedError(error, node.astNode));\n  }\n}\n\nfunction validateTypes(context) {\n  var validateInputObjectCircularRefs = createInputObjectCircularRefsValidator(context);\n  var typeMap = context.schema.getTypeMap();\n\n  for (var _i8 = 0, _objectValues2 = objectValues(typeMap); _i8 < _objectValues2.length; _i8++) {\n    var type = _objectValues2[_i8];\n\n    // Ensure all provided types are in fact GraphQL type.\n    if (!isNamedType(type)) {\n      context.reportError(\"Expected GraphQL named type but got: \".concat(inspect(type), \".\"), type.astNode);\n      continue;\n    } // Ensure it is named correctly (excluding introspection types).\n\n\n    if (!isIntrospectionType(type)) {\n      validateName(context, type);\n    }\n\n    if (isObjectType(type)) {\n      // Ensure fields are valid\n      validateFields(context, type); // Ensure objects implement the interfaces they claim to.\n\n      validateInterfaces(context, type);\n    } else if (isInterfaceType(type)) {\n      // Ensure fields are valid.\n      validateFields(context, type); // Ensure interfaces implement the interfaces they claim to.\n\n      validateInterfaces(context, type);\n    } else if (isUnionType(type)) {\n      // Ensure Unions include valid member types.\n      validateUnionMembers(context, type);\n    } else if (isEnumType(type)) {\n      // Ensure Enums have valid values.\n      validateEnumValues(context, type);\n    } else if (isInputObjectType(type)) {\n      // Ensure Input Object fields are valid.\n      validateInputFields(context, type); // Ensure Input Objects do not contain non-nullable circular references\n\n      validateInputObjectCircularRefs(type);\n    }\n  }\n}\n\nfunction validateFields(context, type) {\n  var fields = objectValues(type.getFields()); // Objects and Interfaces both must define one or more fields.\n\n  if (fields.length === 0) {\n    context.reportError(\"Type \".concat(type.name, \" must define one or more fields.\"), getAllNodes(type));\n  }\n\n  for (var _i10 = 0; _i10 < fields.length; _i10++) {\n    var field = fields[_i10];\n    // Ensure they are named correctly.\n    validateName(context, field); // Ensure the type is an output type\n\n    if (!isOutputType(field.type)) {\n      var _field$astNode;\n\n      context.reportError(\"The type of \".concat(type.name, \".\").concat(field.name, \" must be Output Type \") + \"but got: \".concat(inspect(field.type), \".\"), (_field$astNode = field.astNode) === null || _field$astNode === void 0 ? void 0 : _field$astNode.type);\n    } // Ensure the arguments are valid\n\n\n    for (var _i12 = 0, _field$args2 = field.args; _i12 < _field$args2.length; _i12++) {\n      var arg = _field$args2[_i12];\n      var argName = arg.name; // Ensure they are named correctly.\n\n      validateName(context, arg); // Ensure the type is an input type\n\n      if (!isInputType(arg.type)) {\n        var _arg$astNode2;\n\n        context.reportError(\"The type of \".concat(type.name, \".\").concat(field.name, \"(\").concat(argName, \":) must be Input \") + \"Type but got: \".concat(inspect(arg.type), \".\"), (_arg$astNode2 = arg.astNode) === null || _arg$astNode2 === void 0 ? void 0 : _arg$astNode2.type);\n      }\n\n      if (isRequiredArgument(arg) && arg.deprecationReason != null) {\n        var _arg$astNode3;\n\n        context.reportError(\"Required argument \".concat(type.name, \".\").concat(field.name, \"(\").concat(argName, \":) cannot be deprecated.\"), [getDeprecatedDirectiveNode(arg.astNode), // istanbul ignore next (TODO need to write coverage tests)\n        (_arg$astNode3 = arg.astNode) === null || _arg$astNode3 === void 0 ? void 0 : _arg$astNode3.type]);\n      }\n    }\n  }\n}\n\nfunction validateInterfaces(context, type) {\n  var ifaceTypeNames = Object.create(null);\n\n  for (var _i14 = 0, _type$getInterfaces2 = type.getInterfaces(); _i14 < _type$getInterfaces2.length; _i14++) {\n    var iface = _type$getInterfaces2[_i14];\n\n    if (!isInterfaceType(iface)) {\n      context.reportError(\"Type \".concat(inspect(type), \" must only implement Interface types, \") + \"it cannot implement \".concat(inspect(iface), \".\"), getAllImplementsInterfaceNodes(type, iface));\n      continue;\n    }\n\n    if (type === iface) {\n      context.reportError(\"Type \".concat(type.name, \" cannot implement itself because it would create a circular reference.\"), getAllImplementsInterfaceNodes(type, iface));\n      continue;\n    }\n\n    if (ifaceTypeNames[iface.name]) {\n      context.reportError(\"Type \".concat(type.name, \" can only implement \").concat(iface.name, \" once.\"), getAllImplementsInterfaceNodes(type, iface));\n      continue;\n    }\n\n    ifaceTypeNames[iface.name] = true;\n    validateTypeImplementsAncestors(context, type, iface);\n    validateTypeImplementsInterface(context, type, iface);\n  }\n}\n\nfunction validateTypeImplementsInterface(context, type, iface) {\n  var typeFieldMap = type.getFields(); // Assert each interface field is implemented.\n\n  for (var _i16 = 0, _objectValues4 = objectValues(iface.getFields()); _i16 < _objectValues4.length; _i16++) {\n    var ifaceField = _objectValues4[_i16];\n    var fieldName = ifaceField.name;\n    var typeField = typeFieldMap[fieldName]; // Assert interface field exists on type.\n\n    if (!typeField) {\n      context.reportError(\"Interface field \".concat(iface.name, \".\").concat(fieldName, \" expected but \").concat(type.name, \" does not provide it.\"), [ifaceField.astNode].concat(getAllNodes(type)));\n      continue;\n    } // Assert interface field type is satisfied by type field type, by being\n    // a valid subtype. (covariant)\n\n\n    if (!isTypeSubTypeOf(context.schema, typeField.type, ifaceField.type)) {\n      var _ifaceField$astNode, _typeField$astNode;\n\n      context.reportError(\"Interface field \".concat(iface.name, \".\").concat(fieldName, \" expects type \") + \"\".concat(inspect(ifaceField.type), \" but \").concat(type.name, \".\").concat(fieldName, \" \") + \"is type \".concat(inspect(typeField.type), \".\"), [// istanbul ignore next (TODO need to write coverage tests)\n      (_ifaceField$astNode = ifaceField.astNode) === null || _ifaceField$astNode === void 0 ? void 0 : _ifaceField$astNode.type, // istanbul ignore next (TODO need to write coverage tests)\n      (_typeField$astNode = typeField.astNode) === null || _typeField$astNode === void 0 ? void 0 : _typeField$astNode.type]);\n    } // Assert each interface field arg is implemented.\n\n\n    var _loop = function _loop(_i18, _ifaceField$args2) {\n      var ifaceArg = _ifaceField$args2[_i18];\n      var argName = ifaceArg.name;\n      var typeArg = find(typeField.args, function (arg) {\n        return arg.name === argName;\n      }); // Assert interface field arg exists on object field.\n\n      if (!typeArg) {\n        context.reportError(\"Interface field argument \".concat(iface.name, \".\").concat(fieldName, \"(\").concat(argName, \":) expected but \").concat(type.name, \".\").concat(fieldName, \" does not provide it.\"), [ifaceArg.astNode, typeField.astNode]);\n        return \"continue\";\n      } // Assert interface field arg type matches object field arg type.\n      // (invariant)\n      // TODO: change to contravariant?\n\n\n      if (!isEqualType(ifaceArg.type, typeArg.type)) {\n        var _ifaceArg$astNode, _typeArg$astNode;\n\n        context.reportError(\"Interface field argument \".concat(iface.name, \".\").concat(fieldName, \"(\").concat(argName, \":) \") + \"expects type \".concat(inspect(ifaceArg.type), \" but \") + \"\".concat(type.name, \".\").concat(fieldName, \"(\").concat(argName, \":) is type \") + \"\".concat(inspect(typeArg.type), \".\"), [// istanbul ignore next (TODO need to write coverage tests)\n        (_ifaceArg$astNode = ifaceArg.astNode) === null || _ifaceArg$astNode === void 0 ? void 0 : _ifaceArg$astNode.type, // istanbul ignore next (TODO need to write coverage tests)\n        (_typeArg$astNode = typeArg.astNode) === null || _typeArg$astNode === void 0 ? void 0 : _typeArg$astNode.type]);\n      } // TODO: validate default values?\n\n    };\n\n    for (var _i18 = 0, _ifaceField$args2 = ifaceField.args; _i18 < _ifaceField$args2.length; _i18++) {\n      var _ret = _loop(_i18, _ifaceField$args2);\n\n      if (_ret === \"continue\") continue;\n    } // Assert additional arguments must not be required.\n\n\n    var _loop2 = function _loop2(_i20, _typeField$args2) {\n      var typeArg = _typeField$args2[_i20];\n      var argName = typeArg.name;\n      var ifaceArg = find(ifaceField.args, function (arg) {\n        return arg.name === argName;\n      });\n\n      if (!ifaceArg && isRequiredArgument(typeArg)) {\n        context.reportError(\"Object field \".concat(type.name, \".\").concat(fieldName, \" includes required argument \").concat(argName, \" that is missing from the Interface field \").concat(iface.name, \".\").concat(fieldName, \".\"), [typeArg.astNode, ifaceField.astNode]);\n      }\n    };\n\n    for (var _i20 = 0, _typeField$args2 = typeField.args; _i20 < _typeField$args2.length; _i20++) {\n      _loop2(_i20, _typeField$args2);\n    }\n  }\n}\n\nfunction validateTypeImplementsAncestors(context, type, iface) {\n  var ifaceInterfaces = type.getInterfaces();\n\n  for (var _i22 = 0, _iface$getInterfaces2 = iface.getInterfaces(); _i22 < _iface$getInterfaces2.length; _i22++) {\n    var transitive = _iface$getInterfaces2[_i22];\n\n    if (ifaceInterfaces.indexOf(transitive) === -1) {\n      context.reportError(transitive === type ? \"Type \".concat(type.name, \" cannot implement \").concat(iface.name, \" because it would create a circular reference.\") : \"Type \".concat(type.name, \" must implement \").concat(transitive.name, \" because it is implemented by \").concat(iface.name, \".\"), [].concat(getAllImplementsInterfaceNodes(iface, transitive), getAllImplementsInterfaceNodes(type, iface)));\n    }\n  }\n}\n\nfunction validateUnionMembers(context, union) {\n  var memberTypes = union.getTypes();\n\n  if (memberTypes.length === 0) {\n    context.reportError(\"Union type \".concat(union.name, \" must define one or more member types.\"), getAllNodes(union));\n  }\n\n  var includedTypeNames = Object.create(null);\n\n  for (var _i24 = 0; _i24 < memberTypes.length; _i24++) {\n    var memberType = memberTypes[_i24];\n\n    if (includedTypeNames[memberType.name]) {\n      context.reportError(\"Union type \".concat(union.name, \" can only include type \").concat(memberType.name, \" once.\"), getUnionMemberTypeNodes(union, memberType.name));\n      continue;\n    }\n\n    includedTypeNames[memberType.name] = true;\n\n    if (!isObjectType(memberType)) {\n      context.reportError(\"Union type \".concat(union.name, \" can only include Object types, \") + \"it cannot include \".concat(inspect(memberType), \".\"), getUnionMemberTypeNodes(union, String(memberType)));\n    }\n  }\n}\n\nfunction validateEnumValues(context, enumType) {\n  var enumValues = enumType.getValues();\n\n  if (enumValues.length === 0) {\n    context.reportError(\"Enum type \".concat(enumType.name, \" must define one or more values.\"), getAllNodes(enumType));\n  }\n\n  for (var _i26 = 0; _i26 < enumValues.length; _i26++) {\n    var enumValue = enumValues[_i26];\n    var valueName = enumValue.name; // Ensure valid name.\n\n    validateName(context, enumValue);\n\n    if (valueName === 'true' || valueName === 'false' || valueName === 'null') {\n      context.reportError(\"Enum type \".concat(enumType.name, \" cannot include value: \").concat(valueName, \".\"), enumValue.astNode);\n    }\n  }\n}\n\nfunction validateInputFields(context, inputObj) {\n  var fields = objectValues(inputObj.getFields());\n\n  if (fields.length === 0) {\n    context.reportError(\"Input Object type \".concat(inputObj.name, \" must define one or more fields.\"), getAllNodes(inputObj));\n  } // Ensure the arguments are valid\n\n\n  for (var _i28 = 0; _i28 < fields.length; _i28++) {\n    var field = fields[_i28];\n    // Ensure they are named correctly.\n    validateName(context, field); // Ensure the type is an input type\n\n    if (!isInputType(field.type)) {\n      var _field$astNode2;\n\n      context.reportError(\"The type of \".concat(inputObj.name, \".\").concat(field.name, \" must be Input Type \") + \"but got: \".concat(inspect(field.type), \".\"), (_field$astNode2 = field.astNode) === null || _field$astNode2 === void 0 ? void 0 : _field$astNode2.type);\n    }\n\n    if (isRequiredInputField(field) && field.deprecationReason != null) {\n      var _field$astNode3;\n\n      context.reportError(\"Required input field \".concat(inputObj.name, \".\").concat(field.name, \" cannot be deprecated.\"), [getDeprecatedDirectiveNode(field.astNode), // istanbul ignore next (TODO need to write coverage tests)\n      (_field$astNode3 = field.astNode) === null || _field$astNode3 === void 0 ? void 0 : _field$astNode3.type]);\n    }\n  }\n}\n\nfunction createInputObjectCircularRefsValidator(context) {\n  // Modified copy of algorithm from 'src/validation/rules/NoFragmentCycles.js'.\n  // Tracks already visited types to maintain O(N) and to ensure that cycles\n  // are not redundantly reported.\n  var visitedTypes = Object.create(null); // Array of types nodes used to produce meaningful errors\n\n  var fieldPath = []; // Position in the type path\n\n  var fieldPathIndexByTypeName = Object.create(null);\n  return detectCycleRecursive; // This does a straight-forward DFS to find cycles.\n  // It does not terminate when a cycle was found but continues to explore\n  // the graph to find all possible cycles.\n\n  function detectCycleRecursive(inputObj) {\n    if (visitedTypes[inputObj.name]) {\n      return;\n    }\n\n    visitedTypes[inputObj.name] = true;\n    fieldPathIndexByTypeName[inputObj.name] = fieldPath.length;\n    var fields = objectValues(inputObj.getFields());\n\n    for (var _i30 = 0; _i30 < fields.length; _i30++) {\n      var field = fields[_i30];\n\n      if (isNonNullType(field.type) && isInputObjectType(field.type.ofType)) {\n        var fieldType = field.type.ofType;\n        var cycleIndex = fieldPathIndexByTypeName[fieldType.name];\n        fieldPath.push(field);\n\n        if (cycleIndex === undefined) {\n          detectCycleRecursive(fieldType);\n        } else {\n          var cyclePath = fieldPath.slice(cycleIndex);\n          var pathStr = cyclePath.map(function (fieldObj) {\n            return fieldObj.name;\n          }).join('.');\n          context.reportError(\"Cannot reference Input Object \\\"\".concat(fieldType.name, \"\\\" within itself through a series of non-null fields: \\\"\").concat(pathStr, \"\\\".\"), cyclePath.map(function (fieldObj) {\n            return fieldObj.astNode;\n          }));\n        }\n\n        fieldPath.pop();\n      }\n    }\n\n    fieldPathIndexByTypeName[inputObj.name] = undefined;\n  }\n}\n\nfunction getAllNodes(object) {\n  var astNode = object.astNode,\n      extensionASTNodes = object.extensionASTNodes;\n  return astNode ? extensionASTNodes ? [astNode].concat(extensionASTNodes) : [astNode] : extensionASTNodes !== null && extensionASTNodes !== void 0 ? extensionASTNodes : [];\n}\n\nfunction getAllSubNodes(object, getter) {\n  var subNodes = [];\n\n  for (var _i32 = 0, _getAllNodes2 = getAllNodes(object); _i32 < _getAllNodes2.length; _i32++) {\n    var _getter;\n\n    var node = _getAllNodes2[_i32];\n    // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n    subNodes = subNodes.concat((_getter = getter(node)) !== null && _getter !== void 0 ? _getter : []);\n  }\n\n  return subNodes;\n}\n\nfunction getAllImplementsInterfaceNodes(type, iface) {\n  return getAllSubNodes(type, function (typeNode) {\n    return typeNode.interfaces;\n  }).filter(function (ifaceNode) {\n    return ifaceNode.name.value === iface.name;\n  });\n}\n\nfunction getUnionMemberTypeNodes(union, typeName) {\n  return getAllSubNodes(union, function (unionNode) {\n    return unionNode.types;\n  }).filter(function (typeNode) {\n    return typeNode.name.value === typeName;\n  });\n}\n\nfunction getDeprecatedDirectiveNode(definitionNode) {\n  var _definitionNode$direc;\n\n  // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n  return definitionNode === null || definitionNode === void 0 ? void 0 : (_definitionNode$direc = definitionNode.directives) === null || _definitionNode$direc === void 0 ? void 0 : _definitionNode$direc.find(function (node) {\n    return node.name.value === GraphQLDeprecatedDirective.name;\n  });\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}