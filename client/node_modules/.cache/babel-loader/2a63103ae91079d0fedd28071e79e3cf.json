{"ast":null,"code":"import{__assign,__extends,__rest}from\"tslib\";import{invariant}from\"../../utilities/globals/index.js\";import{dep}from'optimism';import{equal}from'@wry/equality';import{Trie}from'@wry/trie';import{isReference,makeReference,DeepMerger,maybeDeepFreeze,canUseWeakMap,isNonNullObject}from\"../../utilities/index.js\";import{hasOwn,fieldNameFromStoreName}from\"./helpers.js\";var DELETE=Object.create(null);var delModifier=function delModifier(){return DELETE;};var INVALIDATE=Object.create(null);var EntityStore=function(){function EntityStore(policies,group){var _this=this;this.policies=policies;this.group=group;this.data=Object.create(null);this.rootIds=Object.create(null);this.refs=Object.create(null);this.getFieldValue=function(objectOrReference,storeFieldName){return maybeDeepFreeze(isReference(objectOrReference)?_this.get(objectOrReference.__ref,storeFieldName):objectOrReference&&objectOrReference[storeFieldName]);};this.canRead=function(objOrRef){return isReference(objOrRef)?_this.has(objOrRef.__ref):typeof objOrRef===\"object\";};this.toReference=function(objOrIdOrRef,mergeIntoStore){if(typeof objOrIdOrRef===\"string\"){return makeReference(objOrIdOrRef);}if(isReference(objOrIdOrRef)){return objOrIdOrRef;}var id=_this.policies.identify(objOrIdOrRef)[0];if(id){var ref=makeReference(id);if(mergeIntoStore){_this.merge(id,objOrIdOrRef);}return ref;}};}EntityStore.prototype.toObject=function(){return __assign({},this.data);};EntityStore.prototype.has=function(dataId){return this.lookup(dataId,true)!==void 0;};EntityStore.prototype.get=function(dataId,fieldName){this.group.depend(dataId,fieldName);if(hasOwn.call(this.data,dataId)){var storeObject=this.data[dataId];if(storeObject&&hasOwn.call(storeObject,fieldName)){return storeObject[fieldName];}}if(fieldName===\"__typename\"&&hasOwn.call(this.policies.rootTypenamesById,dataId)){return this.policies.rootTypenamesById[dataId];}if(this instanceof Layer){return this.parent.get(dataId,fieldName);}};EntityStore.prototype.lookup=function(dataId,dependOnExistence){if(dependOnExistence)this.group.depend(dataId,\"__exists\");if(hasOwn.call(this.data,dataId)){return this.data[dataId];}if(this instanceof Layer){return this.parent.lookup(dataId,dependOnExistence);}if(this.policies.rootTypenamesById[dataId]){return Object.create(null);}};EntityStore.prototype.merge=function(older,newer){var _this=this;var dataId;if(isReference(older))older=older.__ref;if(isReference(newer))newer=newer.__ref;var existing=typeof older===\"string\"?this.lookup(dataId=older):older;var incoming=typeof newer===\"string\"?this.lookup(dataId=newer):newer;if(!incoming)return;__DEV__?invariant(typeof dataId===\"string\",\"store.merge expects a string ID\"):invariant(typeof dataId===\"string\",1);var merged=new DeepMerger(storeObjectReconciler).merge(existing,incoming);this.data[dataId]=merged;if(merged!==existing){delete this.refs[dataId];if(this.group.caching){var fieldsToDirty_1=Object.create(null);if(!existing)fieldsToDirty_1.__exists=1;Object.keys(incoming).forEach(function(storeFieldName){if(!existing||existing[storeFieldName]!==merged[storeFieldName]){fieldsToDirty_1[storeFieldName]=1;var fieldName=fieldNameFromStoreName(storeFieldName);if(fieldName!==storeFieldName&&!_this.policies.hasKeyArgs(merged.__typename,fieldName)){fieldsToDirty_1[fieldName]=1;}if(merged[storeFieldName]===void 0&&!(_this instanceof Layer)){delete merged[storeFieldName];}}});if(fieldsToDirty_1.__typename&&!(existing&&existing.__typename)&&this.policies.rootTypenamesById[dataId]===merged.__typename){delete fieldsToDirty_1.__typename;}Object.keys(fieldsToDirty_1).forEach(function(fieldName){return _this.group.dirty(dataId,fieldName);});}}};EntityStore.prototype.modify=function(dataId,fields){var _this=this;var storeObject=this.lookup(dataId);if(storeObject){var changedFields_1=Object.create(null);var needToMerge_1=false;var allDeleted_1=true;var sharedDetails_1={DELETE:DELETE,INVALIDATE:INVALIDATE,isReference:isReference,toReference:this.toReference,canRead:this.canRead,readField:function readField(fieldNameOrOptions,from){return _this.policies.readField(typeof fieldNameOrOptions===\"string\"?{fieldName:fieldNameOrOptions,from:from||makeReference(dataId)}:fieldNameOrOptions,{store:_this});}};Object.keys(storeObject).forEach(function(storeFieldName){var fieldName=fieldNameFromStoreName(storeFieldName);var fieldValue=storeObject[storeFieldName];if(fieldValue===void 0)return;var modify=typeof fields===\"function\"?fields:fields[storeFieldName]||fields[fieldName];if(modify){var newValue=modify===delModifier?DELETE:modify(maybeDeepFreeze(fieldValue),__assign(__assign({},sharedDetails_1),{fieldName:fieldName,storeFieldName:storeFieldName,storage:_this.getStorage(dataId,storeFieldName)}));if(newValue===INVALIDATE){_this.group.dirty(dataId,storeFieldName);}else{if(newValue===DELETE)newValue=void 0;if(newValue!==fieldValue){changedFields_1[storeFieldName]=newValue;needToMerge_1=true;fieldValue=newValue;}}}if(fieldValue!==void 0){allDeleted_1=false;}});if(needToMerge_1){this.merge(dataId,changedFields_1);if(allDeleted_1){if(this instanceof Layer){this.data[dataId]=void 0;}else{delete this.data[dataId];}this.group.dirty(dataId,\"__exists\");}return true;}}return false;};EntityStore.prototype.delete=function(dataId,fieldName,args){var _a;var storeObject=this.lookup(dataId);if(storeObject){var typename=this.getFieldValue(storeObject,\"__typename\");var storeFieldName=fieldName&&args?this.policies.getStoreFieldName({typename:typename,fieldName:fieldName,args:args}):fieldName;return this.modify(dataId,storeFieldName?(_a={},_a[storeFieldName]=delModifier,_a):delModifier);}return false;};EntityStore.prototype.evict=function(options,limit){var evicted=false;if(options.id){if(hasOwn.call(this.data,options.id)){evicted=this.delete(options.id,options.fieldName,options.args);}if(this instanceof Layer&&this!==limit){evicted=this.parent.evict(options,limit)||evicted;}if(options.fieldName||evicted){this.group.dirty(options.id,options.fieldName||\"__exists\");}}return evicted;};EntityStore.prototype.clear=function(){this.replace(null);};EntityStore.prototype.extract=function(){var _this=this;var obj=this.toObject();var extraRootIds=[];this.getRootIdSet().forEach(function(id){if(!hasOwn.call(_this.policies.rootTypenamesById,id)){extraRootIds.push(id);}});if(extraRootIds.length){obj.__META={extraRootIds:extraRootIds.sort()};}return obj;};EntityStore.prototype.replace=function(newData){var _this=this;Object.keys(this.data).forEach(function(dataId){if(!(newData&&hasOwn.call(newData,dataId))){_this.delete(dataId);}});if(newData){var __META=newData.__META,rest_1=__rest(newData,[\"__META\"]);Object.keys(rest_1).forEach(function(dataId){_this.merge(dataId,rest_1[dataId]);});if(__META){__META.extraRootIds.forEach(this.retain,this);}}};EntityStore.prototype.retain=function(rootId){return this.rootIds[rootId]=(this.rootIds[rootId]||0)+1;};EntityStore.prototype.release=function(rootId){if(this.rootIds[rootId]>0){var count=--this.rootIds[rootId];if(!count)delete this.rootIds[rootId];return count;}return 0;};EntityStore.prototype.getRootIdSet=function(ids){if(ids===void 0){ids=new Set();}Object.keys(this.rootIds).forEach(ids.add,ids);if(this instanceof Layer){this.parent.getRootIdSet(ids);}else{Object.keys(this.policies.rootTypenamesById).forEach(ids.add,ids);}return ids;};EntityStore.prototype.gc=function(){var _this=this;var ids=this.getRootIdSet();var snapshot=this.toObject();ids.forEach(function(id){if(hasOwn.call(snapshot,id)){Object.keys(_this.findChildRefIds(id)).forEach(ids.add,ids);delete snapshot[id];}});var idsToRemove=Object.keys(snapshot);if(idsToRemove.length){var root_1=this;while(root_1 instanceof Layer){root_1=root_1.parent;}idsToRemove.forEach(function(id){return root_1.delete(id);});}return idsToRemove;};EntityStore.prototype.findChildRefIds=function(dataId){if(!hasOwn.call(this.refs,dataId)){var found_1=this.refs[dataId]=Object.create(null);var root=this.data[dataId];if(!root)return found_1;var workSet_1=new Set([root]);workSet_1.forEach(function(obj){if(isReference(obj)){found_1[obj.__ref]=true;}if(isNonNullObject(obj)){Object.keys(obj).forEach(function(key){var child=obj[key];if(isNonNullObject(child)){workSet_1.add(child);}});}});}return this.refs[dataId];};EntityStore.prototype.makeCacheKey=function(){return this.group.keyMaker.lookupArray(arguments);};return EntityStore;}();export{EntityStore};var CacheGroup=function(){function CacheGroup(caching,parent){if(parent===void 0){parent=null;}this.caching=caching;this.parent=parent;this.d=null;this.resetCaching();}CacheGroup.prototype.resetCaching=function(){this.d=this.caching?dep():null;this.keyMaker=new Trie(canUseWeakMap);};CacheGroup.prototype.depend=function(dataId,storeFieldName){if(this.d){this.d(makeDepKey(dataId,storeFieldName));var fieldName=fieldNameFromStoreName(storeFieldName);if(fieldName!==storeFieldName){this.d(makeDepKey(dataId,fieldName));}if(this.parent){this.parent.depend(dataId,storeFieldName);}}};CacheGroup.prototype.dirty=function(dataId,storeFieldName){if(this.d){this.d.dirty(makeDepKey(dataId,storeFieldName),storeFieldName===\"__exists\"?\"forget\":\"setDirty\");}};return CacheGroup;}();function makeDepKey(dataId,storeFieldName){return storeFieldName+'#'+dataId;}export function maybeDependOnExistenceOfEntity(store,entityId){if(supportsResultCaching(store)){store.group.depend(entityId,\"__exists\");}}(function(EntityStore){var Root=function(_super){__extends(Root,_super);function Root(_a){var policies=_a.policies,_b=_a.resultCaching,resultCaching=_b===void 0?true:_b,seed=_a.seed;var _this=_super.call(this,policies,new CacheGroup(resultCaching))||this;_this.stump=new Stump(_this);_this.storageTrie=new Trie(canUseWeakMap);if(seed)_this.replace(seed);return _this;}Root.prototype.addLayer=function(layerId,replay){return this.stump.addLayer(layerId,replay);};Root.prototype.removeLayer=function(){return this;};Root.prototype.getStorage=function(){return this.storageTrie.lookupArray(arguments);};return Root;}(EntityStore);EntityStore.Root=Root;})(EntityStore||(EntityStore={}));var Layer=function(_super){__extends(Layer,_super);function Layer(id,parent,replay,group){var _this=_super.call(this,parent.policies,group)||this;_this.id=id;_this.parent=parent;_this.replay=replay;_this.group=group;replay(_this);return _this;}Layer.prototype.addLayer=function(layerId,replay){return new Layer(layerId,this,replay,this.group);};Layer.prototype.removeLayer=function(layerId){var _this=this;var parent=this.parent.removeLayer(layerId);if(layerId===this.id){if(this.group.caching){Object.keys(this.data).forEach(function(dataId){var ownStoreObject=_this.data[dataId];var parentStoreObject=parent[\"lookup\"](dataId);if(!parentStoreObject){_this.delete(dataId);}else if(!ownStoreObject){_this.group.dirty(dataId,\"__exists\");Object.keys(parentStoreObject).forEach(function(storeFieldName){_this.group.dirty(dataId,storeFieldName);});}else if(ownStoreObject!==parentStoreObject){Object.keys(ownStoreObject).forEach(function(storeFieldName){if(!equal(ownStoreObject[storeFieldName],parentStoreObject[storeFieldName])){_this.group.dirty(dataId,storeFieldName);}});}});}return parent;}if(parent===this.parent)return this;return parent.addLayer(this.id,this.replay);};Layer.prototype.toObject=function(){return __assign(__assign({},this.parent.toObject()),this.data);};Layer.prototype.findChildRefIds=function(dataId){var fromParent=this.parent.findChildRefIds(dataId);return hasOwn.call(this.data,dataId)?__assign(__assign({},fromParent),_super.prototype.findChildRefIds.call(this,dataId)):fromParent;};Layer.prototype.getStorage=function(){var p=this.parent;while(p.parent){p=p.parent;}return p.getStorage.apply(p,arguments);};return Layer;}(EntityStore);var Stump=function(_super){__extends(Stump,_super);function Stump(root){return _super.call(this,\"EntityStore.Stump\",root,function(){},new CacheGroup(root.group.caching,root.group))||this;}Stump.prototype.removeLayer=function(){return this;};Stump.prototype.merge=function(){return this.parent.merge.apply(this.parent,arguments);};return Stump;}(Layer);function storeObjectReconciler(existingObject,incomingObject,property){var existingValue=existingObject[property];var incomingValue=incomingObject[property];return equal(existingValue,incomingValue)?existingValue:incomingValue;}export function supportsResultCaching(store){return!!(store instanceof EntityStore&&store.group.caching);}","map":{"version":3,"mappings":"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","names":["invariant","dep","equal","Trie","isReference","makeReference","DeepMerger","maybeDeepFreeze","canUseWeakMap","isNonNullObject","hasOwn","fieldNameFromStoreName","DELETE","Object","create","delModifier","INVALIDATE","policies","group","objectOrReference","storeFieldName","_this","get","__ref","objOrRef","has","objOrIdOrRef","mergeIntoStore","identify","id","ref","merge","EntityStore","data","dataId","lookup","fieldName","depend","call","storeObject","rootTypenamesById","Layer","parent","dependOnExistence","older","newer","existing","incoming","__DEV__","merged","storeObjectReconciler","refs","caching","fieldsToDirty_1","__exists","keys","forEach","hasKeyArgs","__typename","dirty","fields","changedFields_1","needToMerge_1","allDeleted_1","sharedDetails_1","toReference","canRead","readField","fieldNameOrOptions","from","store","fieldValue","modify","newValue","__assign","storage","getStorage","args","typename","getFieldValue","getStoreFieldName","_a","options","limit","evicted","delete","evict","replace","obj","toObject","extraRootIds","getRootIdSet","push","length","__META","sort","newData","rest_1","retain","rootId","rootIds","count","ids","Set","add","snapshot","findChildRefIds","idsToRemove","root_1","found_1","root","workSet_1","child","key","keyMaker","lookupArray","arguments","resetCaching","CacheGroup","d","makeDepKey","maybeDependOnExistenceOfEntity","entityId","supportsResultCaching","__extends","_b","seed","_super","resultCaching","Stump","Root","layerId","replay","stump","addLayer","storageTrie","removeLayer","ownStoreObject","parentStoreObject","fromParent","p","apply","existingObject","incomingObject","property","existingValue","incomingValue"],"sourceRoot":"","sources":["../../../src/cache/inmemory/entityStore.ts"],"sourcesContent":["import { invariant } from '../../utilities/globals';\nimport { dep, OptimisticDependencyFunction } from 'optimism';\nimport { equal } from '@wry/equality';\nimport { Trie } from '@wry/trie';\n\nimport {\n  isReference,\n  StoreValue,\n  StoreObject,\n  Reference,\n  makeReference,\n  DeepMerger,\n  maybeDeepFreeze,\n  canUseWeakMap,\n  isNonNullObject,\n} from '../../utilities';\nimport { NormalizedCache, NormalizedCacheObject } from './types';\nimport { hasOwn, fieldNameFromStoreName } from './helpers';\nimport { Policies, StorageType } from './policies';\nimport { Cache } from '../core/types/Cache';\nimport {\n  SafeReadonly,\n  Modifier,\n  Modifiers,\n  ReadFieldOptions,\n  ToReferenceFunction,\n  CanReadFunction,\n} from '../core/types/common';\n\nconst DELETE: any = Object.create(null);\nconst delModifier: Modifier<any> = () => DELETE;\nconst INVALIDATE: any = Object.create(null);\n\nexport abstract class EntityStore implements NormalizedCache {\n  protected data: NormalizedCacheObject = Object.create(null);\n\n  constructor(\n    public readonly policies: Policies,\n    public readonly group: CacheGroup,\n  ) {}\n\n  public abstract addLayer(\n    layerId: string,\n    replay: (layer: EntityStore) => any,\n  ): Layer;\n\n  public abstract removeLayer(layerId: string): EntityStore;\n\n  // Although the EntityStore class is abstract, it contains concrete\n  // implementations of the various NormalizedCache interface methods that\n  // are inherited by the Root and Layer subclasses.\n\n  public toObject(): NormalizedCacheObject {\n    return { ...this.data };\n  }\n\n  public has(dataId: string): boolean {\n    return this.lookup(dataId, true) !== void 0;\n  }\n\n  public get(dataId: string, fieldName: string): StoreValue {\n    this.group.depend(dataId, fieldName);\n    if (hasOwn.call(this.data, dataId)) {\n      const storeObject = this.data[dataId];\n      if (storeObject && hasOwn.call(storeObject, fieldName)) {\n        return storeObject[fieldName];\n      }\n    }\n    if (fieldName === \"__typename\" &&\n        hasOwn.call(this.policies.rootTypenamesById, dataId)) {\n      return this.policies.rootTypenamesById[dataId];\n    }\n    if (this instanceof Layer) {\n      return this.parent.get(dataId, fieldName);\n    }\n  }\n\n  protected lookup(dataId: string, dependOnExistence?: boolean): StoreObject | undefined {\n    // The has method (above) calls lookup with dependOnExistence = true, so\n    // that it can later be invalidated when we add or remove a StoreObject for\n    // this dataId. Any consumer who cares about the contents of the StoreObject\n    // should not rely on this dependency, since the contents could change\n    // without the object being added or removed.\n    if (dependOnExistence) this.group.depend(dataId, \"__exists\");\n\n    if (hasOwn.call(this.data, dataId)) {\n      return this.data[dataId];\n    }\n\n    if (this instanceof Layer) {\n      return this.parent.lookup(dataId, dependOnExistence);\n    }\n\n    if (this.policies.rootTypenamesById[dataId]) {\n      return Object.create(null);\n    }\n  }\n\n  public merge(\n    older: string | StoreObject,\n    newer: StoreObject | string,\n  ): void {\n    let dataId: string | undefined;\n\n    // Convert unexpected references to ID strings.\n    if (isReference(older)) older = older.__ref;\n    if (isReference(newer)) newer = newer.__ref;\n\n    const existing: StoreObject | undefined =\n      typeof older === \"string\"\n        ? this.lookup(dataId = older)\n        : older;\n\n    const incoming: StoreObject | undefined =\n      typeof newer === \"string\"\n        ? this.lookup(dataId = newer)\n        : newer;\n\n    // If newer was a string ID, but that ID was not defined in this store,\n    // then there are no fields to be merged, so we're done.\n    if (!incoming) return;\n\n    invariant(\n      typeof dataId === \"string\",\n      \"store.merge expects a string ID\",\n    );\n\n    const merged: StoreObject =\n      new DeepMerger(storeObjectReconciler).merge(existing, incoming);\n\n    // Even if merged === existing, existing may have come from a lower\n    // layer, so we always need to set this.data[dataId] on this level.\n    this.data[dataId] = merged;\n\n    if (merged !== existing) {\n      delete this.refs[dataId];\n      if (this.group.caching) {\n        const fieldsToDirty: Record<string, 1> = Object.create(null);\n\n        // If we added a new StoreObject where there was previously none, dirty\n        // anything that depended on the existence of this dataId, such as the\n        // EntityStore#has method.\n        if (!existing) fieldsToDirty.__exists = 1;\n\n        // Now invalidate dependents who called getFieldValue for any fields\n        // that are changing as a result of this merge.\n        Object.keys(incoming).forEach(storeFieldName => {\n          if (!existing || existing[storeFieldName] !== merged[storeFieldName]) {\n            // Always dirty the full storeFieldName, which may include\n            // serialized arguments following the fieldName prefix.\n            fieldsToDirty[storeFieldName] = 1;\n\n            // Also dirty fieldNameFromStoreName(storeFieldName) if it's\n            // different from storeFieldName and this field does not have\n            // keyArgs configured, because that means the cache can't make\n            // any assumptions about how field values with the same field\n            // name but different arguments might be interrelated, so it\n            // must err on the side of invalidating all field values that\n            // share the same short fieldName, regardless of arguments.\n            const fieldName = fieldNameFromStoreName(storeFieldName);\n            if (fieldName !== storeFieldName &&\n                !this.policies.hasKeyArgs(merged.__typename, fieldName)) {\n              fieldsToDirty[fieldName] = 1;\n            }\n\n            // If merged[storeFieldName] has become undefined, and this is the\n            // Root layer, actually delete the property from the merged object,\n            // which is guaranteed to have been created fresh in this method.\n            if (merged[storeFieldName] === void 0 && !(this instanceof Layer)) {\n              delete merged[storeFieldName];\n            }\n          }\n        });\n\n        if (fieldsToDirty.__typename &&\n            !(existing && existing.__typename) &&\n            // Since we return default root __typename strings\n            // automatically from store.get, we don't need to dirty the\n            // ROOT_QUERY.__typename field if merged.__typename is equal\n            // to the default string (usually \"Query\").\n            this.policies.rootTypenamesById[dataId] === merged.__typename) {\n          delete fieldsToDirty.__typename;\n        }\n\n        Object.keys(fieldsToDirty).forEach(\n          fieldName => this.group.dirty(dataId as string, fieldName));\n      }\n    }\n  }\n\n  public modify(\n    dataId: string,\n    fields: Modifier<any> | Modifiers,\n  ): boolean {\n    const storeObject = this.lookup(dataId);\n\n    if (storeObject) {\n      const changedFields: Record<string, any> = Object.create(null);\n      let needToMerge = false;\n      let allDeleted = true;\n\n      const sharedDetails = {\n        DELETE,\n        INVALIDATE,\n        isReference,\n        toReference: this.toReference,\n        canRead: this.canRead,\n        readField: <V = StoreValue>(\n          fieldNameOrOptions: string | ReadFieldOptions,\n          from?: StoreObject | Reference,\n        ) => this.policies.readField<V>(\n          typeof fieldNameOrOptions === \"string\" ? {\n            fieldName: fieldNameOrOptions,\n            from: from || makeReference(dataId),\n          } : fieldNameOrOptions,\n          { store: this },\n        ),\n      };\n\n      Object.keys(storeObject).forEach(storeFieldName => {\n        const fieldName = fieldNameFromStoreName(storeFieldName);\n        let fieldValue = storeObject[storeFieldName];\n        if (fieldValue === void 0) return;\n        const modify: Modifier<StoreValue> = typeof fields === \"function\"\n          ? fields\n          : fields[storeFieldName] || fields[fieldName];\n        if (modify) {\n          let newValue = modify === delModifier ? DELETE :\n            modify(maybeDeepFreeze(fieldValue), {\n              ...sharedDetails,\n              fieldName,\n              storeFieldName,\n              storage: this.getStorage(dataId, storeFieldName),\n            });\n          if (newValue === INVALIDATE) {\n            this.group.dirty(dataId, storeFieldName);\n          } else {\n            if (newValue === DELETE) newValue = void 0;\n            if (newValue !== fieldValue) {\n              changedFields[storeFieldName] = newValue;\n              needToMerge = true;\n              fieldValue = newValue;\n            }\n          }\n        }\n        if (fieldValue !== void 0) {\n          allDeleted = false;\n        }\n      });\n\n      if (needToMerge) {\n        this.merge(dataId, changedFields);\n\n        if (allDeleted) {\n          if (this instanceof Layer) {\n            this.data[dataId] = void 0;\n          } else {\n            delete this.data[dataId];\n          }\n          this.group.dirty(dataId, \"__exists\");\n        }\n\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  // If called with only one argument, removes the entire entity\n  // identified by dataId. If called with a fieldName as well, removes all\n  // fields of that entity whose names match fieldName according to the\n  // fieldNameFromStoreName helper function. If called with a fieldName\n  // and variables, removes all fields of that entity whose names match fieldName\n  // and whose arguments when cached exactly match the variables passed.\n  public delete(\n    dataId: string,\n    fieldName?: string,\n    args?: Record<string, any>,\n  ) {\n    const storeObject = this.lookup(dataId);\n    if (storeObject) {\n      const typename = this.getFieldValue<string>(storeObject, \"__typename\");\n      const storeFieldName = fieldName && args\n        ? this.policies.getStoreFieldName({ typename, fieldName, args })\n        : fieldName;\n      return this.modify(dataId, storeFieldName ? {\n        [storeFieldName]: delModifier,\n      } : delModifier);\n    }\n    return false;\n  }\n\n  public evict(\n    options: Cache.EvictOptions,\n    limit: EntityStore,\n  ): boolean {\n    let evicted = false;\n    if (options.id) {\n      if (hasOwn.call(this.data, options.id)) {\n        evicted = this.delete(options.id, options.fieldName, options.args);\n      }\n      if (this instanceof Layer && this !== limit) {\n        evicted = this.parent.evict(options, limit) || evicted;\n      }\n      // Always invalidate the field to trigger rereading of watched\n      // queries, even if no cache data was modified by the eviction,\n      // because queries may depend on computed fields with custom read\n      // functions, whose values are not stored in the EntityStore.\n      if (options.fieldName || evicted) {\n        this.group.dirty(options.id, options.fieldName || \"__exists\");\n      }\n    }\n    return evicted;\n  }\n\n  public clear(): void {\n    this.replace(null);\n  }\n\n  public extract(): NormalizedCacheObject {\n    const obj = this.toObject();\n    const extraRootIds: string[] = [];\n    this.getRootIdSet().forEach(id => {\n      if (!hasOwn.call(this.policies.rootTypenamesById, id)) {\n        extraRootIds.push(id);\n      }\n    });\n    if (extraRootIds.length) {\n      obj.__META = { extraRootIds: extraRootIds.sort() };\n    }\n    return obj;\n  }\n\n  public replace(newData: NormalizedCacheObject | null): void {\n    Object.keys(this.data).forEach(dataId => {\n      if (!(newData && hasOwn.call(newData, dataId))) {\n        this.delete(dataId);\n      }\n    });\n    if (newData) {\n      const { __META, ...rest } = newData;\n      Object.keys(rest).forEach(dataId => {\n        this.merge(dataId, rest[dataId] as StoreObject);\n      });\n      if (__META) {\n        __META.extraRootIds.forEach(this.retain, this);\n      }\n    }\n  }\n\n  public abstract getStorage(\n    idOrObj: string | StoreObject,\n    ...storeFieldNames: (string | number)[]\n  ): StorageType;\n\n  // Maps root entity IDs to the number of times they have been retained, minus\n  // the number of times they have been released. Retained entities keep other\n  // entities they reference (even indirectly) from being garbage collected.\n  private rootIds: {\n    [rootId: string]: number;\n  } = Object.create(null);\n\n  public retain(rootId: string): number {\n    return this.rootIds[rootId] = (this.rootIds[rootId] || 0) + 1;\n  }\n\n  public release(rootId: string): number {\n    if (this.rootIds[rootId] > 0) {\n      const count = --this.rootIds[rootId];\n      if (!count) delete this.rootIds[rootId];\n      return count;\n    }\n    return 0;\n  }\n\n  // Return a Set<string> of all the ID strings that have been retained by\n  // this layer/root *and* any layers/roots beneath it.\n  public getRootIdSet(ids = new Set<string>()) {\n    Object.keys(this.rootIds).forEach(ids.add, ids);\n    if (this instanceof Layer) {\n      this.parent.getRootIdSet(ids);\n    } else {\n      // Official singleton IDs like ROOT_QUERY and ROOT_MUTATION are\n      // always considered roots for garbage collection, regardless of\n      // their retainment counts in this.rootIds.\n      Object.keys(this.policies.rootTypenamesById).forEach(ids.add, ids);\n    }\n    return ids;\n  }\n\n  // The goal of garbage collection is to remove IDs from the Root layer of the\n  // store that are no longer reachable starting from any IDs that have been\n  // explicitly retained (see retain and release, above). Returns an array of\n  // dataId strings that were removed from the store.\n  public gc() {\n    const ids = this.getRootIdSet();\n    const snapshot = this.toObject();\n    ids.forEach(id => {\n      if (hasOwn.call(snapshot, id)) {\n        // Because we are iterating over an ECMAScript Set, the IDs we add here\n        // will be visited in later iterations of the forEach loop only if they\n        // were not previously contained by the Set.\n        Object.keys(this.findChildRefIds(id)).forEach(ids.add, ids);\n        // By removing IDs from the snapshot object here, we protect them from\n        // getting removed from the root store layer below.\n        delete snapshot[id];\n      }\n    });\n    const idsToRemove = Object.keys(snapshot);\n    if (idsToRemove.length) {\n      let root: EntityStore = this;\n      while (root instanceof Layer) root = root.parent;\n      idsToRemove.forEach(id => root.delete(id));\n    }\n    return idsToRemove;\n  }\n\n  // Lazily tracks { __ref: <dataId> } strings contained by this.data[dataId].\n  private refs: {\n    [dataId: string]: Record<string, true>;\n  } = Object.create(null);\n\n  public findChildRefIds(dataId: string): Record<string, true> {\n    if (!hasOwn.call(this.refs, dataId)) {\n      const found = this.refs[dataId] = Object.create(null);\n      const root = this.data[dataId];\n      if (!root) return found;\n\n      const workSet = new Set<Record<string | number, any>>([root]);\n      // Within the store, only arrays and objects can contain child entity\n      // references, so we can prune the traversal using this predicate:\n      workSet.forEach(obj => {\n        if (isReference(obj)) {\n          found[obj.__ref] = true;\n          // In rare cases, a { __ref } Reference object may have other fields.\n          // This often indicates a mismerging of References with StoreObjects,\n          // but garbage collection should not be fooled by a stray __ref\n          // property in a StoreObject (ignoring all the other fields just\n          // because the StoreObject looks like a Reference). To avoid this\n          // premature termination of findChildRefIds recursion, we fall through\n          // to the code below, which will handle any other properties of obj.\n        }\n        if (isNonNullObject(obj)) {\n          Object.keys(obj).forEach(key => {\n            const child = obj[key];\n            // No need to add primitive values to the workSet, since they cannot\n            // contain reference objects.\n            if (isNonNullObject(child)) {\n              workSet.add(child);\n            }\n          });\n        }\n      });\n    }\n    return this.refs[dataId];\n  }\n\n  // Used to compute cache keys specific to this.group.\n  public makeCacheKey(...args: any[]): object;\n  public makeCacheKey() {\n    return this.group.keyMaker.lookupArray(arguments);\n  }\n\n  // Bound function that can be passed around to provide easy access to fields\n  // of Reference objects as well as ordinary objects.\n  public getFieldValue = <T = StoreValue>(\n    objectOrReference: StoreObject | Reference | undefined,\n    storeFieldName: string,\n  ) => maybeDeepFreeze(\n    isReference(objectOrReference)\n      ? this.get(objectOrReference.__ref, storeFieldName)\n      : objectOrReference && objectOrReference[storeFieldName]\n  ) as SafeReadonly<T>;\n\n  // Returns true for non-normalized StoreObjects and non-dangling\n  // References, indicating that readField(name, objOrRef) has a chance of\n  // working. Useful for filtering out dangling references from lists.\n  public canRead: CanReadFunction = objOrRef => {\n    return isReference(objOrRef)\n      ? this.has(objOrRef.__ref)\n      : typeof objOrRef === \"object\";\n  };\n\n  // Bound function that converts an id or an object with a __typename and\n  // primary key fields to a Reference object. If called with a Reference object,\n  // that same Reference object is returned. Pass true for mergeIntoStore to persist\n  // an object into the store.\n  public toReference: ToReferenceFunction = (\n    objOrIdOrRef,\n    mergeIntoStore,\n  ) => {\n    if (typeof objOrIdOrRef === \"string\") {\n      return makeReference(objOrIdOrRef);\n    }\n\n    if (isReference(objOrIdOrRef)) {\n      return objOrIdOrRef;\n    }\n\n    const [id] = this.policies.identify(objOrIdOrRef);\n\n    if (id) {\n      const ref = makeReference(id);\n      if (mergeIntoStore) {\n        this.merge(id, objOrIdOrRef);\n      }\n      return ref;\n    }\n  };\n}\n\nexport type FieldValueGetter = EntityStore[\"getFieldValue\"];\n\n// A single CacheGroup represents a set of one or more EntityStore objects,\n// typically the Root store in a CacheGroup by itself, and all active Layer\n// stores in a group together. A single EntityStore object belongs to only\n// one CacheGroup, store.group. The CacheGroup is responsible for tracking\n// dependencies, so store.group is helpful for generating unique keys for\n// cached results that need to be invalidated when/if those dependencies\n// change. If we used the EntityStore objects themselves as cache keys (that\n// is, store rather than store.group), the cache would become unnecessarily\n// fragmented by all the different Layer objects. Instead, the CacheGroup\n// approach allows all optimistic Layer objects in the same linked list to\n// belong to one CacheGroup, with the non-optimistic Root object belonging\n// to another CacheGroup, allowing resultCaching dependencies to be tracked\n// separately for optimistic and non-optimistic entity data.\nclass CacheGroup {\n  private d: OptimisticDependencyFunction<string> | null = null;\n\n  // Used by the EntityStore#makeCacheKey method to compute cache keys\n  // specific to this CacheGroup.\n  public keyMaker: Trie<object>;\n\n  constructor(\n    public readonly caching: boolean,\n    private parent: CacheGroup | null = null,\n  ) {\n    this.resetCaching();\n  }\n\n  public resetCaching() {\n    this.d = this.caching ? dep<string>() : null;\n    this.keyMaker = new Trie(canUseWeakMap);\n  }\n\n  public depend(dataId: string, storeFieldName: string) {\n    if (this.d) {\n      this.d(makeDepKey(dataId, storeFieldName));\n      const fieldName = fieldNameFromStoreName(storeFieldName);\n      if (fieldName !== storeFieldName) {\n        // Fields with arguments that contribute extra identifying\n        // information to the fieldName (thus forming the storeFieldName)\n        // depend not only on the full storeFieldName but also on the\n        // short fieldName, so the field can be invalidated using either\n        // level of specificity.\n        this.d(makeDepKey(dataId, fieldName));\n      }\n      if (this.parent) {\n        this.parent.depend(dataId, storeFieldName);\n      }\n    }\n  }\n\n  public dirty(dataId: string, storeFieldName: string) {\n    if (this.d) {\n      this.d.dirty(\n        makeDepKey(dataId, storeFieldName),\n        // When storeFieldName === \"__exists\", that means the entity identified\n        // by dataId has either disappeared from the cache or was newly added,\n        // so the result caching system would do well to \"forget everything it\n        // knows\" about that object. To achieve that kind of invalidation, we\n        // not only dirty the associated result cache entry, but also remove it\n        // completely from the dependency graph. For the optimism implementation\n        // details, see https://github.com/benjamn/optimism/pull/195.\n        storeFieldName === \"__exists\" ? \"forget\" : \"setDirty\",\n      );\n    }\n  }\n}\n\nfunction makeDepKey(dataId: string, storeFieldName: string) {\n  // Since field names cannot have '#' characters in them, this method\n  // of joining the field name and the ID should be unambiguous, and much\n  // cheaper than JSON.stringify([dataId, fieldName]).\n  return storeFieldName + '#' + dataId;\n}\n\nexport function maybeDependOnExistenceOfEntity(\n  store: NormalizedCache,\n  entityId: string,\n) {\n  if (supportsResultCaching(store)) {\n    // We use this pseudo-field __exists elsewhere in the EntityStore code to\n    // represent changes in the existence of the entity object identified by\n    // entityId. This dependency gets reliably dirtied whenever an object with\n    // this ID is deleted (or newly created) within this group, so any result\n    // cache entries (for example, StoreReader#executeSelectionSet results) that\n    // depend on __exists for this entityId will get dirtied as well, leading to\n    // the eventual recomputation (instead of reuse) of those result objects the\n    // next time someone reads them from the cache.\n    store.group.depend(entityId, \"__exists\");\n  }\n}\n\nexport namespace EntityStore {\n  // Refer to this class as EntityStore.Root outside this namespace.\n  export class Root extends EntityStore {\n    constructor({\n      policies,\n      resultCaching = true,\n      seed,\n    }: {\n      policies: Policies;\n      resultCaching?: boolean;\n      seed?: NormalizedCacheObject;\n    }) {\n      super(policies, new CacheGroup(resultCaching));\n      if (seed) this.replace(seed);\n    }\n\n    public readonly stump = new Stump(this);\n\n    public addLayer(\n      layerId: string,\n      replay: (layer: EntityStore) => any,\n    ): Layer {\n      // Adding an optimistic Layer on top of the Root actually adds the Layer\n      // on top of the Stump, so the Stump always comes between the Root and\n      // any Layer objects that we've added.\n      return this.stump.addLayer(layerId, replay);\n    }\n\n    public removeLayer(): Root {\n      // Never remove the root layer.\n      return this;\n    }\n\n    public readonly storageTrie = new Trie<StorageType>(canUseWeakMap);\n    public getStorage(): StorageType {\n      return this.storageTrie.lookupArray(arguments);\n    }\n  }\n}\n\n// Not exported, since all Layer instances are created by the addLayer method\n// of the EntityStore.Root class.\nclass Layer extends EntityStore {\n  constructor(\n    public readonly id: string,\n    public readonly parent: EntityStore,\n    public readonly replay: (layer: EntityStore) => any,\n    public readonly group: CacheGroup,\n  ) {\n    super(parent.policies, group);\n    replay(this);\n  }\n\n  public addLayer(\n    layerId: string,\n    replay: (layer: EntityStore) => any,\n  ): Layer {\n    return new Layer(layerId, this, replay, this.group);\n  }\n\n  public removeLayer(layerId: string): EntityStore {\n    // Remove all instances of the given id, not just the first one.\n    const parent = this.parent.removeLayer(layerId);\n\n    if (layerId === this.id) {\n      if (this.group.caching) {\n        // Dirty every ID we're removing. Technically we might be able to avoid\n        // dirtying fields that have values in higher layers, but we don't have\n        // easy access to higher layers here, and we're about to recreate those\n        // layers anyway (see parent.addLayer below).\n        Object.keys(this.data).forEach(dataId => {\n          const ownStoreObject = this.data[dataId];\n          const parentStoreObject = parent[\"lookup\"](dataId);\n          if (!parentStoreObject) {\n            // The StoreObject identified by dataId was defined in this layer\n            // but will be undefined in the parent layer, so we can delete the\n            // whole entity using this.delete(dataId). Since we're about to\n            // throw this layer away, the only goal of this deletion is to dirty\n            // the removed fields.\n            this.delete(dataId);\n          } else if (!ownStoreObject) {\n            // This layer had an entry for dataId but it was undefined, which\n            // means the entity was deleted in this layer, and it's about to\n            // become undeleted when we remove this layer, so we need to dirty\n            // all fields that are about to be reexposed.\n            this.group.dirty(dataId, \"__exists\");\n            Object.keys(parentStoreObject).forEach(storeFieldName => {\n              this.group.dirty(dataId, storeFieldName);\n            });\n          } else if (ownStoreObject !== parentStoreObject) {\n            // If ownStoreObject is not exactly the same as parentStoreObject,\n            // dirty any fields whose values will change as a result of this\n            // removal.\n            Object.keys(ownStoreObject).forEach(storeFieldName => {\n              if (!equal(ownStoreObject[storeFieldName],\n                         parentStoreObject[storeFieldName])) {\n                this.group.dirty(dataId, storeFieldName);\n              }\n            });\n          }\n        });\n      }\n\n      return parent;\n    }\n\n    // No changes are necessary if the parent chain remains identical.\n    if (parent === this.parent) return this;\n\n    // Recreate this layer on top of the new parent.\n    return parent.addLayer(this.id, this.replay);\n  }\n\n  public toObject(): NormalizedCacheObject {\n    return {\n      ...this.parent.toObject(),\n      ...this.data,\n    };\n  }\n\n  public findChildRefIds(dataId: string): Record<string, true> {\n    const fromParent = this.parent.findChildRefIds(dataId);\n    return hasOwn.call(this.data, dataId) ? {\n      ...fromParent,\n      ...super.findChildRefIds(dataId),\n    } : fromParent;\n  }\n\n  public getStorage(): StorageType {\n    let p: EntityStore = this.parent;\n    while ((p as Layer).parent) p = (p as Layer).parent;\n    return p.getStorage.apply(p, arguments);\n  }\n}\n\n// Represents a Layer permanently installed just above the Root, which allows\n// reading optimistically (and registering optimistic dependencies) even when\n// no optimistic layers are currently active. The stump.group CacheGroup object\n// is shared by any/all Layer objects added on top of the Stump.\nclass Stump extends Layer {\n  constructor(root: EntityStore.Root) {\n    super(\n      \"EntityStore.Stump\",\n      root,\n      () => {},\n      new CacheGroup(root.group.caching, root.group),\n    );\n  }\n\n  public removeLayer() {\n    // Never remove the Stump layer.\n    return this;\n  }\n\n  public merge() {\n    // We never want to write any data into the Stump, so we forward any merge\n    // calls to the Root instead. Another option here would be to throw an\n    // exception, but the toReference(object, true) function can sometimes\n    // trigger Stump writes (which used to be Root writes, before the Stump\n    // concept was introduced).\n    return this.parent.merge.apply(this.parent, arguments);\n  }\n}\n\nfunction storeObjectReconciler(\n  existingObject: StoreObject,\n  incomingObject: StoreObject,\n  property: string,\n): StoreValue {\n  const existingValue = existingObject[property];\n  const incomingValue = incomingObject[property];\n  // Wherever there is a key collision, prefer the incoming value, unless\n  // it is deeply equal to the existing value. It's worth checking deep\n  // equality here (even though blindly returning incoming would be\n  // logically correct) because preserving the referential identity of\n  // existing data can prevent needless rereading and rerendering.\n  return equal(existingValue, incomingValue) ? existingValue : incomingValue;\n}\n\nexport function supportsResultCaching(store: any): store is EntityStore {\n  // When result caching is disabled, store.depend will be null.\n  return !!(store instanceof EntityStore && store.group.caching);\n}\n"]},"metadata":{},"sourceType":"module"}