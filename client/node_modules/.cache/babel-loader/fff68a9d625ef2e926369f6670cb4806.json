{"ast":null,"code":"import{__assign,__rest}from\"tslib\";import{invariant,InvariantError}from\"../../utilities/globals/index.js\";import{storeKeyNameFromField,argumentsObjectFromField,isReference,getStoreKeyName,isNonNullObject,stringifyForDisplay}from\"../../utilities/index.js\";import{hasOwn,fieldNameFromStoreName,storeValueIsStoreObject,selectionSetMatchesResult,TypeOrFieldNameRegExp,defaultDataIdFromObject,isArray}from\"./helpers.js\";import{cacheSlot}from\"./reactiveVars.js\";import{canonicalStringify}from\"./object-canon.js\";import{keyArgsFnFromSpecifier,keyFieldsFnFromSpecifier}from\"./key-extractor.js\";getStoreKeyName.setStringify(canonicalStringify);function argsFromFieldSpecifier(spec){return spec.args!==void 0?spec.args:spec.field?argumentsObjectFromField(spec.field,spec.variables):null;}var nullKeyFieldsFn=function nullKeyFieldsFn(){return void 0;};var simpleKeyArgsFn=function simpleKeyArgsFn(_args,context){return context.fieldName;};var mergeTrueFn=function mergeTrueFn(existing,incoming,_a){var mergeObjects=_a.mergeObjects;return mergeObjects(existing,incoming);};var mergeFalseFn=function mergeFalseFn(_,incoming){return incoming;};var Policies=function(){function Policies(config){this.config=config;this.typePolicies=Object.create(null);this.toBeAdded=Object.create(null);this.supertypeMap=new Map();this.fuzzySubtypes=new Map();this.rootIdsByTypename=Object.create(null);this.rootTypenamesById=Object.create(null);this.usingPossibleTypes=false;this.config=__assign({dataIdFromObject:defaultDataIdFromObject},config);this.cache=this.config.cache;this.setRootTypename(\"Query\");this.setRootTypename(\"Mutation\");this.setRootTypename(\"Subscription\");if(config.possibleTypes){this.addPossibleTypes(config.possibleTypes);}if(config.typePolicies){this.addTypePolicies(config.typePolicies);}}Policies.prototype.identify=function(object,partialContext){var _a;var policies=this;var typename=partialContext&&(partialContext.typename||((_a=partialContext.storeObject)===null||_a===void 0?void 0:_a.__typename))||object.__typename;if(typename===this.rootTypenamesById.ROOT_QUERY){return[\"ROOT_QUERY\"];}var storeObject=partialContext&&partialContext.storeObject||object;var context=__assign(__assign({},partialContext),{typename:typename,storeObject:storeObject,readField:partialContext&&partialContext.readField||function(){var options=normalizeReadFieldOptions(arguments,storeObject);return policies.readField(options,{store:policies.cache[\"data\"],variables:options.variables});}});var id;var policy=typename&&this.getTypePolicy(typename);var keyFn=policy&&policy.keyFn||this.config.dataIdFromObject;while(keyFn){var specifierOrId=keyFn(object,context);if(isArray(specifierOrId)){keyFn=keyFieldsFnFromSpecifier(specifierOrId);}else{id=specifierOrId;break;}}id=id?String(id):void 0;return context.keyObject?[id,context.keyObject]:[id];};Policies.prototype.addTypePolicies=function(typePolicies){var _this=this;Object.keys(typePolicies).forEach(function(typename){var _a=typePolicies[typename],queryType=_a.queryType,mutationType=_a.mutationType,subscriptionType=_a.subscriptionType,incoming=__rest(_a,[\"queryType\",\"mutationType\",\"subscriptionType\"]);if(queryType)_this.setRootTypename(\"Query\",typename);if(mutationType)_this.setRootTypename(\"Mutation\",typename);if(subscriptionType)_this.setRootTypename(\"Subscription\",typename);if(hasOwn.call(_this.toBeAdded,typename)){_this.toBeAdded[typename].push(incoming);}else{_this.toBeAdded[typename]=[incoming];}});};Policies.prototype.updateTypePolicy=function(typename,incoming){var _this=this;var existing=this.getTypePolicy(typename);var keyFields=incoming.keyFields,fields=incoming.fields;function setMerge(existing,merge){existing.merge=typeof merge===\"function\"?merge:merge===true?mergeTrueFn:merge===false?mergeFalseFn:existing.merge;}setMerge(existing,incoming.merge);existing.keyFn=keyFields===false?nullKeyFieldsFn:isArray(keyFields)?keyFieldsFnFromSpecifier(keyFields):typeof keyFields===\"function\"?keyFields:existing.keyFn;if(fields){Object.keys(fields).forEach(function(fieldName){var existing=_this.getFieldPolicy(typename,fieldName,true);var incoming=fields[fieldName];if(typeof incoming===\"function\"){existing.read=incoming;}else{var keyArgs=incoming.keyArgs,read=incoming.read,merge=incoming.merge;existing.keyFn=keyArgs===false?simpleKeyArgsFn:isArray(keyArgs)?keyArgsFnFromSpecifier(keyArgs):typeof keyArgs===\"function\"?keyArgs:existing.keyFn;if(typeof read===\"function\"){existing.read=read;}setMerge(existing,merge);}if(existing.read&&existing.merge){existing.keyFn=existing.keyFn||simpleKeyArgsFn;}});}};Policies.prototype.setRootTypename=function(which,typename){if(typename===void 0){typename=which;}var rootId=\"ROOT_\"+which.toUpperCase();var old=this.rootTypenamesById[rootId];if(typename!==old){__DEV__?invariant(!old||old===which,\"Cannot change root \".concat(which,\" __typename more than once\")):invariant(!old||old===which,3);if(old)delete this.rootIdsByTypename[old];this.rootIdsByTypename[typename]=rootId;this.rootTypenamesById[rootId]=typename;}};Policies.prototype.addPossibleTypes=function(possibleTypes){var _this=this;this.usingPossibleTypes=true;Object.keys(possibleTypes).forEach(function(supertype){_this.getSupertypeSet(supertype,true);possibleTypes[supertype].forEach(function(subtype){_this.getSupertypeSet(subtype,true).add(supertype);var match=subtype.match(TypeOrFieldNameRegExp);if(!match||match[0]!==subtype){_this.fuzzySubtypes.set(subtype,new RegExp(subtype));}});});};Policies.prototype.getTypePolicy=function(typename){var _this=this;if(!hasOwn.call(this.typePolicies,typename)){var policy_1=this.typePolicies[typename]=Object.create(null);policy_1.fields=Object.create(null);var supertypes=this.supertypeMap.get(typename);if(supertypes&&supertypes.size){supertypes.forEach(function(supertype){var _a=_this.getTypePolicy(supertype),fields=_a.fields,rest=__rest(_a,[\"fields\"]);Object.assign(policy_1,rest);Object.assign(policy_1.fields,fields);});}}var inbox=this.toBeAdded[typename];if(inbox&&inbox.length){inbox.splice(0).forEach(function(policy){_this.updateTypePolicy(typename,policy);});}return this.typePolicies[typename];};Policies.prototype.getFieldPolicy=function(typename,fieldName,createIfMissing){if(typename){var fieldPolicies=this.getTypePolicy(typename).fields;return fieldPolicies[fieldName]||createIfMissing&&(fieldPolicies[fieldName]=Object.create(null));}};Policies.prototype.getSupertypeSet=function(subtype,createIfMissing){var supertypeSet=this.supertypeMap.get(subtype);if(!supertypeSet&&createIfMissing){this.supertypeMap.set(subtype,supertypeSet=new Set());}return supertypeSet;};Policies.prototype.fragmentMatches=function(fragment,typename,result,variables){var _this=this;if(!fragment.typeCondition)return true;if(!typename)return false;var supertype=fragment.typeCondition.name.value;if(typename===supertype)return true;if(this.usingPossibleTypes&&this.supertypeMap.has(supertype)){var typenameSupertypeSet=this.getSupertypeSet(typename,true);var workQueue_1=[typenameSupertypeSet];var maybeEnqueue_1=function maybeEnqueue_1(subtype){var supertypeSet=_this.getSupertypeSet(subtype,false);if(supertypeSet&&supertypeSet.size&&workQueue_1.indexOf(supertypeSet)<0){workQueue_1.push(supertypeSet);}};var needToCheckFuzzySubtypes=!!(result&&this.fuzzySubtypes.size);var checkingFuzzySubtypes=false;for(var i=0;i<workQueue_1.length;++i){var supertypeSet=workQueue_1[i];if(supertypeSet.has(supertype)){if(!typenameSupertypeSet.has(supertype)){if(checkingFuzzySubtypes){__DEV__&&invariant.warn(\"Inferring subtype \".concat(typename,\" of supertype \").concat(supertype));}typenameSupertypeSet.add(supertype);}return true;}supertypeSet.forEach(maybeEnqueue_1);if(needToCheckFuzzySubtypes&&i===workQueue_1.length-1&&selectionSetMatchesResult(fragment.selectionSet,result,variables)){needToCheckFuzzySubtypes=false;checkingFuzzySubtypes=true;this.fuzzySubtypes.forEach(function(regExp,fuzzyString){var match=typename.match(regExp);if(match&&match[0]===typename){maybeEnqueue_1(fuzzyString);}});}}}return false;};Policies.prototype.hasKeyArgs=function(typename,fieldName){var policy=this.getFieldPolicy(typename,fieldName,false);return!!(policy&&policy.keyFn);};Policies.prototype.getStoreFieldName=function(fieldSpec){var typename=fieldSpec.typename,fieldName=fieldSpec.fieldName;var policy=this.getFieldPolicy(typename,fieldName,false);var storeFieldName;var keyFn=policy&&policy.keyFn;if(keyFn&&typename){var context={typename:typename,fieldName:fieldName,field:fieldSpec.field||null,variables:fieldSpec.variables};var args=argsFromFieldSpecifier(fieldSpec);while(keyFn){var specifierOrString=keyFn(args,context);if(isArray(specifierOrString)){keyFn=keyArgsFnFromSpecifier(specifierOrString);}else{storeFieldName=specifierOrString||fieldName;break;}}}if(storeFieldName===void 0){storeFieldName=fieldSpec.field?storeKeyNameFromField(fieldSpec.field,fieldSpec.variables):getStoreKeyName(fieldName,argsFromFieldSpecifier(fieldSpec));}if(storeFieldName===false){return fieldName;}return fieldName===fieldNameFromStoreName(storeFieldName)?storeFieldName:fieldName+\":\"+storeFieldName;};Policies.prototype.readField=function(options,context){var objectOrReference=options.from;if(!objectOrReference)return;var nameOrField=options.field||options.fieldName;if(!nameOrField)return;if(options.typename===void 0){var typename=context.store.getFieldValue(objectOrReference,\"__typename\");if(typename)options.typename=typename;}var storeFieldName=this.getStoreFieldName(options);var fieldName=fieldNameFromStoreName(storeFieldName);var existing=context.store.getFieldValue(objectOrReference,storeFieldName);var policy=this.getFieldPolicy(options.typename,fieldName,false);var read=policy&&policy.read;if(read){var readOptions=makeFieldFunctionOptions(this,objectOrReference,options,context,context.store.getStorage(isReference(objectOrReference)?objectOrReference.__ref:objectOrReference,storeFieldName));return cacheSlot.withValue(this.cache,read,[existing,readOptions]);}return existing;};Policies.prototype.getReadFunction=function(typename,fieldName){var policy=this.getFieldPolicy(typename,fieldName,false);return policy&&policy.read;};Policies.prototype.getMergeFunction=function(parentTypename,fieldName,childTypename){var policy=this.getFieldPolicy(parentTypename,fieldName,false);var merge=policy&&policy.merge;if(!merge&&childTypename){policy=this.getTypePolicy(childTypename);merge=policy&&policy.merge;}return merge;};Policies.prototype.runMergeFunction=function(existing,incoming,_a,context,storage){var field=_a.field,typename=_a.typename,merge=_a.merge;if(merge===mergeTrueFn){return makeMergeObjectsFunction(context.store)(existing,incoming);}if(merge===mergeFalseFn){return incoming;}if(context.overwrite){existing=void 0;}return merge(existing,incoming,makeFieldFunctionOptions(this,void 0,{typename:typename,fieldName:field.name.value,field:field,variables:context.variables},context,storage||Object.create(null)));};return Policies;}();export{Policies};function makeFieldFunctionOptions(policies,objectOrReference,fieldSpec,context,storage){var storeFieldName=policies.getStoreFieldName(fieldSpec);var fieldName=fieldNameFromStoreName(storeFieldName);var variables=fieldSpec.variables||context.variables;var _a=context.store,toReference=_a.toReference,canRead=_a.canRead;return{args:argsFromFieldSpecifier(fieldSpec),field:fieldSpec.field||null,fieldName:fieldName,storeFieldName:storeFieldName,variables:variables,isReference:isReference,toReference:toReference,storage:storage,cache:policies.cache,canRead:canRead,readField:function readField(){return policies.readField(normalizeReadFieldOptions(arguments,objectOrReference,variables),context);},mergeObjects:makeMergeObjectsFunction(context.store)};}export function normalizeReadFieldOptions(readFieldArgs,objectOrReference,variables){var fieldNameOrOptions=readFieldArgs[0],from=readFieldArgs[1],argc=readFieldArgs.length;var options;if(typeof fieldNameOrOptions===\"string\"){options={fieldName:fieldNameOrOptions,from:argc>1?from:objectOrReference};}else{options=__assign({},fieldNameOrOptions);if(!hasOwn.call(options,\"from\")){options.from=objectOrReference;}}if(__DEV__&&options.from===void 0){__DEV__&&invariant.warn(\"Undefined 'from' passed to readField with arguments \".concat(stringifyForDisplay(Array.from(readFieldArgs))));}if(void 0===options.variables){options.variables=variables;}return options;}function makeMergeObjectsFunction(store){return function mergeObjects(existing,incoming){if(isArray(existing)||isArray(incoming)){throw __DEV__?new InvariantError(\"Cannot automatically merge arrays\"):new InvariantError(4);}if(isNonNullObject(existing)&&isNonNullObject(incoming)){var eType=store.getFieldValue(existing,\"__typename\");var iType=store.getFieldValue(incoming,\"__typename\");var typesDiffer=eType&&iType&&eType!==iType;if(typesDiffer){return incoming;}if(isReference(existing)&&storeValueIsStoreObject(incoming)){store.merge(existing.__ref,incoming);return existing;}if(storeValueIsStoreObject(existing)&&isReference(incoming)){store.merge(existing,incoming.__ref);return incoming;}if(storeValueIsStoreObject(existing)&&storeValueIsStoreObject(incoming)){return __assign(__assign({},existing),incoming);}}return incoming;};}","map":{"version":3,"mappings":"mCAAA,OAASA,SAAT,CAAoBC,cAApB,KAA0C,kCAA1C,CASA,OAEEC,qBAFF,CAKEC,wBALF,CAOEC,WAPF,CAQEC,eARF,CASEC,eATF,CAUEC,mBAVF,KAWO,0BAXP,CAkBA,OACEC,MADF,CAEEC,sBAFF,CAGEC,uBAHF,CAIEC,yBAJF,CAKEC,qBALF,CAMEC,uBANF,CAOEC,OAPF,KAQO,cARP,CASA,OAASC,SAAT,KAA0B,mBAA1B,CAeA,OAASC,kBAAT,KAAmC,mBAAnC,CACA,OAASC,sBAAT,CAAiCC,wBAAjC,KAAiE,oBAAjE,CAEAb,eAAe,CAACc,YAAhB,CAA6BH,kBAA7B,EAoHA,QAASI,uBAAT,CAAgCC,IAAhC,CAAoD,CAClD,MAAOA,KAAI,CAACC,IAAL,GAAc,IAAK,EAAnB,CAAuBD,IAAI,CAACC,IAA5B,CACLD,IAAI,CAACE,KAAL,CAAapB,wBAAwB,CAACkB,IAAI,CAACE,KAAN,CAAaF,IAAI,CAACG,SAAlB,CAArC,CAAoE,IADtE,CAED,CA6FD,GAAMC,gBAAe,CAAsB,QAArCA,gBAAqC,GAAM,WAAK,EAAL,CAAM,CAAvD,CACA,GAAMC,gBAAe,CAAoB,QAAnCA,gBAAmC,CAACC,KAAD,CAAQC,OAAR,CAAe,CAAK,cAAO,CAACC,SAAR,CAAiB,CAA9E,CAIA,GAAMC,YAAW,CACf,QADIA,YACJ,CAACC,QAAD,CAAWC,QAAX,CAAqBC,EAArB,CAAqC,IAAdC,aAAY,iBAAO,mBAAY,CAACH,QAAD,CAAWC,QAAX,CAAZ,CAAgC,CAD5E,CAEA,GAAMG,aAAY,CAA4B,QAAxCA,aAAwC,CAACC,CAAD,CAAIJ,QAAJ,CAAY,CAAK,gBAAQ,CAAvE,CAMA,wBAsCE,kBAAoBK,MAApB,CAKC,CALmB,mBArCZ,kBAYJC,MAAM,CAACC,MAAP,CAAc,IAAd,CAZI,CAcA,eAEJD,MAAM,CAACC,MAAP,CAAc,IAAd,CAFI,CAQA,kBAAe,GAAIC,IAAJ,EAAf,CAMA,mBAAgB,GAAIA,IAAJ,EAAhB,CAIQ,uBAA4CF,MAAM,CAACC,MAAP,CAAc,IAAd,CAA5C,CACA,uBAA4CD,MAAM,CAACC,MAAP,CAAc,IAAd,CAA5C,CAEA,wBAAqB,KAArB,CAQd,KAAKF,MAAL,CAAWI,UACTC,gBAAgB,CAAE7B,uBADT,EAENwB,MAFM,CAAX,CAKA,KAAKM,KAAL,CAAa,KAAKN,MAAL,CAAYM,KAAzB,CAEA,KAAKC,eAAL,CAAqB,OAArB,EACA,KAAKA,eAAL,CAAqB,UAArB,EACA,KAAKA,eAAL,CAAqB,cAArB,EAEA,GAAIP,MAAM,CAACQ,aAAX,CAA0B,CACxB,KAAKC,gBAAL,CAAsBT,MAAM,CAACQ,aAA7B,EACD,CAED,GAAIR,MAAM,CAACU,YAAX,CAAyB,CACvB,KAAKC,eAAL,CAAqBX,MAAM,CAACU,YAA5B,EACD,CACF,CAEME,4BAAP,SACEC,MADF,CAEEC,cAFF,CAE4C,QAE1C,GAAMC,SAAQ,CAAG,IAAjB,CAEA,GAAMC,SAAQ,CAAGF,cAAc,GAC7BA,cAAc,CAACE,QAAf,GACA,kBAAc,CAACC,WAAf,IAA0B,IAA1B,EAA0BrB,WAA1B,CAA0B,MAA1B,CAA0BA,GAAEsB,UAD5B,CAD6B,CAAd,EAGZL,MAAM,CAACK,UAHZ,CAUA,GAAIF,QAAQ,GAAK,KAAKG,iBAAL,CAAuBC,UAAxC,CAAoD,CAClD,MAAO,CAAC,YAAD,CAAP,CACD,CAGD,GAAMH,YAAW,CAAGH,cAAc,EAAIA,cAAc,CAACG,WAAjC,EAAgDJ,MAApE,CAEA,GAAMtB,QAAO,sBACRuB,cADQ,EACM,CACjBE,QAAQ,SADS,CAEjBC,WAAW,YAFM,CAGjBI,SAAS,CAAEP,cAAc,EAAIA,cAAc,CAACO,SAAjC,EAA8C,WACvD,GAAMC,QAAO,CAAGC,yBAAyB,CAACC,SAAD,CAAYP,WAAZ,CAAzC,CACA,MAAOF,SAAQ,CAACM,SAAT,CAAmBC,OAAnB,CAA4B,CACjCG,KAAK,CAAEV,QAAQ,CAACT,KAAT,CAAe,MAAf,CAD0B,CAEjCnB,SAAS,CAAEmC,OAAO,CAACnC,SAFc,CAA5B,CAAP,CAID,CATgB,CADN,CAAb,CAaA,GAAIuC,GAAJ,CAEA,GAAMC,OAAM,CAAGX,QAAQ,EAAI,KAAKY,aAAL,CAAmBZ,QAAnB,CAA3B,CACA,GAAIa,MAAK,CAAGF,MAAM,EAAIA,MAAM,CAACE,KAAjB,EAA0B,KAAK7B,MAAL,CAAYK,gBAAlD,CACA,MAAOwB,KAAP,CAAc,CACZ,GAAMC,cAAa,CAAGD,KAAK,CAAChB,MAAD,CAAStB,OAAT,CAA3B,CACA,GAAId,OAAO,CAACqD,aAAD,CAAX,CAA4B,CAC1BD,KAAK,CAAGhD,wBAAwB,CAACiD,aAAD,CAAhC,CACD,CAFD,IAEO,CACLJ,EAAE,CAAGI,aAAL,CACA,MACD,CACF,CAEDJ,EAAE,CAAGA,EAAE,CAAGK,MAAM,CAACL,EAAD,CAAT,CAAgB,IAAK,EAA5B,CACA,MAAOnC,QAAO,CAACyC,SAAR,CAAoB,CAACN,EAAD,CAAKnC,OAAO,CAACyC,SAAb,CAApB,CAA8C,CAACN,EAAD,CAArD,CACD,CApDM,CAsDAd,mCAAP,SAAuBF,YAAvB,CAAiD,CAAjD,eACET,MAAM,CAACgC,IAAP,CAAYvB,YAAZ,EAA0BwB,OAA1B,CAAkC,kBAAQ,CACxC,GAAMtC,IAKFc,YAAY,CAACM,QAAD,CALhB,CACEmB,SAAS,aADX,CAEEC,YAAY,gBAFd,CAGEC,gBAAgB,oBAHlB,CAIK1C,QAAQ,WAJP,+CAIO,CAJb,CAqBA,GAAIwC,SAAJ,CAAeG,KAAI,CAAC/B,eAAL,CAAqB,OAArB,CAA8BS,QAA9B,EACf,GAAIoB,YAAJ,CAAkBE,KAAI,CAAC/B,eAAL,CAAqB,UAArB,CAAiCS,QAAjC,EAClB,GAAIqB,gBAAJ,CAAsBC,KAAI,CAAC/B,eAAL,CAAqB,cAArB,CAAqCS,QAArC,EAEtB,GAAI7C,MAAM,CAACoE,IAAP,CAAYD,KAAI,CAACE,SAAjB,CAA4BxB,QAA5B,CAAJ,CAA2C,CACzCsB,KAAI,CAACE,SAAL,CAAexB,QAAf,EAAyByB,IAAzB,CAA8B9C,QAA9B,EACD,CAFD,IAEO,CACL2C,KAAI,CAACE,SAAL,CAAexB,QAAf,EAA2B,CAACrB,QAAD,CAA3B,CACD,CACF,CA/BD,EAgCD,CAjCM,CAmCCiB,oCAAR,SAAyBI,QAAzB,CAA2CrB,QAA3C,CAA+D,CAA/D,eACE,GAAMD,SAAQ,CAAG,KAAKkC,aAAL,CAAmBZ,QAAnB,CAAjB,CACQ,aAAS,CAAarB,QAAQ,UAA9B,CAAW+C,MAAM,CAAK/C,QAAQ,OAA9B,CAER,QAASgD,SAAT,CACEjD,QADF,CAEEkD,KAFF,CAEsC,CAEpClD,QAAQ,CAACkD,KAAT,CACE,MAAOA,MAAP,GAAiB,UAAjB,CAA8BA,KAA9B,CAGAA,KAAK,GAAK,IAAV,CAAiBnD,WAAjB,CAGAmD,KAAK,GAAK,KAAV,CAAkB9C,YAAlB,CACAJ,QAAQ,CAACkD,KARX,CASD,CAIDD,QAAQ,CAACjD,QAAD,CAAWC,QAAQ,CAACiD,KAApB,CAAR,CAEAlD,QAAQ,CAACmC,KAAT,CAEEgB,SAAS,GAAK,KAAd,CAAsBzD,eAAtB,CAGAX,OAAO,CAACoE,SAAD,CAAP,CAAqBhE,wBAAwB,CAACgE,SAAD,CAA7C,CAEA,MAAOA,UAAP,GAAqB,UAArB,CAAkCA,SAAlC,CAEAnD,QAAQ,CAACmC,KATX,CAWA,GAAIa,MAAJ,CAAY,CACVzC,MAAM,CAACgC,IAAP,CAAYS,MAAZ,EAAoBR,OAApB,CAA4B,mBAAS,CACnC,GAAMxC,SAAQ,CAAG4C,KAAI,CAACQ,cAAL,CAAoB9B,QAApB,CAA8BxB,SAA9B,CAAyC,IAAzC,CAAjB,CACA,GAAMG,SAAQ,CAAG+C,MAAM,CAAClD,SAAD,CAAvB,CAEA,GAAI,MAAOG,SAAP,GAAoB,UAAxB,CAAoC,CAClCD,QAAQ,CAACqD,IAAT,CAAgBpD,QAAhB,CACD,CAFD,IAEO,CACG,WAAO,CAAkBA,QAAQ,QAAjC,CAASoD,IAAI,CAAYpD,QAAQ,KAAjC,CAAeiD,KAAK,CAAKjD,QAAQ,MAAjC,CAERD,QAAQ,CAACmC,KAAT,CAGEmB,OAAO,GAAK,KAAZ,CAAoB3D,eAApB,CAGAZ,OAAO,CAACuE,OAAD,CAAP,CAAmBpE,sBAAsB,CAACoE,OAAD,CAAzC,CAEA,MAAOA,QAAP,GAAmB,UAAnB,CAAgCA,OAAhC,CAEAtD,QAAQ,CAACmC,KAVX,CAYA,GAAI,MAAOkB,KAAP,GAAgB,UAApB,CAAgC,CAC9BrD,QAAQ,CAACqD,IAAT,CAAgBA,IAAhB,CACD,CAEDJ,QAAQ,CAACjD,QAAD,CAAWkD,KAAX,CAAR,CACD,CAED,GAAIlD,QAAQ,CAACqD,IAAT,EAAiBrD,QAAQ,CAACkD,KAA9B,CAAqC,CAMnClD,QAAQ,CAACmC,KAAT,CAAiBnC,QAAQ,CAACmC,KAAT,EAAkBxC,eAAnC,CACD,CACF,CApCD,EAqCD,CACF,CAzEO,CA2EAuB,mCAAR,SACEqC,KADF,CAEEjC,QAFF,CAE0B,CAAxB,qCAAwB,CAExB,GAAMkC,OAAM,CAAG,QAAUD,KAAK,CAACE,WAAN,EAAzB,CACA,GAAMC,IAAG,CAAG,KAAKjC,iBAAL,CAAuB+B,MAAvB,CAAZ,CACA,GAAIlC,QAAQ,GAAKoC,GAAjB,CAAsB,CACpBC,QAAU1F,SAAQ,EAAGyF,GAAH,EAAQA,GAAK,GAAEH,KAAf,CAAe,sBAAsBK,MAAtB,CAA2BL,KAA3B,CAA2B,4BAA3B,CAAf,CAAlB,CAA0FtF,8BAA1F,CAGA,GAAIyF,GAAJ,CAAS,MAAO,MAAKG,iBAAL,CAAuBH,GAAvB,CAAP,CAET,KAAKG,iBAAL,CAAuBvC,QAAvB,EAAmCkC,MAAnC,CAEA,KAAK/B,iBAAL,CAAuB+B,MAAvB,EAAiClC,QAAjC,CACD,CACF,CAhBO,CAkBDJ,oCAAP,SAAwBJ,aAAxB,CAAuD,CAAvD,eACG,KAAKgD,kBAAL,CAAsC,IAAtC,CACDvD,MAAM,CAACgC,IAAP,CAAYzB,aAAZ,EAA2B0B,OAA3B,CAAmC,mBAAS,CAI1CI,KAAI,CAACmB,eAAL,CAAqBC,SAArB,CAAgC,IAAhC,EAEAlD,aAAa,CAACkD,SAAD,CAAb,CAAyBxB,OAAzB,CAAiC,iBAAO,CACtCI,KAAI,CAACmB,eAAL,CAAqBE,OAArB,CAA8B,IAA9B,EAAqCC,GAArC,CAAyCF,SAAzC,EACA,GAAMG,MAAK,CAAGF,OAAO,CAACE,KAAR,CAActF,qBAAd,CAAd,CACA,GAAI,CAACsF,KAAD,EAAUA,KAAK,CAAC,CAAD,CAAL,GAAaF,OAA3B,CAAoC,CAElCrB,KAAI,CAACwB,aAAL,CAAmBC,GAAnB,CAAuBJ,OAAvB,CAAgC,GAAIK,OAAJ,CAAWL,OAAX,CAAhC,EACD,CACF,CAPD,EAQD,CAdD,EAeD,CAjBM,CAmBC/C,iCAAR,SAAsBI,QAAtB,CAAsC,CAAtC,eACE,GAAI,CAAC7C,MAAM,CAACoE,IAAP,CAAY,KAAK7B,YAAjB,CAA+BM,QAA/B,CAAL,CAA+C,CAC7C,GAAMiD,SAAM,CACV,KAAKvD,YAAL,CAAkBM,QAAlB,EAA8Bf,MAAM,CAACC,MAAP,CAAc,IAAd,CADhC,CAEA+D,QAAM,CAACvB,MAAP,CAAgBzC,MAAM,CAACC,MAAP,CAAc,IAAd,CAAhB,CAuBA,GAAMgE,WAAU,CAAG,KAAKC,YAAL,CAAkBC,GAAlB,CAAsBpD,QAAtB,CAAnB,CACA,GAAIkD,UAAU,EAAIA,UAAU,CAACG,IAA7B,CAAmC,CACjCH,UAAU,CAAChC,OAAX,CAAmB,mBAAS,CAC1B,GAAMtC,IAAsB0C,KAAI,CAACV,aAAL,CAAmB8B,SAAnB,CAA5B,CAAQhB,MAAM,UAAd,CAAmB4B,IAAI,WAAjB,UAAiB,CAAvB,CACArE,MAAM,CAACsE,MAAP,CAAcN,QAAd,CAAsBK,IAAtB,EACArE,MAAM,CAACsE,MAAP,CAAcN,QAAM,CAACvB,MAArB,CAA6BA,MAA7B,EACD,CAJD,EAKD,CACF,CAED,GAAM8B,MAAK,CAAG,KAAKhC,SAAL,CAAexB,QAAf,CAAd,CACA,GAAIwD,KAAK,EAAIA,KAAK,CAACC,MAAnB,CAA2B,CAGzBD,KAAK,CAACE,MAAN,CAAa,CAAb,EAAgBxC,OAAhB,CAAwB,gBAAM,CAC5BI,KAAI,CAACqC,gBAAL,CAAsB3D,QAAtB,CAAgCW,MAAhC,EACD,CAFD,EAGD,CAED,MAAO,MAAKjB,YAAL,CAAkBM,QAAlB,CAAP,CACD,CA/CO,CAiDAJ,kCAAR,SACEI,QADF,CAEExB,SAFF,CAGEoF,eAHF,CAG0B,CAMxB,GAAI5D,QAAJ,CAAc,CACZ,GAAM6D,cAAa,CAAG,KAAKjD,aAAL,CAAmBZ,QAAnB,EAA6B0B,MAAnD,CACA,MAAOmC,cAAa,CAACrF,SAAD,CAAb,EACLoF,eAAe,GAAKC,aAAa,CAACrF,SAAD,CAAb,CAA2BS,MAAM,CAACC,MAAP,CAAc,IAAd,CAAhC,CADjB,CAED,CACF,CAdO,CAgBAU,mCAAR,SACE+C,OADF,CAEEiB,eAFF,CAE0B,CAExB,GAAIE,aAAY,CAAG,KAAKX,YAAL,CAAkBC,GAAlB,CAAsBT,OAAtB,CAAnB,CACA,GAAI,CAACmB,YAAD,EAAiBF,eAArB,CAAsC,CACpC,KAAKT,YAAL,CAAkBJ,GAAlB,CAAsBJ,OAAtB,CAA+BmB,YAAY,CAAG,GAAIC,IAAJ,EAA9C,EACD,CACD,MAAOD,aAAP,CACD,CATO,CAWDlE,mCAAP,SACEoE,QADF,CAEEhE,QAFF,CAGEiE,MAHF,CAIE9F,SAJF,CAIiC,CAJjC,eAME,GAAI,CAAC6F,QAAQ,CAACE,aAAd,CAA6B,MAAO,KAAP,CAI7B,GAAI,CAAClE,QAAL,CAAe,MAAO,MAAP,CAEf,GAAM0C,UAAS,CAAGsB,QAAQ,CAACE,aAAT,CAAuBC,IAAvB,CAA4BC,KAA9C,CAEA,GAAIpE,QAAQ,GAAK0C,SAAjB,CAA4B,MAAO,KAAP,CAE5B,GAAI,KAAKF,kBAAL,EACA,KAAKW,YAAL,CAAkBkB,GAAlB,CAAsB3B,SAAtB,CADJ,CACsC,CACpC,GAAM4B,qBAAoB,CAAG,KAAK7B,eAAL,CAAqBzC,QAArB,CAA+B,IAA/B,CAA7B,CACA,GAAMuE,YAAS,CAAG,CAACD,oBAAD,CAAlB,CACA,GAAME,eAAY,CAAG,QAAfA,eAAe,CAAC7B,OAAD,CAAgB,CACnC,GAAMmB,aAAY,CAAGxC,KAAI,CAACmB,eAAL,CAAqBE,OAArB,CAA8B,KAA9B,CAArB,CACA,GAAImB,YAAY,EACZA,YAAY,CAACT,IADb,EAEAkB,WAAS,CAACE,OAAV,CAAkBX,YAAlB,EAAkC,CAFtC,CAEyC,CACvCS,WAAS,CAAC9C,IAAV,CAAeqC,YAAf,EACD,CACF,CAPD,CAeA,GAAIY,yBAAwB,CAAG,CAAC,EAAET,MAAM,EAAI,KAAKnB,aAAL,CAAmBO,IAA/B,CAAhC,CACA,GAAIsB,sBAAqB,CAAG,KAA5B,CAIA,IAAK,GAAIC,EAAC,CAAG,CAAb,CAAgBA,CAAC,CAAGL,WAAS,CAACd,MAA9B,CAAsC,EAAEmB,CAAxC,CAA2C,CACzC,GAAMd,aAAY,CAAGS,WAAS,CAACK,CAAD,CAA9B,CAEA,GAAId,YAAY,CAACO,GAAb,CAAiB3B,SAAjB,CAAJ,CAAiC,CAC/B,GAAI,CAAC4B,oBAAoB,CAACD,GAArB,CAAyB3B,SAAzB,CAAL,CAA0C,CACxC,GAAIiC,qBAAJ,CAA2B,CACzBtC,SAAU1F,SAAK,KAAL,CAAK,qBAAqB2F,MAArB,CAA6BtC,QAA7B,CAA6B,gBAA7B,EAA8CsC,MAA9C,CAA0DI,SAA1D,CAAL,CAAV,CACD,CAKD4B,oBAAoB,CAAC1B,GAArB,CAAyBF,SAAzB,EACD,CACD,MAAO,KAAP,CACD,CAEDoB,YAAY,CAAC5C,OAAb,CAAqBsD,cAArB,EAEA,GAAIE,wBAAwB,EAGxBE,CAAC,GAAKL,WAAS,CAACd,MAAV,CAAmB,CAHzB,EAQAnG,yBAAyB,CAAC0G,QAAQ,CAACa,YAAV,CAAwBZ,MAAxB,CAAiC9F,SAAjC,CAR7B,CAQ0E,CAIxEuG,wBAAwB,CAAG,KAA3B,CACAC,qBAAqB,CAAG,IAAxB,CAMA,KAAK7B,aAAL,CAAmB5B,OAAnB,CAA2B,SAAC4D,MAAD,CAASC,WAAT,CAAoB,CAC7C,GAAMlC,MAAK,CAAG7C,QAAQ,CAAC6C,KAAT,CAAeiC,MAAf,CAAd,CACA,GAAIjC,KAAK,EAAIA,KAAK,CAAC,CAAD,CAAL,GAAa7C,QAA1B,CAAoC,CAClCwE,cAAY,CAACO,WAAD,CAAZ,CACD,CACF,CALD,EAMD,CACF,CACF,CAED,MAAO,MAAP,CACD,CAzFM,CA2FAnF,8BAAP,SAAkBI,QAAlB,CAAgDxB,SAAhD,CAAiE,CAC/D,GAAMmC,OAAM,CAAG,KAAKmB,cAAL,CAAoB9B,QAApB,CAA8BxB,SAA9B,CAAyC,KAAzC,CAAf,CACA,MAAO,CAAC,EAAEmC,MAAM,EAAIA,MAAM,CAACE,KAAnB,CAAR,CACD,CAHM,CAKAjB,qCAAP,SAAyBoF,SAAzB,CAAkD,CACxC,YAAQ,CAAgBA,SAAS,SAAjC,CAAUxG,SAAS,CAAKwG,SAAS,UAAjC,CACR,GAAMrE,OAAM,CAAG,KAAKmB,cAAL,CAAoB9B,QAApB,CAA8BxB,SAA9B,CAAyC,KAAzC,CAAf,CACA,GAAIyG,eAAJ,CAEA,GAAIpE,MAAK,CAAGF,MAAM,EAAIA,MAAM,CAACE,KAA7B,CACA,GAAIA,KAAK,EAAIb,QAAb,CAAuB,CACrB,GAAMzB,QAAO,CAAmC,CAC9CyB,QAAQ,SADsC,CAE9CxB,SAAS,UAFqC,CAG9CN,KAAK,CAAE8G,SAAS,CAAC9G,KAAV,EAAmB,IAHoB,CAI9CC,SAAS,CAAE6G,SAAS,CAAC7G,SAJyB,CAAhD,CAMA,GAAMF,KAAI,CAAGF,sBAAsB,CAACiH,SAAD,CAAnC,CACA,MAAOnE,KAAP,CAAc,CACZ,GAAMqE,kBAAiB,CAAGrE,KAAK,CAAC5C,IAAD,CAAOM,OAAP,CAA/B,CACA,GAAId,OAAO,CAACyH,iBAAD,CAAX,CAAgC,CAC9BrE,KAAK,CAAGjD,sBAAsB,CAACsH,iBAAD,CAA9B,CACD,CAFD,IAEO,CAGLD,cAAc,CAAGC,iBAAiB,EAAI1G,SAAtC,CACA,MACD,CACF,CACF,CAED,GAAIyG,cAAc,GAAK,IAAK,EAA5B,CAA+B,CAC7BA,cAAc,CAAGD,SAAS,CAAC9G,KAAV,CACbrB,qBAAqB,CAACmI,SAAS,CAAC9G,KAAX,CAAkB8G,SAAS,CAAC7G,SAA5B,CADR,CAEbnB,eAAe,CAACwB,SAAD,CAAYT,sBAAsB,CAACiH,SAAD,CAAlC,CAFnB,CAGD,CAID,GAAIC,cAAc,GAAK,KAAvB,CAA8B,CAC5B,MAAOzG,UAAP,CACD,CAKD,MAAOA,UAAS,GAAKpB,sBAAsB,CAAC6H,cAAD,CAApC,CACHA,cADG,CAEHzG,SAAS,CAAG,GAAZ,CAAkByG,cAFtB,CAGD,CA7CM,CA+CArF,6BAAP,SACEU,OADF,CAEE/B,OAFF,CAEiC,CAE/B,GAAM4G,kBAAiB,CAAG7E,OAAO,CAAC8E,IAAlC,CACA,GAAI,CAACD,iBAAL,CAAwB,OAExB,GAAME,YAAW,CAAG/E,OAAO,CAACpC,KAAR,EAAiBoC,OAAO,CAAC9B,SAA7C,CACA,GAAI,CAAC6G,WAAL,CAAkB,OAElB,GAAI/E,OAAO,CAACN,QAAR,GAAqB,IAAK,EAA9B,CAAiC,CAC/B,GAAMA,SAAQ,CAAGzB,OAAO,CAACkC,KAAR,CAAc6E,aAAd,CAAoCH,iBAApC,CAAuD,YAAvD,CAAjB,CACA,GAAInF,QAAJ,CAAcM,OAAO,CAACN,QAAR,CAAmBA,QAAnB,CACf,CAED,GAAMiF,eAAc,CAAG,KAAKM,iBAAL,CAAuBjF,OAAvB,CAAvB,CACA,GAAM9B,UAAS,CAAGpB,sBAAsB,CAAC6H,cAAD,CAAxC,CACA,GAAMvG,SAAQ,CAAGH,OAAO,CAACkC,KAAR,CAAc6E,aAAd,CAA+BH,iBAA/B,CAAkDF,cAAlD,CAAjB,CACA,GAAMtE,OAAM,CAAG,KAAKmB,cAAL,CAAoBxB,OAAO,CAACN,QAA5B,CAAsCxB,SAAtC,CAAiD,KAAjD,CAAf,CACA,GAAMuD,KAAI,CAAGpB,MAAM,EAAIA,MAAM,CAACoB,IAA9B,CAEA,GAAIA,IAAJ,CAAU,CACR,GAAMyD,YAAW,CAAGC,wBAAwB,CAC1C,IAD0C,CAE1CN,iBAF0C,CAG1C7E,OAH0C,CAI1C/B,OAJ0C,CAK1CA,OAAO,CAACkC,KAAR,CAAciF,UAAd,CACE3I,WAAW,CAACoI,iBAAD,CAAX,CACIA,iBAAiB,CAACQ,KADtB,CAEIR,iBAHN,CAIEF,cAJF,CAL0C,CAA5C,CAcA,MAAOvH,UAAS,CAACkI,SAAV,CACL,KAAKtG,KADA,CAELyC,IAFK,CAGL,CAACrD,QAAD,CAAW8G,WAAX,CAHK,CAAP,CAKD,CAED,MAAO9G,SAAP,CACD,CA5CM,CA8CAkB,mCAAP,SACEI,QADF,CAEExB,SAFF,CAEmB,CAEjB,GAAMmC,OAAM,CAAG,KAAKmB,cAAL,CAAoB9B,QAApB,CAA8BxB,SAA9B,CAAyC,KAAzC,CAAf,CACA,MAAOmC,OAAM,EAAIA,MAAM,CAACoB,IAAxB,CACD,CANM,CAQAnC,oCAAP,SACEiG,cADF,CAEErH,SAFF,CAGEsH,aAHF,CAGmC,CAEjC,GAAInF,OAAM,CAIR,KAAKmB,cAAL,CAAoB+D,cAApB,CAAoCrH,SAApC,CAA+C,KAA/C,CAJF,CAKA,GAAIoD,MAAK,CAAGjB,MAAM,EAAIA,MAAM,CAACiB,KAA7B,CACA,GAAI,CAACA,KAAD,EAAUkE,aAAd,CAA6B,CAC3BnF,MAAM,CAAG,KAAKC,aAAL,CAAmBkF,aAAnB,CAAT,CACAlE,KAAK,CAAGjB,MAAM,EAAIA,MAAM,CAACiB,KAAzB,CACD,CACD,MAAOA,MAAP,CACD,CAhBM,CAkBAhC,oCAAP,SACElB,QADF,CAEEC,QAFF,CAGEC,EAHF,CAIEL,OAJF,CAKEwH,OALF,CAKuB,IAFnB7H,MAAK,UAAE8B,QAAQ,aAAE4B,KAAK,UAIxB,GAAIA,KAAK,GAAKnD,WAAd,CAA2B,CAIzB,MAAOuH,yBAAwB,CAC7BzH,OAAO,CAACkC,KADqB,CAAxB,CAEL/B,QAFK,CAGLC,QAHK,CAAP,CAID,CAED,GAAIiD,KAAK,GAAK9C,YAAd,CAA4B,CAE1B,MAAOH,SAAP,CACD,CAMD,GAAIJ,OAAO,CAAC0H,SAAZ,CAAuB,CACrBvH,QAAQ,CAAG,IAAK,EAAhB,CACD,CAED,MAAOkD,MAAK,CAAClD,QAAD,CAAWC,QAAX,CAAqB8G,wBAAwB,CACvD,IADuD,CAavD,IAAK,EAbkD,CAcvD,CAAEzF,QAAQ,SAAV,CACExB,SAAS,CAAEN,KAAK,CAACiG,IAAN,CAAWC,KADxB,CAEElG,KAAK,MAFP,CAGEC,SAAS,CAAEI,OAAO,CAACJ,SAHrB,CAduD,CAkBvDI,OAlBuD,CAmBvDwH,OAAO,EAAI9G,MAAM,CAACC,MAAP,CAAc,IAAd,CAnB4C,CAA7C,CAAZ,CAqBD,CAnDM,CAoDT,gBAAC,CAhmBD,oBAkmBA,QAASuG,yBAAT,CACE1F,QADF,CAEEoF,iBAFF,CAGEH,SAHF,CAIEzG,OAJF,CAKEwH,OALF,CAKsB,CAEpB,GAAMd,eAAc,CAAGlF,QAAQ,CAACwF,iBAAT,CAA2BP,SAA3B,CAAvB,CACA,GAAMxG,UAAS,CAAGpB,sBAAsB,CAAC6H,cAAD,CAAxC,CACA,GAAM9G,UAAS,CAAG6G,SAAS,CAAC7G,SAAV,EAAuBI,OAAO,CAACJ,SAAjD,CACM,OAA2BI,OAAO,CAACkC,KAAnC,CAAEyF,WAAW,eAAb,CAAeC,OAAO,WAAtB,CAEN,MAAO,CACLlI,IAAI,CAAEF,sBAAsB,CAACiH,SAAD,CADvB,CAEL9G,KAAK,CAAE8G,SAAS,CAAC9G,KAAV,EAAmB,IAFrB,CAGLM,SAAS,UAHJ,CAILyG,cAAc,eAJT,CAKL9G,SAAS,UALJ,CAMLpB,WAAW,YANN,CAOLmJ,WAAW,YAPN,CAQLH,OAAO,QARF,CASLzG,KAAK,CAAES,QAAQ,CAACT,KATX,CAUL6G,OAAO,QAVF,CAWL9F,SAAS,CAAT,qBACE,MAAON,SAAQ,CAACM,SAAT,CACLE,yBAAyB,CAACC,SAAD,CAAY2E,iBAAZ,CAA+BhH,SAA/B,CADpB,CAELI,OAFK,CAAP,CAID,CAhBI,CAiBLM,YAAY,CAAEmH,wBAAwB,CAACzH,OAAO,CAACkC,KAAT,CAjBjC,CAAP,CAmBD,CAED,MAAM,SAAUF,0BAAV,CACJ6F,aADI,CAEJjB,iBAFI,CAGJhH,SAHI,CAG2C,CAG7C,GAAGkI,mBAAkB,CAGnBD,aAAa,GAHf,CACGhB,IAAI,CAELgB,aAAa,GAHf,CAEQE,IAAI,CACVF,aAAa,OAHf,CAKF,GAAI9F,QAAJ,CAEA,GAAI,MAAO+F,mBAAP,GAA8B,QAAlC,CAA4C,CAC1C/F,OAAO,CAAG,CACR9B,SAAS,CAAE6H,kBADH,CAKRjB,IAAI,CAAEkB,IAAI,CAAG,CAAP,CAAWlB,IAAX,CAAkBD,iBALhB,CAAV,CAOD,CARD,IAQO,CACL7E,OAAO,aAAQ+F,kBAAR,CAAP,CAGA,GAAI,CAAClJ,MAAM,CAACoE,IAAP,CAAYjB,OAAZ,CAAqB,MAArB,CAAL,CAAmC,CACjCA,OAAO,CAAC8E,IAAR,CAAeD,iBAAf,CACD,CACF,CAED,GAAI9C,OAAO,EAAI/B,OAAO,CAAC8E,IAAR,GAAiB,IAAK,EAArC,CAAwC,CACtC/C,SAAU1F,SAAK,KAAL,CAAK,uDACb2F,MADa,CACbpF,mBAA8B,CAACqJ,yBAAD,CADjB,CAAL,CAAV,CAGD,CAED,GAAI,IAAK,EAAL,GAAWjG,OAAO,CAACnC,SAAvB,CAAkC,CAChCmC,OAAO,CAACnC,SAAR,CAAoBA,SAApB,CACD,CAED,MAAOmC,QAAP,CACD,CAED,QAAS0F,yBAAT,CACEvF,KADF,CACwB,CAEtB,MAAO,SAAS5B,aAAT,CAAsBH,QAAtB,CAAgCC,QAAhC,CAAwC,CAC7C,GAAIlB,OAAO,CAACiB,QAAD,CAAP,EAAqBjB,OAAO,CAACkB,QAAD,CAAhC,CAA4C,CAC1C,KAAM0D,QAAI,oBAAe,mCAAf,EAAoD,qBAA9D,CACD,CAMD,GAAIpF,eAAe,CAACyB,QAAD,CAAf,EACAzB,eAAe,CAAC0B,QAAD,CADnB,CAC+B,CAC7B,GAAM6H,MAAK,CAAG/F,KAAK,CAAC6E,aAAN,CAAoB5G,QAApB,CAA8B,YAA9B,CAAd,CACA,GAAM+H,MAAK,CAAGhG,KAAK,CAAC6E,aAAN,CAAoB3G,QAApB,CAA8B,YAA9B,CAAd,CACA,GAAM+H,YAAW,CAAGF,KAAK,EAAIC,KAAT,EAAkBD,KAAK,GAAKC,KAAhD,CAEA,GAAIC,WAAJ,CAAiB,CACf,MAAO/H,SAAP,CACD,CAED,GAAI5B,WAAW,CAAC2B,QAAD,CAAX,EACArB,uBAAuB,CAACsB,QAAD,CAD3B,CACuC,CAIrC8B,KAAK,CAACmB,KAAN,CAAYlD,QAAQ,CAACiH,KAArB,CAA4BhH,QAA5B,EACA,MAAOD,SAAP,CACD,CAED,GAAIrB,uBAAuB,CAACqB,QAAD,CAAvB,EACA3B,WAAW,CAAC4B,QAAD,CADf,CAC2B,CAKzB8B,KAAK,CAACmB,KAAN,CAAYlD,QAAZ,CAAsBC,QAAQ,CAACgH,KAA/B,EACA,MAAOhH,SAAP,CACD,CAED,GAAItB,uBAAuB,CAACqB,QAAD,CAAvB,EACArB,uBAAuB,CAACsB,QAAD,CAD3B,CACuC,CACrC,4BAAYD,QAAZ,EAAyBC,QAAzB,EACD,CACF,CAED,MAAOA,SAAP,CACD,CA7CD,CA8CD","names":["invariant","InvariantError","storeKeyNameFromField","argumentsObjectFromField","isReference","getStoreKeyName","isNonNullObject","stringifyForDisplay","hasOwn","fieldNameFromStoreName","storeValueIsStoreObject","selectionSetMatchesResult","TypeOrFieldNameRegExp","defaultDataIdFromObject","isArray","cacheSlot","canonicalStringify","keyArgsFnFromSpecifier","keyFieldsFnFromSpecifier","setStringify","argsFromFieldSpecifier","spec","args","field","variables","nullKeyFieldsFn","simpleKeyArgsFn","_args","context","fieldName","mergeTrueFn","existing","incoming","_a","mergeObjects","mergeFalseFn","_","config","Object","create","Map","__assign","dataIdFromObject","cache","setRootTypename","possibleTypes","addPossibleTypes","typePolicies","addTypePolicies","Policies","object","partialContext","policies","typename","storeObject","__typename","rootTypenamesById","ROOT_QUERY","readField","options","normalizeReadFieldOptions","arguments","store","id","policy","getTypePolicy","keyFn","specifierOrId","String","keyObject","keys","forEach","queryType","mutationType","subscriptionType","_this","call","toBeAdded","push","fields","setMerge","merge","keyFields","getFieldPolicy","read","keyArgs","which","rootId","toUpperCase","old","__DEV__","concat","rootIdsByTypename","usingPossibleTypes","getSupertypeSet","supertype","subtype","add","match","fuzzySubtypes","set","RegExp","policy_1","supertypes","supertypeMap","get","size","rest","assign","inbox","length","splice","updateTypePolicy","createIfMissing","fieldPolicies","supertypeSet","Set","fragment","result","typeCondition","name","value","has","typenameSupertypeSet","workQueue_1","maybeEnqueue_1","indexOf","needToCheckFuzzySubtypes","checkingFuzzySubtypes","i","selectionSet","regExp","fuzzyString","fieldSpec","storeFieldName","specifierOrString","objectOrReference","from","nameOrField","getFieldValue","getStoreFieldName","readOptions","makeFieldFunctionOptions","getStorage","__ref","withValue","parentTypename","childTypename","storage","makeMergeObjectsFunction","overwrite","toReference","canRead","readFieldArgs","fieldNameOrOptions","argc","Array","eType","iType","typesDiffer"],"sourceRoot":"","sources":["../../../src/cache/inmemory/policies.ts"],"sourcesContent":["import { invariant, InvariantError } from '../../utilities/globals';\n\nimport {\n  InlineFragmentNode,\n  FragmentDefinitionNode,\n  SelectionSetNode,\n  FieldNode,\n} from 'graphql';\n\nimport {\n  FragmentMap,\n  storeKeyNameFromField,\n  StoreValue,\n  StoreObject,\n  argumentsObjectFromField,\n  Reference,\n  isReference,\n  getStoreKeyName,\n  isNonNullObject,\n  stringifyForDisplay,\n} from '../../utilities';\nimport {\n  IdGetter,\n  MergeInfo,\n  NormalizedCache,\n  ReadMergeModifyContext,\n} from \"./types\";\nimport {\n  hasOwn,\n  fieldNameFromStoreName,\n  storeValueIsStoreObject,\n  selectionSetMatchesResult,\n  TypeOrFieldNameRegExp,\n  defaultDataIdFromObject,\n  isArray,\n} from './helpers';\nimport { cacheSlot } from './reactiveVars';\nimport { InMemoryCache } from './inMemoryCache';\nimport {\n  SafeReadonly,\n  FieldSpecifier,\n  ToReferenceFunction,\n  ReadFieldFunction,\n  ReadFieldOptions,\n  CanReadFunction,\n} from '../core/types/common';\nimport { WriteContext } from './writeToStore';\n\n// Upgrade to a faster version of the default stable JSON.stringify function\n// used by getStoreKeyName. This function is used when computing storeFieldName\n// strings (when no keyArgs has been configured for a field).\nimport { canonicalStringify } from './object-canon';\nimport { keyArgsFnFromSpecifier, keyFieldsFnFromSpecifier } from './key-extractor';\n\ngetStoreKeyName.setStringify(canonicalStringify);\n\nexport type TypePolicies = {\n  [__typename: string]: TypePolicy;\n}\n\n// TypeScript 3.7 will allow recursive type aliases, so this should work:\n// type KeySpecifier = (string | KeySpecifier)[]\nexport type KeySpecifier = ReadonlyArray<string | KeySpecifier>;\n\nexport type KeyFieldsContext = {\n  // The __typename of the incoming object, even if the __typename field was\n  // aliased to another name in the raw result object. May be undefined when\n  // dataIdFromObject is called for objects without __typename fields.\n  typename: string | undefined;\n\n  // The object to be identified, after processing to remove aliases and\n  // normalize identifiable child objects with references.\n  storeObject: StoreObject;\n\n  // Handy tool for reading additional fields from context.storeObject, either\n  // readField(\"fieldName\") to read storeObject[fieldName], or readField(\"name\",\n  // objectOrReference) to read from another object or Reference. If you read a\n  // field with a read function, that function will be invoked.\n  readField: ReadFieldFunction;\n\n  // If you are writing a custom keyFields function, and you plan to use the raw\n  // result object passed as the first argument, you may also need access to the\n  // selection set and available fragments for this object, just in case any\n  // fields have aliases. Since this logic is tricky to get right, and these\n  // context properties are not even always provided (for example, they are\n  // omitted when calling cache.identify(object), where object is assumed to be\n  // a StoreObject), we recommend you use context.storeObject (which has already\n  // been de-aliased) and context.readField (which can read from references as\n  // well as objects) instead of the raw result object in your keyFields\n  // functions, or just rely on the internal implementation of keyFields:[...]\n  // syntax to get these details right for you.\n  selectionSet?: SelectionSetNode;\n  fragmentMap?: FragmentMap;\n\n  // Internal. May be set by the KeyFieldsFunction to report fields that were\n  // involved in computing the ID. Never passed in by the caller.\n  keyObject?: Record<string, any>;\n};\n\nexport type KeyFieldsFunction = (\n  object: Readonly<StoreObject>,\n  context: KeyFieldsContext,\n) => KeySpecifier | false | ReturnType<IdGetter>;\n\ntype KeyFieldsResult = Exclude<ReturnType<KeyFieldsFunction>, KeySpecifier>;\n\n// TODO Should TypePolicy be a generic type, with a TObject or TEntity\n// type parameter?\nexport type TypePolicy = {\n  // Allows defining the primary key fields for this type, either using an\n  // array of field names or a function that returns an arbitrary string.\n  keyFields?: KeySpecifier | KeyFieldsFunction | false;\n\n  // Allows defining a merge function (or merge:true/false shorthand) to\n  // be used for merging objects of this type wherever they appear, unless\n  // the parent field also defines a merge function/boolean (that is,\n  // parent field merge functions take precedence over type policy merge\n  // functions). In many cases, defining merge:true for a given type\n  // policy can save you from specifying merge:true for all the field\n  // policies where that type might be encountered.\n  merge?: FieldMergeFunction | boolean;\n\n  // In the rare event that your schema happens to use a different\n  // __typename for the root Query, Mutation, and/or Schema types, you can\n  // express your deviant preferences by enabling one of these options.\n  queryType?: true,\n  mutationType?: true,\n  subscriptionType?: true,\n\n  fields?: {\n    [fieldName: string]:\n      | FieldPolicy<any>\n      | FieldReadFunction<any>;\n  }\n};\n\nexport type KeyArgsFunction = (\n  args: Record<string, any> | null,\n  context: {\n    typename: string;\n    fieldName: string;\n    field: FieldNode | null;\n    variables?: Record<string, any>;\n  },\n) => KeySpecifier | false | ReturnType<IdGetter>;\n\nexport type FieldPolicy<\n  // The internal representation used to store the field's data in the\n  // cache. Must be JSON-serializable if you plan to serialize the result\n  // of cache.extract() using JSON.\n  TExisting = any,\n  // The type of the incoming parameter passed to the merge function,\n  // typically matching the GraphQL response format, but with Reference\n  // objects substituted for any identifiable child objects. Often the\n  // same as TExisting, but not necessarily.\n  TIncoming = TExisting,\n  // The type that the read function actually returns, using TExisting\n  // data and options.args as input. Usually the same as TIncoming.\n  TReadResult = TIncoming,\n  // Allows FieldFunctionOptions definition to be overwritten by the\n  // developer\n  TOptions extends FieldFunctionOptions = FieldFunctionOptions\n> = {\n  keyArgs?: KeySpecifier | KeyArgsFunction | false;\n  read?: FieldReadFunction<TExisting, TReadResult, TOptions>;\n  merge?: FieldMergeFunction<TExisting, TIncoming, TOptions> | boolean;\n};\n\nexport type StorageType = Record<string, any>;\n\nfunction argsFromFieldSpecifier(spec: FieldSpecifier) {\n  return spec.args !== void 0 ? spec.args :\n    spec.field ? argumentsObjectFromField(spec.field, spec.variables) : null;\n}\n\nexport interface FieldFunctionOptions<\n  TArgs = Record<string, any>,\n  TVars = Record<string, any>,\n> {\n  args: TArgs | null;\n\n  // The name of the field, equal to options.field.name.value when\n  // options.field is available. Useful if you reuse the same function for\n  // multiple fields, and you need to know which field you're currently\n  // processing. Always a string, even when options.field is null.\n  fieldName: string;\n\n  // The full field key used internally, including serialized key arguments.\n  storeFieldName: string;\n\n  // The FieldNode object used to read this field. Useful if you need to\n  // know about other attributes of the field, such as its directives. This\n  // option will be null when a string was passed to options.readField.\n  field: FieldNode | null;\n\n  variables?: TVars;\n\n  // Utilities for dealing with { __ref } objects.\n  isReference: typeof isReference;\n  toReference: ToReferenceFunction;\n\n  // A handy place to put field-specific data that you want to survive\n  // across multiple read function calls. Useful for field-level caching,\n  // if your read function does any expensive work.\n  storage: StorageType;\n\n  cache: InMemoryCache;\n\n  // Helper function for reading other fields within the current object.\n  // If a foreign object or reference is provided, the field will be read\n  // from that object instead of the current object, so this function can\n  // be used (together with isReference) to examine the cache outside the\n  // current object. If a FieldNode is passed instead of a string, and\n  // that FieldNode has arguments, the same options.variables will be used\n  // to compute the argument values. Note that this function will invoke\n  // custom read functions for other fields, if defined. Always returns\n  // immutable data (enforced with Object.freeze in development).\n  readField: ReadFieldFunction;\n\n  // Returns true for non-normalized StoreObjects and non-dangling\n  // References, indicating that readField(name, objOrRef) has a chance of\n  // working. Useful for filtering out dangling references from lists.\n  canRead: CanReadFunction;\n\n  // Instead of just merging objects with { ...existing, ...incoming }, this\n  // helper function can be used to merge objects in a way that respects any\n  // custom merge functions defined for their fields.\n  mergeObjects: MergeObjectsFunction;\n}\n\ntype MergeObjectsFunction = <T extends StoreObject | Reference>(\n  existing: T,\n  incoming: T,\n) => T;\n\nexport type FieldReadFunction<\n  TExisting = any,\n  TReadResult = TExisting,\n  TOptions extends FieldFunctionOptions = FieldFunctionOptions\n> = (\n  // When reading a field, one often needs to know about any existing\n  // value stored for that field. If the field is read before any value\n  // has been written to the cache, this existing parameter will be\n  // undefined, which makes it easy to use a default parameter expression\n  // to supply the initial value. This parameter is positional (rather\n  // than one of the named options) because that makes it possible for the\n  // developer to annotate it with a type, without also having to provide\n  // a whole new type for the options object.\n  existing: SafeReadonly<TExisting> | undefined,\n  options: TOptions,\n) => TReadResult | undefined;\n\nexport type FieldMergeFunction<\n  TExisting = any,\n  TIncoming = TExisting,\n  // Passing the whole FieldFunctionOptions makes the current definition\n  // independent from its implementation\n  TOptions extends FieldFunctionOptions = FieldFunctionOptions\n> = (\n  existing: SafeReadonly<TExisting> | undefined,\n  // The incoming parameter needs to be positional as well, for the same\n  // reasons discussed in FieldReadFunction above.\n  incoming: SafeReadonly<TIncoming>,\n  options: TOptions,\n) => SafeReadonly<TExisting>;\n\nconst nullKeyFieldsFn: KeyFieldsFunction = () => void 0;\nconst simpleKeyArgsFn: KeyArgsFunction = (_args, context) => context.fieldName;\n\n// These merge functions can be selected by specifying merge:true or\n// merge:false in a field policy.\nconst mergeTrueFn: FieldMergeFunction<any> =\n  (existing, incoming, { mergeObjects }) => mergeObjects(existing, incoming);\nconst mergeFalseFn: FieldMergeFunction<any> = (_, incoming) => incoming;\n\nexport type PossibleTypesMap = {\n  [supertype: string]: string[];\n};\n\nexport class Policies {\n  private typePolicies: {\n    [__typename: string]: {\n      keyFn?: KeyFieldsFunction;\n      merge?: FieldMergeFunction<any>;\n      fields: {\n        [fieldName: string]: {\n          keyFn?: KeyArgsFunction;\n          read?: FieldReadFunction<any>;\n          merge?: FieldMergeFunction<any>;\n        };\n      };\n    };\n  } = Object.create(null);\n\n  private toBeAdded: {\n    [__typename: string]: TypePolicy[];\n  } = Object.create(null);\n\n  // Map from subtype names to sets of supertype names. Note that this\n  // representation inverts the structure of possibleTypes (whose keys are\n  // supertypes and whose values are arrays of subtypes) because it tends\n  // to be much more efficient to search upwards than downwards.\n  private supertypeMap = new Map<string, Set<string>>();\n\n  // Any fuzzy subtypes specified by possibleTypes will be converted to\n  // RegExp objects and recorded here. Every key of this map can also be\n  // found in supertypeMap. In many cases this Map will be empty, which\n  // means no fuzzy subtype checking will happen in fragmentMatches.\n  private fuzzySubtypes = new Map<string, RegExp>();\n\n  public readonly cache: InMemoryCache;\n\n  public readonly rootIdsByTypename: Record<string, string> = Object.create(null);\n  public readonly rootTypenamesById: Record<string, string> = Object.create(null);\n\n  public readonly usingPossibleTypes = false;\n\n  constructor(private config: {\n    cache: InMemoryCache;\n    dataIdFromObject?: KeyFieldsFunction;\n    possibleTypes?: PossibleTypesMap;\n    typePolicies?: TypePolicies;\n  }) {\n    this.config = {\n      dataIdFromObject: defaultDataIdFromObject,\n      ...config,\n    };\n\n    this.cache = this.config.cache;\n\n    this.setRootTypename(\"Query\");\n    this.setRootTypename(\"Mutation\");\n    this.setRootTypename(\"Subscription\");\n\n    if (config.possibleTypes) {\n      this.addPossibleTypes(config.possibleTypes);\n    }\n\n    if (config.typePolicies) {\n      this.addTypePolicies(config.typePolicies);\n    }\n  }\n\n  public identify(\n    object: StoreObject,\n    partialContext?: Partial<KeyFieldsContext>,\n  ): [string?, StoreObject?] {\n    const policies = this;\n\n    const typename = partialContext && (\n      partialContext.typename ||\n      partialContext.storeObject?.__typename\n    ) || object.__typename;\n\n    // It should be possible to write root Query fields with writeFragment,\n    // using { __typename: \"Query\", ... } as the data, but it does not make\n    // sense to allow the same identification behavior for the Mutation and\n    // Subscription types, since application code should never be writing\n    // directly to (or reading directly from) those root objects.\n    if (typename === this.rootTypenamesById.ROOT_QUERY) {\n      return [\"ROOT_QUERY\"];\n    }\n\n    // Default context.storeObject to object if not otherwise provided.\n    const storeObject = partialContext && partialContext.storeObject || object;\n\n    const context: KeyFieldsContext = {\n      ...partialContext,\n      typename,\n      storeObject,\n      readField: partialContext && partialContext.readField || function () {\n        const options = normalizeReadFieldOptions(arguments, storeObject);\n        return policies.readField(options, {\n          store: policies.cache[\"data\"],\n          variables: options.variables,\n        });\n      },\n    };\n\n    let id: KeyFieldsResult;\n\n    const policy = typename && this.getTypePolicy(typename);\n    let keyFn = policy && policy.keyFn || this.config.dataIdFromObject;\n    while (keyFn) {\n      const specifierOrId = keyFn(object, context);\n      if (isArray(specifierOrId)) {\n        keyFn = keyFieldsFnFromSpecifier(specifierOrId);\n      } else {\n        id = specifierOrId;\n        break;\n      }\n    }\n\n    id = id ? String(id) : void 0;\n    return context.keyObject ? [id, context.keyObject] : [id];\n  }\n\n  public addTypePolicies(typePolicies: TypePolicies) {\n    Object.keys(typePolicies).forEach(typename => {\n      const {\n        queryType,\n        mutationType,\n        subscriptionType,\n        ...incoming\n      } = typePolicies[typename];\n\n      // Though {query,mutation,subscription}Type configurations are rare,\n      // it's important to call setRootTypename as early as possible,\n      // since these configurations should apply consistently for the\n      // entire lifetime of the cache. Also, since only one __typename can\n      // qualify as one of these root types, these three properties cannot\n      // be inherited, unlike the rest of the incoming properties. That\n      // restriction is convenient, because the purpose of this.toBeAdded\n      // is to delay the processing of type/field policies until the first\n      // time they're used, allowing policies to be added in any order as\n      // long as all relevant policies (including policies for supertypes)\n      // have been added by the time a given policy is used for the first\n      // time. In other words, since inheritance doesn't matter for these\n      // properties, there's also no need to delay their processing using\n      // the this.toBeAdded queue.\n      if (queryType) this.setRootTypename(\"Query\", typename);\n      if (mutationType) this.setRootTypename(\"Mutation\", typename);\n      if (subscriptionType) this.setRootTypename(\"Subscription\", typename);\n\n      if (hasOwn.call(this.toBeAdded, typename)) {\n        this.toBeAdded[typename].push(incoming);\n      } else {\n        this.toBeAdded[typename] = [incoming];\n      }\n    });\n  }\n\n  private updateTypePolicy(typename: string, incoming: TypePolicy) {\n    const existing = this.getTypePolicy(typename);\n    const { keyFields, fields } = incoming;\n\n    function setMerge(\n      existing: { merge?: FieldMergeFunction | boolean; },\n      merge?: FieldMergeFunction | boolean,\n    ) {\n      existing.merge =\n        typeof merge === \"function\" ? merge :\n        // Pass merge:true as a shorthand for a merge implementation\n        // that returns options.mergeObjects(existing, incoming).\n        merge === true ? mergeTrueFn :\n        // Pass merge:false to make incoming always replace existing\n        // without any warnings about data clobbering.\n        merge === false ? mergeFalseFn :\n        existing.merge;\n    }\n\n    // Type policies can define merge functions, as an alternative to\n    // using field policies to merge child objects.\n    setMerge(existing, incoming.merge);\n\n    existing.keyFn =\n      // Pass false to disable normalization for this typename.\n      keyFields === false ? nullKeyFieldsFn :\n      // Pass an array of strings to use those fields to compute a\n      // composite ID for objects of this typename.\n      isArray(keyFields) ? keyFieldsFnFromSpecifier(keyFields) :\n      // Pass a function to take full control over identification.\n      typeof keyFields === \"function\" ? keyFields :\n      // Leave existing.keyFn unchanged if above cases fail.\n      existing.keyFn;\n\n    if (fields) {\n      Object.keys(fields).forEach(fieldName => {\n        const existing = this.getFieldPolicy(typename, fieldName, true)!;\n        const incoming = fields[fieldName];\n\n        if (typeof incoming === \"function\") {\n          existing.read = incoming;\n        } else {\n          const { keyArgs, read, merge } = incoming;\n\n          existing.keyFn =\n            // Pass false to disable argument-based differentiation of\n            // field identities.\n            keyArgs === false ? simpleKeyArgsFn :\n            // Pass an array of strings to use named arguments to\n            // compute a composite identity for the field.\n            isArray(keyArgs) ? keyArgsFnFromSpecifier(keyArgs) :\n            // Pass a function to take full control over field identity.\n            typeof keyArgs === \"function\" ? keyArgs :\n            // Leave existing.keyFn unchanged if above cases fail.\n            existing.keyFn;\n\n          if (typeof read === \"function\") {\n            existing.read = read;\n          }\n\n          setMerge(existing, merge);\n        }\n\n        if (existing.read && existing.merge) {\n          // If we have both a read and a merge function, assume\n          // keyArgs:false, because read and merge together can take\n          // responsibility for interpreting arguments in and out. This\n          // default assumption can always be overridden by specifying\n          // keyArgs explicitly in the FieldPolicy.\n          existing.keyFn = existing.keyFn || simpleKeyArgsFn;\n        }\n      });\n    }\n  }\n\n  private setRootTypename(\n    which: \"Query\" | \"Mutation\" | \"Subscription\",\n    typename: string = which,\n  ) {\n    const rootId = \"ROOT_\" + which.toUpperCase();\n    const old = this.rootTypenamesById[rootId];\n    if (typename !== old) {\n      invariant(!old || old === which, `Cannot change root ${which} __typename more than once`);\n      // First, delete any old __typename associated with this rootId from\n      // rootIdsByTypename.\n      if (old) delete this.rootIdsByTypename[old];\n      // Now make this the only __typename that maps to this rootId.\n      this.rootIdsByTypename[typename] = rootId;\n      // Finally, update the __typename associated with this rootId.\n      this.rootTypenamesById[rootId] = typename;\n    }\n  }\n\n  public addPossibleTypes(possibleTypes: PossibleTypesMap) {\n    (this.usingPossibleTypes as boolean) = true;\n    Object.keys(possibleTypes).forEach(supertype => {\n      // Make sure all types have an entry in this.supertypeMap, even if\n      // their supertype set is empty, so we can return false immediately\n      // from policies.fragmentMatches for unknown supertypes.\n      this.getSupertypeSet(supertype, true);\n\n      possibleTypes[supertype].forEach(subtype => {\n        this.getSupertypeSet(subtype, true)!.add(supertype);\n        const match = subtype.match(TypeOrFieldNameRegExp);\n        if (!match || match[0] !== subtype) {\n          // TODO Don't interpret just any invalid typename as a RegExp.\n          this.fuzzySubtypes.set(subtype, new RegExp(subtype));\n        }\n      });\n    });\n  }\n\n  private getTypePolicy(typename: string): Policies[\"typePolicies\"][string] {\n    if (!hasOwn.call(this.typePolicies, typename)) {\n      const policy: Policies[\"typePolicies\"][string] =\n        this.typePolicies[typename] = Object.create(null);\n      policy.fields = Object.create(null);\n\n      // When the TypePolicy for typename is first accessed, instead of\n      // starting with an empty policy object, inherit any properties or\n      // fields from the type policies of the supertypes of typename.\n      //\n      // Any properties or fields defined explicitly within the TypePolicy\n      // for typename will take precedence, and if there are multiple\n      // supertypes, the properties of policies whose types were added\n      // later via addPossibleTypes will take precedence over those of\n      // earlier supertypes. TODO Perhaps we should warn about these\n      // conflicts in development, and recommend defining the property\n      // explicitly in the subtype policy?\n      //\n      // Field policy inheritance is atomic/shallow: you can't inherit a\n      // field policy and then override just its read function, since read\n      // and merge functions often need to cooperate, so changing only one\n      // of them would be a recipe for inconsistency.\n      //\n      // Once the TypePolicy for typename has been accessed, its\n      // properties can still be updated directly using addTypePolicies,\n      // but future changes to supertype policies will not be reflected in\n      // this policy, because this code runs at most once per typename.\n      const supertypes = this.supertypeMap.get(typename);\n      if (supertypes && supertypes.size) {\n        supertypes.forEach(supertype => {\n          const { fields, ...rest } = this.getTypePolicy(supertype);\n          Object.assign(policy, rest);\n          Object.assign(policy.fields, fields);\n        });\n      }\n    }\n\n    const inbox = this.toBeAdded[typename];\n    if (inbox && inbox.length) {\n      // Merge the pending policies into this.typePolicies, in the order they\n      // were originally passed to addTypePolicy.\n      inbox.splice(0).forEach(policy => {\n        this.updateTypePolicy(typename, policy);\n      });\n    }\n\n    return this.typePolicies[typename];\n  }\n\n  private getFieldPolicy(\n    typename: string | undefined,\n    fieldName: string,\n    createIfMissing: boolean,\n  ): {\n    keyFn?: KeyArgsFunction;\n    read?: FieldReadFunction<any>;\n    merge?: FieldMergeFunction<any>;\n  } | undefined {\n    if (typename) {\n      const fieldPolicies = this.getTypePolicy(typename).fields;\n      return fieldPolicies[fieldName] || (\n        createIfMissing && (fieldPolicies[fieldName] = Object.create(null)));\n    }\n  }\n\n  private getSupertypeSet(\n    subtype: string,\n    createIfMissing: boolean,\n  ): Set<string> | undefined {\n    let supertypeSet = this.supertypeMap.get(subtype);\n    if (!supertypeSet && createIfMissing) {\n      this.supertypeMap.set(subtype, supertypeSet = new Set<string>());\n    }\n    return supertypeSet;\n  }\n\n  public fragmentMatches(\n    fragment: InlineFragmentNode | FragmentDefinitionNode,\n    typename: string | undefined,\n    result?: Record<string, any>,\n    variables?: Record<string, any>,\n  ): boolean {\n    if (!fragment.typeCondition) return true;\n\n    // If the fragment has a type condition but the object we're matching\n    // against does not have a __typename, the fragment cannot match.\n    if (!typename) return false;\n\n    const supertype = fragment.typeCondition.name.value;\n    // Common case: fragment type condition and __typename are the same.\n    if (typename === supertype) return true;\n\n    if (this.usingPossibleTypes &&\n        this.supertypeMap.has(supertype)) {\n      const typenameSupertypeSet = this.getSupertypeSet(typename, true)!;\n      const workQueue = [typenameSupertypeSet];\n      const maybeEnqueue = (subtype: string) => {\n        const supertypeSet = this.getSupertypeSet(subtype, false);\n        if (supertypeSet &&\n            supertypeSet.size &&\n            workQueue.indexOf(supertypeSet) < 0) {\n          workQueue.push(supertypeSet);\n        }\n      };\n\n      // We need to check fuzzy subtypes only if we encountered fuzzy\n      // subtype strings in addPossibleTypes, and only while writing to\n      // the cache, since that's when selectionSetMatchesResult gives a\n      // strong signal of fragment matching. The StoreReader class calls\n      // policies.fragmentMatches without passing a result object, so\n      // needToCheckFuzzySubtypes is always false while reading.\n      let needToCheckFuzzySubtypes = !!(result && this.fuzzySubtypes.size);\n      let checkingFuzzySubtypes = false;\n\n      // It's important to keep evaluating workQueue.length each time through\n      // the loop, because the queue can grow while we're iterating over it.\n      for (let i = 0; i < workQueue.length; ++i) {\n        const supertypeSet = workQueue[i];\n\n        if (supertypeSet.has(supertype)) {\n          if (!typenameSupertypeSet.has(supertype)) {\n            if (checkingFuzzySubtypes) {\n              invariant.warn(`Inferring subtype ${typename} of supertype ${supertype}`);\n            }\n            // Record positive results for faster future lookup.\n            // Unfortunately, we cannot safely cache negative results,\n            // because new possibleTypes data could always be added to the\n            // Policies class.\n            typenameSupertypeSet.add(supertype);\n          }\n          return true;\n        }\n\n        supertypeSet.forEach(maybeEnqueue);\n\n        if (needToCheckFuzzySubtypes &&\n            // Start checking fuzzy subtypes only after exhausting all\n            // non-fuzzy subtypes (after the final iteration of the loop).\n            i === workQueue.length - 1 &&\n            // We could wait to compare fragment.selectionSet to result\n            // after we verify the supertype, but this check is often less\n            // expensive than that search, and we will have to do the\n            // comparison anyway whenever we find a potential match.\n            selectionSetMatchesResult(fragment.selectionSet, result!, variables)) {\n          // We don't always need to check fuzzy subtypes (if no result\n          // was provided, or !this.fuzzySubtypes.size), but, when we do,\n          // we only want to check them once.\n          needToCheckFuzzySubtypes = false;\n          checkingFuzzySubtypes = true;\n\n          // If we find any fuzzy subtypes that match typename, extend the\n          // workQueue to search through the supertypes of those fuzzy\n          // subtypes. Otherwise the for-loop will terminate and we'll\n          // return false below.\n          this.fuzzySubtypes.forEach((regExp, fuzzyString) => {\n            const match = typename.match(regExp);\n            if (match && match[0] === typename) {\n              maybeEnqueue(fuzzyString);\n            }\n          });\n        }\n      }\n    }\n\n    return false;\n  }\n\n  public hasKeyArgs(typename: string | undefined, fieldName: string) {\n    const policy = this.getFieldPolicy(typename, fieldName, false);\n    return !!(policy && policy.keyFn);\n  }\n\n  public getStoreFieldName(fieldSpec: FieldSpecifier): string {\n    const { typename, fieldName } = fieldSpec;\n    const policy = this.getFieldPolicy(typename, fieldName, false);\n    let storeFieldName: Exclude<ReturnType<KeyArgsFunction>, KeySpecifier>;\n\n    let keyFn = policy && policy.keyFn;\n    if (keyFn && typename) {\n      const context: Parameters<KeyArgsFunction>[1] = {\n        typename,\n        fieldName,\n        field: fieldSpec.field || null,\n        variables: fieldSpec.variables,\n      };\n      const args = argsFromFieldSpecifier(fieldSpec);\n      while (keyFn) {\n        const specifierOrString = keyFn(args, context);\n        if (isArray(specifierOrString)) {\n          keyFn = keyArgsFnFromSpecifier(specifierOrString);\n        } else {\n          // If the custom keyFn returns a falsy value, fall back to\n          // fieldName instead.\n          storeFieldName = specifierOrString || fieldName;\n          break;\n        }\n      }\n    }\n\n    if (storeFieldName === void 0) {\n      storeFieldName = fieldSpec.field\n        ? storeKeyNameFromField(fieldSpec.field, fieldSpec.variables)\n        : getStoreKeyName(fieldName, argsFromFieldSpecifier(fieldSpec));\n    }\n\n    // Returning false from a keyArgs function is like configuring\n    // keyArgs: false, but more dynamic.\n    if (storeFieldName === false) {\n      return fieldName;\n    }\n\n    // Make sure custom field names start with the actual field.name.value\n    // of the field, so we can always figure out which properties of a\n    // StoreObject correspond to which original field names.\n    return fieldName === fieldNameFromStoreName(storeFieldName)\n      ? storeFieldName\n      : fieldName + \":\" + storeFieldName;\n  }\n\n  public readField<V = StoreValue>(\n    options: ReadFieldOptions,\n    context: ReadMergeModifyContext,\n  ): SafeReadonly<V> | undefined {\n    const objectOrReference = options.from;\n    if (!objectOrReference) return;\n\n    const nameOrField = options.field || options.fieldName;\n    if (!nameOrField) return;\n\n    if (options.typename === void 0) {\n      const typename = context.store.getFieldValue<string>(objectOrReference, \"__typename\");\n      if (typename) options.typename = typename;\n    }\n\n    const storeFieldName = this.getStoreFieldName(options);\n    const fieldName = fieldNameFromStoreName(storeFieldName);\n    const existing = context.store.getFieldValue<V>(objectOrReference, storeFieldName);\n    const policy = this.getFieldPolicy(options.typename, fieldName, false);\n    const read = policy && policy.read;\n\n    if (read) {\n      const readOptions = makeFieldFunctionOptions(\n        this,\n        objectOrReference,\n        options,\n        context,\n        context.store.getStorage(\n          isReference(objectOrReference)\n            ? objectOrReference.__ref\n            : objectOrReference,\n          storeFieldName,\n        ),\n      );\n\n      // Call read(existing, readOptions) with cacheSlot holding this.cache.\n      return cacheSlot.withValue(\n        this.cache,\n        read,\n        [existing, readOptions],\n      ) as SafeReadonly<V>;\n    }\n\n    return existing;\n  }\n\n  public getReadFunction(\n    typename: string | undefined,\n    fieldName: string,\n  ): FieldReadFunction | undefined {\n    const policy = this.getFieldPolicy(typename, fieldName, false);\n    return policy && policy.read;\n  }\n\n  public getMergeFunction(\n    parentTypename: string | undefined,\n    fieldName: string,\n    childTypename: string | undefined,\n  ): FieldMergeFunction | undefined {\n    let policy:\n      | Policies[\"typePolicies\"][string]\n      | Policies[\"typePolicies\"][string][\"fields\"][string]\n      | undefined =\n      this.getFieldPolicy(parentTypename, fieldName, false);\n    let merge = policy && policy.merge;\n    if (!merge && childTypename) {\n      policy = this.getTypePolicy(childTypename);\n      merge = policy && policy.merge;\n    }\n    return merge;\n  }\n\n  public runMergeFunction(\n    existing: StoreValue,\n    incoming: StoreValue,\n    { field, typename, merge }: MergeInfo,\n    context: WriteContext,\n    storage?: StorageType,\n  ) {\n    if (merge === mergeTrueFn) {\n      // Instead of going to the trouble of creating a full\n      // FieldFunctionOptions object and calling mergeTrueFn, we can\n      // simply call mergeObjects, as mergeTrueFn would.\n      return makeMergeObjectsFunction(\n        context.store,\n      )(existing as StoreObject,\n        incoming as StoreObject);\n    }\n\n    if (merge === mergeFalseFn) {\n      // Likewise for mergeFalseFn, whose implementation is even simpler.\n      return incoming;\n    }\n\n    // If cache.writeQuery or cache.writeFragment was called with\n    // options.overwrite set to true, we still call merge functions, but\n    // the existing data is always undefined, so the merge function will\n    // not attempt to combine the incoming data with the existing data.\n    if (context.overwrite) {\n      existing = void 0;\n    }\n\n    return merge(existing, incoming, makeFieldFunctionOptions(\n      this,\n      // Unlike options.readField for read functions, we do not fall\n      // back to the current object if no foreignObjOrRef is provided,\n      // because it's not clear what the current object should be for\n      // merge functions: the (possibly undefined) existing object, or\n      // the incoming object? If you think your merge function needs\n      // to read sibling fields in order to produce a new value for\n      // the current field, you might want to rethink your strategy,\n      // because that's a recipe for making merge behavior sensitive\n      // to the order in which fields are written into the cache.\n      // However, readField(name, ref) is useful for merge functions\n      // that need to deduplicate child objects and references.\n      void 0,\n      { typename,\n        fieldName: field.name.value,\n        field,\n        variables: context.variables },\n      context,\n      storage || Object.create(null),\n    ));\n  }\n}\n\nfunction makeFieldFunctionOptions(\n  policies: Policies,\n  objectOrReference: StoreObject | Reference | undefined,\n  fieldSpec: FieldSpecifier,\n  context: ReadMergeModifyContext,\n  storage: StorageType,\n): FieldFunctionOptions {\n  const storeFieldName = policies.getStoreFieldName(fieldSpec);\n  const fieldName = fieldNameFromStoreName(storeFieldName);\n  const variables = fieldSpec.variables || context.variables;\n  const { toReference, canRead } = context.store;\n\n  return {\n    args: argsFromFieldSpecifier(fieldSpec),\n    field: fieldSpec.field || null,\n    fieldName,\n    storeFieldName,\n    variables,\n    isReference,\n    toReference,\n    storage,\n    cache: policies.cache,\n    canRead,\n    readField<T>() {\n      return policies.readField<T>(\n        normalizeReadFieldOptions(arguments, objectOrReference, variables),\n        context,\n      );\n    },\n    mergeObjects: makeMergeObjectsFunction(context.store),\n  };\n}\n\nexport function normalizeReadFieldOptions(\n  readFieldArgs: IArguments,\n  objectOrReference: StoreObject | Reference | undefined,\n  variables?: ReadMergeModifyContext[\"variables\"],\n): ReadFieldOptions {\n  const {\n    0: fieldNameOrOptions,\n    1: from,\n    length: argc,\n  } = readFieldArgs;\n\n  let options: ReadFieldOptions;\n\n  if (typeof fieldNameOrOptions === \"string\") {\n    options = {\n      fieldName: fieldNameOrOptions,\n      // Default to objectOrReference only when no second argument was\n      // passed for the from parameter, not when undefined is explicitly\n      // passed as the second argument.\n      from: argc > 1 ? from : objectOrReference,\n    };\n  } else {\n    options = { ...fieldNameOrOptions };\n    // Default to objectOrReference only when fieldNameOrOptions.from is\n    // actually omitted, rather than just undefined.\n    if (!hasOwn.call(options, \"from\")) {\n      options.from = objectOrReference;\n    }\n  }\n\n  if (__DEV__ && options.from === void 0) {\n    invariant.warn(`Undefined 'from' passed to readField with arguments ${\n      stringifyForDisplay(Array.from(readFieldArgs))\n    }`);\n  }\n\n  if (void 0 === options.variables) {\n    options.variables = variables;\n  }\n\n  return options;\n}\n\nfunction makeMergeObjectsFunction(\n  store: NormalizedCache,\n): MergeObjectsFunction {\n  return function mergeObjects(existing, incoming) {\n    if (isArray(existing) || isArray(incoming)) {\n      throw new InvariantError(\"Cannot automatically merge arrays\");\n    }\n\n    // These dynamic checks are necessary because the parameters of a\n    // custom merge function can easily have the any type, so the type\n    // system cannot always enforce the StoreObject | Reference parameter\n    // types of options.mergeObjects.\n    if (isNonNullObject(existing) &&\n        isNonNullObject(incoming)) {\n      const eType = store.getFieldValue(existing, \"__typename\");\n      const iType = store.getFieldValue(incoming, \"__typename\");\n      const typesDiffer = eType && iType && eType !== iType;\n\n      if (typesDiffer) {\n        return incoming;\n      }\n\n      if (isReference(existing) &&\n          storeValueIsStoreObject(incoming)) {\n        // Update the normalized EntityStore for the entity identified by\n        // existing.__ref, preferring/overwriting any fields contributed by the\n        // newer incoming StoreObject.\n        store.merge(existing.__ref, incoming);\n        return existing;\n      }\n\n      if (storeValueIsStoreObject(existing) &&\n          isReference(incoming)) {\n        // Update the normalized EntityStore for the entity identified by\n        // incoming.__ref, taking fields from the older existing object only if\n        // those fields are not already present in the newer StoreObject\n        // identified by incoming.__ref.\n        store.merge(existing, incoming.__ref);\n        return incoming;\n      }\n\n      if (storeValueIsStoreObject(existing) &&\n          storeValueIsStoreObject(incoming)) {\n        return { ...existing, ...incoming };\n      }\n    }\n\n    return incoming;\n  };\n}\n"]},"metadata":{},"sourceType":"module"}