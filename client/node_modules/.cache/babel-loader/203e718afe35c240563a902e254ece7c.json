{"ast":null,"code":"import arrayFrom from\"../../polyfills/arrayFrom.mjs\";import didYouMean from\"../../jsutils/didYouMean.mjs\";import suggestionList from\"../../jsutils/suggestionList.mjs\";import naturalCompare from\"../../jsutils/naturalCompare.mjs\";import{GraphQLError}from\"../../error/GraphQLError.mjs\";import{isObjectType,isInterfaceType,isAbstractType}from\"../../type/definition.mjs\";/**\n * Fields on correct type\n *\n * A GraphQL document is only valid if all fields selected are defined by the\n * parent type, or are an allowed meta field such as __typename.\n */export function FieldsOnCorrectTypeRule(context){return{Field:function Field(node){var type=context.getParentType();if(type){var fieldDef=context.getFieldDef();if(!fieldDef){// This field doesn't exist, lets look for suggestions.\nvar schema=context.getSchema();var fieldName=node.name.value;// First determine if there are any suggested types to condition on.\nvar suggestion=didYouMean('to use an inline fragment on',getSuggestedTypeNames(schema,type,fieldName));// If there are no suggested types, then perhaps this was a typo?\nif(suggestion===''){suggestion=didYouMean(getSuggestedFieldNames(type,fieldName));}// Report an error, including helpful suggestions.\ncontext.reportError(new GraphQLError(\"Cannot query field \\\"\".concat(fieldName,\"\\\" on type \\\"\").concat(type.name,\"\\\".\")+suggestion,node));}}}};}/**\n * Go through all of the implementations of type, as well as the interfaces that\n * they implement. If any of those types include the provided field, suggest them,\n * sorted by how often the type is referenced.\n */function getSuggestedTypeNames(schema,type,fieldName){if(!isAbstractType(type)){// Must be an Object type, which does not have possible fields.\nreturn[];}var suggestedTypes=new Set();var usageCount=Object.create(null);for(var _i2=0,_schema$getPossibleTy2=schema.getPossibleTypes(type);_i2<_schema$getPossibleTy2.length;_i2++){var possibleType=_schema$getPossibleTy2[_i2];if(!possibleType.getFields()[fieldName]){continue;}// This object type defines this field.\nsuggestedTypes.add(possibleType);usageCount[possibleType.name]=1;for(var _i4=0,_possibleType$getInte2=possibleType.getInterfaces();_i4<_possibleType$getInte2.length;_i4++){var _usageCount$possibleI;var possibleInterface=_possibleType$getInte2[_i4];if(!possibleInterface.getFields()[fieldName]){continue;}// This interface type defines this field.\nsuggestedTypes.add(possibleInterface);usageCount[possibleInterface.name]=((_usageCount$possibleI=usageCount[possibleInterface.name])!==null&&_usageCount$possibleI!==void 0?_usageCount$possibleI:0)+1;}}return arrayFrom(suggestedTypes).sort(function(typeA,typeB){// Suggest both interface and object types based on how common they are.\nvar usageCountDiff=usageCount[typeB.name]-usageCount[typeA.name];if(usageCountDiff!==0){return usageCountDiff;}// Suggest super types first followed by subtypes\nif(isInterfaceType(typeA)&&schema.isSubType(typeA,typeB)){return-1;}if(isInterfaceType(typeB)&&schema.isSubType(typeB,typeA)){return 1;}return naturalCompare(typeA.name,typeB.name);}).map(function(x){return x.name;});}/**\n * For the field name provided, determine if there are any similar field names\n * that may be the result of a typo.\n */function getSuggestedFieldNames(type,fieldName){if(isObjectType(type)||isInterfaceType(type)){var possibleFieldNames=Object.keys(type.getFields());return suggestionList(fieldName,possibleFieldNames);}// Otherwise, must be a Union type, which does not define fields.\nreturn[];}","map":{"version":3,"names":["arrayFrom","didYouMean","suggestionList","naturalCompare","GraphQLError","isObjectType","isInterfaceType","isAbstractType","FieldsOnCorrectTypeRule","context","Field","node","type","getParentType","fieldDef","getFieldDef","schema","getSchema","fieldName","name","value","suggestion","getSuggestedTypeNames","getSuggestedFieldNames","reportError","concat","suggestedTypes","Set","usageCount","Object","create","_i2","_schema$getPossibleTy2","getPossibleTypes","length","possibleType","getFields","add","_i4","_possibleType$getInte2","getInterfaces","_usageCount$possibleI","possibleInterface","sort","typeA","typeB","usageCountDiff","isSubType","map","x","possibleFieldNames","keys"],"sources":["C:/Users/jarma/school/challenges/Project3_Final/client/src/node_modules/graphql/validation/rules/FieldsOnCorrectTypeRule.mjs"],"sourcesContent":["import arrayFrom from \"../../polyfills/arrayFrom.mjs\";\nimport didYouMean from \"../../jsutils/didYouMean.mjs\";\nimport suggestionList from \"../../jsutils/suggestionList.mjs\";\nimport naturalCompare from \"../../jsutils/naturalCompare.mjs\";\nimport { GraphQLError } from \"../../error/GraphQLError.mjs\";\nimport { isObjectType, isInterfaceType, isAbstractType } from \"../../type/definition.mjs\";\n\n/**\n * Fields on correct type\n *\n * A GraphQL document is only valid if all fields selected are defined by the\n * parent type, or are an allowed meta field such as __typename.\n */\nexport function FieldsOnCorrectTypeRule(context) {\n  return {\n    Field: function Field(node) {\n      var type = context.getParentType();\n\n      if (type) {\n        var fieldDef = context.getFieldDef();\n\n        if (!fieldDef) {\n          // This field doesn't exist, lets look for suggestions.\n          var schema = context.getSchema();\n          var fieldName = node.name.value; // First determine if there are any suggested types to condition on.\n\n          var suggestion = didYouMean('to use an inline fragment on', getSuggestedTypeNames(schema, type, fieldName)); // If there are no suggested types, then perhaps this was a typo?\n\n          if (suggestion === '') {\n            suggestion = didYouMean(getSuggestedFieldNames(type, fieldName));\n          } // Report an error, including helpful suggestions.\n\n\n          context.reportError(new GraphQLError(\"Cannot query field \\\"\".concat(fieldName, \"\\\" on type \\\"\").concat(type.name, \"\\\".\") + suggestion, node));\n        }\n      }\n    }\n  };\n}\n/**\n * Go through all of the implementations of type, as well as the interfaces that\n * they implement. If any of those types include the provided field, suggest them,\n * sorted by how often the type is referenced.\n */\n\nfunction getSuggestedTypeNames(schema, type, fieldName) {\n  if (!isAbstractType(type)) {\n    // Must be an Object type, which does not have possible fields.\n    return [];\n  }\n\n  var suggestedTypes = new Set();\n  var usageCount = Object.create(null);\n\n  for (var _i2 = 0, _schema$getPossibleTy2 = schema.getPossibleTypes(type); _i2 < _schema$getPossibleTy2.length; _i2++) {\n    var possibleType = _schema$getPossibleTy2[_i2];\n\n    if (!possibleType.getFields()[fieldName]) {\n      continue;\n    } // This object type defines this field.\n\n\n    suggestedTypes.add(possibleType);\n    usageCount[possibleType.name] = 1;\n\n    for (var _i4 = 0, _possibleType$getInte2 = possibleType.getInterfaces(); _i4 < _possibleType$getInte2.length; _i4++) {\n      var _usageCount$possibleI;\n\n      var possibleInterface = _possibleType$getInte2[_i4];\n\n      if (!possibleInterface.getFields()[fieldName]) {\n        continue;\n      } // This interface type defines this field.\n\n\n      suggestedTypes.add(possibleInterface);\n      usageCount[possibleInterface.name] = ((_usageCount$possibleI = usageCount[possibleInterface.name]) !== null && _usageCount$possibleI !== void 0 ? _usageCount$possibleI : 0) + 1;\n    }\n  }\n\n  return arrayFrom(suggestedTypes).sort(function (typeA, typeB) {\n    // Suggest both interface and object types based on how common they are.\n    var usageCountDiff = usageCount[typeB.name] - usageCount[typeA.name];\n\n    if (usageCountDiff !== 0) {\n      return usageCountDiff;\n    } // Suggest super types first followed by subtypes\n\n\n    if (isInterfaceType(typeA) && schema.isSubType(typeA, typeB)) {\n      return -1;\n    }\n\n    if (isInterfaceType(typeB) && schema.isSubType(typeB, typeA)) {\n      return 1;\n    }\n\n    return naturalCompare(typeA.name, typeB.name);\n  }).map(function (x) {\n    return x.name;\n  });\n}\n/**\n * For the field name provided, determine if there are any similar field names\n * that may be the result of a typo.\n */\n\n\nfunction getSuggestedFieldNames(type, fieldName) {\n  if (isObjectType(type) || isInterfaceType(type)) {\n    var possibleFieldNames = Object.keys(type.getFields());\n    return suggestionList(fieldName, possibleFieldNames);\n  } // Otherwise, must be a Union type, which does not define fields.\n\n\n  return [];\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}